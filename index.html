<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Library ‚Äî Minimal Shell v1.1.0</title>
  <link rel="stylesheet" href="styles.css?v=1.1.0&bust=20250910106000" />
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Main menu">
      <div class="brand">
        <div class="hamburger">
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
        </div>
        <span>Image Library</span>
      </div>
      <nav class="menu">
        <a id="nav-library" class="menu__item is-active" href="#">Image Library</a>
        <a id="nav-upload" class="menu__item" href="#">Upload Image</a>
        <a id="nav-project" class="menu__item" href="#">Project</a>
        <a id="nav-tags" class="menu__item" href="#">Tags</a>
        <a id="nav-admin" class="menu__item is-hidden" href="#">Admin Panel</a>
        <a id="nav-settings" class="menu__item" href="#" onclick="openSettings()">Settings</a>
      </nav>

      <div class="version-wrapper">
          <span class="version" id="app-version">v1.1.0</span>
      </div>

      <div class="sidebar__footer">
        <button id="nav-logout" class="button button--logout" type="button" onclick="logout()">üö™ Logout</button>
      </div>
    </aside>

    <main class="content">
      <!-- Image Library Page (Default) -->
      <div id="page-library" class="page">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <h1 class="title">Image Library</h1>
              <div class="legend" style="margin-top:8px;">Solid = Objective, Dashed = Subjective</div>
            </div>
            <div id="user-email-display" class="user-email-display"></div>
          </div>

          <!-- Broken Image Notification -->
          <div id="broken-image-notification" class="broken-image-notification hidden">
            <div class="notification-content">
              <span class="notification-icon">‚ö†Ô∏è</span>
              <span class="notification-text">
                <span id="broken-count">0</span> images could not be loaded.
                <span class="notification-reason">Backend server may not be running.</span>
              </span>
              <button id="dismiss-notification" class="notification-dismiss">‚úï</button>
            </div>
          </div>
          <div id="selection-controls" class="selection-controls is-hidden">
            <button id="select-all-btn" class="button" type="button">Select All</button>
            <button id="deselect-all-btn" class="button" type="button">Deselect All</button>
            <button id="view-pool-btn" class="button" type="button">View Selection Pool</button>
            <button id="back-to-library-btn" class="button is-hidden" type="button">Back to Library</button>
            <button id="add-to-project-btn" class="button button--primary" type="button">Add to Project</button>
            <span id="selection-count" class="selection-count">0 selected</span>
          </div>
        </header>
        <section class="panel">
          <div class="search-bar">
            <div class="search-input-row">
              <div class="autocomplete-container">
                <input type="text" id="library-search-input" placeholder="Enter tags separated by commas..."
                       autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       spellcheck="false"
                       data-form-type="other">
                <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
              </div>
              <button id="clear-all-tags" class="button clear-tags-btn" type="button">Clear All</button>
            </div>
            <div id="library-search-chips" class="chips search-chips"></div>
            <button id="update-tag-btn" class="button update-tag-btn is-hidden" type="button">Update Tag</button>
            <button id="delete-image-btn" class="button delete-image-btn is-hidden" type="button">Delete Image</button>

          </div>
          <div id="library-grid" class="preview-grid"></div>
        </section>
      </div>

      <!-- Upload Image Page -->
      <div id="page-upload" class="page is-hidden">
          <header class="content__header">
            <div class="header-content-wrapper">
              <div class="header-left">
                <h1 class="title">Upload Images</h1>
              </div>
              <div id="user-email-display-upload" class="user-email-display"></div>
            </div>
          </header>
          <section class="panel">
            <div id="dropzone" class="upload-area">
              <div class="preview-header">
                <h2 class="panel__title">Selected Images</h2>
                <div class="upload-actions">
                  <input type="file" id="file-input" class="file-input" multiple />
                  <label for="file-input" class="button">Browse Files</label>
                  <button id="clear-all" class="button" type="button">Clear All</button>
                </div>
              </div>
              <p class="text">Browse, drag & drop, or paste images</p>
              <div id="preview-grid" class="preview-grid"></div>
            </div>
            <div class="upload-actions">
                <button id="upload-button" class="button button--primary" type="button">Upload</button>
            </div>
          </section>

          <!-- Layer 3: Tag panels -->
          <section class="panel">
            <div class="apply-scope">
              Apply to: <button id="apply-all" class="button" type="button">All images</button>
              <button id="apply-selected" class="button" type="button">Selected only</button>
              <span class="legend">Solid = Objective, Dashed = Subjective</span>
            </div>

            <div class="tag-panels">
              <div class="tag-panel tag-panel--objective">
                <div class="tag-panel__header is-objective" style="display: none;">
                  OBJECTIVE (FACTS)
                </div>
                <div class="tag-panel__body" style="padding-top: 8px;">
                  <div style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 8px;">
                    <button id="auto-fill-btn" class="button auto-fill-btn" type="button">Auto Fill</button>
                  </div>
                  <!-- Location Fields -->
                  <div class="metadata-section">
                    <h4>Location</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        book: <input id="obj-book" type="text" placeholder="Album-01" data-prefix="book:" />
                      </label>
                      <label class="tag-input">
                        page: <input id="obj-page" type="text" placeholder="15" data-prefix="page:" />
                      </label>
                      <label class="tag-input">
                        row: <input id="obj-row" type="text" placeholder="3" data-prefix="row:" />
                      </label>
                      <label class="tag-input">
                        column: <input id="obj-column" type="text" placeholder="2" data-prefix="column:" />
                      </label>
                    </div>
                  </div>

                  <!-- Item Details -->
                  <div class="metadata-section">
                    <h4>Item Details</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        type: <input id="obj-type" type="text" placeholder="stamp" data-prefix="type:" />
                      </label>
                      <label class="tag-input">
                        material: <input id="obj-material" type="text" placeholder="paper" data-prefix="material:" />
                      </label>
                      <label class="tag-input">
                        width (mm): <input id="obj-width" type="text" placeholder="25" class="dimension-field" data-prefix="width:" />
                      </label>
                      <label class="tag-input">
                        length (mm): <input id="obj-length" type="text" placeholder="30" class="dimension-field" data-prefix="length:" />
                      </label>
                    </div>
                  </div>

                  <!-- Remark -->
                  <div class="metadata-section">
                    <h4>Remark</h4>
                      <label class="tag-input">
                        remark: <input id="obj-remark" type="text" placeholder="excellent condition, rare find" data-prefix="remark:" />
                      </label>
                  </div>

                  <!-- Original Fields -->
                  <div class="metadata-section">
                    <h4>Additional Tags</h4>
                      <label class="tag-input">
                        brand: <input id="obj-brand" type="text" placeholder="nike" data-prefix="brand:" />
                      </label>
                      <label class="tag-input">
                        color: <input id="obj-color" type="text" placeholder="red" data-prefix="color:" />
                      </label>
                  </div>

                  <div id="obj-chips" class="chips"></div>
                </div>
              </div>

              <div class="tag-panel tag-panel--subjective">
                <div class="tag-panel__header is-subjective" style="display: none;">SUBJECTIVE (FEELINGS)</div>
                <div class="tag-panel__body" style="padding-top: 8px;">
                  <div class="subj-inline">
                    <div>
                      <label class="tag-input">Add feelings:
                        <input id="subj-input" type="text" placeholder="type and press Enter/Tab" />
                      </label>
                      <div class="hint">Press Enter or Tab to add; Backspace removes last when empty</div>
                    </div>
                    <div id="subj-chips" class="chips"></div>
                  </div>
                </div>
              </div>
            </div>
          </section>
      </div>

      <!-- Project Page -->
      <div id="page-project" class="page is-hidden">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <div class="project-header-row">
                <h1 class="title">Projects</h1>
                <div class="project-view-toggle">
                  <button id="project-view-toggle-btn" class="button is-small">
                    <span id="toggle-icon">üìã</span>
                    <span id="toggle-text">Detailed View</span>
                  </button>
                </div>
              </div>
            </div>
            <div class="header-right">
              <div id="user-email-display-project" class="user-email-display"></div>
            </div>
          </div>
        </header>
        <section class="panel">
          <!-- Project Search Bar -->
          <div class="project-search-bar">
            <input type="text" id="project-search-input" placeholder="Search project name..." autocomplete="off">
            <button id="project-filter-btn" class="button" type="button">Filter</button>
          </div>
          <div id="project-list" class="project-list">
            <p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>
          </div>
        </section>
      </div>

      <!-- Admin Panel Page -->
      <div id="page-admin" class="page is-hidden">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <h1 class="title">Admin Panel - User Management</h1>
            </div>
            <div class="header-right">
              <div id="user-email-display-admin" class="user-email-display"></div>
            </div>
          </div>
        </header>
        <section class="panel">
          <div id="admin-message" class="admin-message hidden"></div>
          
          <div class="users-section">
            <div class="section-header">
              User Access Management
            </div>
            
            <div id="admin-loading" class="admin-loading">
              Loading users...
            </div>
            
            <div id="admin-users-content" class="hidden">
              <table class="users-table">
                <thead>
                  <tr>
                    <th>Email</th>
                    <th>Status</th>
                    <th>Registration Date</th>
                    <th>Last Login</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="admin-users-tbody">
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </div>
    </main>
  </div>





  <!-- Lightbox Modal -->
  <div id="lightbox-modal" class="modal is-hidden">
    <span class="modal-close">&times;</span>
    <a class="prev">&#10094;</a>
    <div class="lightbox-content">
      <img class="modal-content" id="lightbox-image">
      <div id="lightbox-tags" class="lightbox-tags"></div>
    </div>
    <a class="next">&#10095;</a>
  </div>

      <!-- Confirmation Dialog -->
      <div id="confirm-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Upload Successful! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="upload-more-btn" class="button">Upload More</button>
            <button id="go-to-library-btn" class="button is-primary">Go to Library</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for Missing Feelings -->
      <div id="feelings-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please add at least one feeling in the "Add feelings" field before uploading.</p>
          <div class="modal-buttons">
            <button id="ok-feelings-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for No Images Selected -->
      <div id="no-images-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please select images to upload.</p>
          <div class="modal-buttons">
            <button id="ok-no-images-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for Missing Dimensions -->
      <div id="dimension-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please fill in at least one dimension field (width or length) before uploading.</p>
          <div class="modal-buttons">
            <button id="ok-dimension-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>



      <!-- Loading Overlay -->
      <div id="loading-overlay" class="modal is-hidden">
        <div class="modal-content-text">
          Uploading... Please wait.
        </div>
      </div>

      <!-- Project Name Input Modal -->
      <div id="project-name-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <h3>Create New Project</h3>
          <p>Enter a name for your project:</p>
          <input type="text" id="project-name-input" placeholder="Project name..." maxlength="50">
          <div class="modal-buttons">
            <button id="cancel-project-btn" class="button">Cancel</button>
            <button id="create-project-btn" class="button is-primary">Create Project</button>
          </div>
        </div>
      </div>

      <!-- Project Created Confirmation Modal -->
      <div id="project-created-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p id="project-success-message">Project created successfully! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="add-more-projects-btn" class="button">Add More Projects</button>
            <button id="go-to-project-btn" class="button is-primary">Go to Project</button>
          </div>
        </div>
      </div>

      <!-- Image Preview Overlay -->
      <div id="image-preview-overlay" class="image-preview-overlay">
        <div class="image-preview-content">
          <img id="preview-overlay-img" src="" alt="Full Size Preview">
          <button id="preview-overlay-close" class="image-preview-close">‚úï</button>
        </div>
        <!-- Navigation arrows for Selection Pool -->
        <button id="preview-nav-left" class="image-preview-nav-arrow nav-left hidden">‚óÄ</button>
        <button id="preview-nav-right" class="image-preview-nav-arrow nav-right hidden">‚ñ∂</button>
      </div>

      <!-- Project Detail Overlay Modal -->
      <div id="project-detail-modal" class="project-detail-overlay is-hidden">
        <div class="project-detail-content">
          <!-- Project Header (20%) -->
          <div class="project-detail-header">
            <div class="project-info-section">
              <div class="project-title-row">
                <h2 id="project-detail-name">üìÅ Project Name</h2>
                <button id="close-project-detail" class="modal-close-btn">‚úï Close</button>
              </div>
              <div class="project-stats-row">
                <span id="project-detail-date">üìÖ Created: 2024-01-15</span>
                <span id="project-detail-count">üìä Total Images: 12</span>
                <span id="project-detail-owner" style="display: none;">üë§ Created by: </span>
              </div>
              <div class="project-tags-row">
                <span id="project-detail-tags">üè∑Ô∏è Tags: beach, sunset, family</span>
              </div>
            </div>
          </div>

          <!-- Project Image Grid (80%) -->
          <div class="project-detail-grid-container">
            <div id="project-detail-grid" class="project-detail-grid">
              <!-- Project images will be loaded here -->
            </div>
          </div>
        </div>
      </div>

      <!-- Share Project Modal -->
      <div id="share-project-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Share Project</h2>
            <button id="share-project-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Share "<span id="share-project-name"></span>" via email</p>
            <div class="form-group">
              <label for="share-email-input">Recipient Email Address:</label>
              <input type="email" id="share-email-input" placeholder="Enter email address..." required>
            </div>
            <div class="form-group">
              <label for="share-message-input">Optional Message:</label>
              <textarea id="share-message-input" placeholder="Add a personal message (optional)..." rows="3"></textarea>
            </div>
          </div>
          <div class="modal-footer">
            <button id="cancel-share-btn" class="button">Cancel</button>
            <button id="send-share-btn" class="button button-primary">Send Email</button>
          </div>
        </div>
      </div>

      <!-- Email Sending Overlay -->
      <div id="email-sending-overlay" class="email-overlay is-hidden">
        <div class="email-overlay-content">
          <div class="email-spinner"></div>
          <h3>Sending Email...</h3>
          <p>Please wait while we prepare and send your project email.</p>
          <div class="email-progress">
            <div class="email-progress-bar"></div>
          </div>
        </div>
      </div>

      <!-- Update Tag Modal -->
      <div id="update-tag-modal" class="modal-overlay is-hidden">
        <div class="modal-content update-tag-modal-content">
          <div class="modal-header">
            <h2>Update Tags</h2>
            <button id="update-tag-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body update-tag-body">
            <div class="tag-columns">
              <div class="tag-column">
                <h3>Original Tags</h3>
                <div id="original-tags-list" class="tags-list">
                  <!-- Original tags will be populated here -->
                </div>
                <div class="tag-actions-section">
                  <button id="remove-all-tags-btn" class="button remove-all-btn">Remove All Tags</button>
                </div>
              </div>
              <div class="tag-column">
                <h3>New Tags</h3>
                <div id="new-tags-list" class="tags-list">
                  <!-- New tags will be populated here -->
                </div>
                <div class="tag-input-section">
                  <input type="text" id="new-tag-input" placeholder="Add new tags (comma-separated)..." />
                  <button id="add-new-tag-btn" class="button">Add</button>
                </div>
                <div id="tag-warning" class="tag-warning is-hidden">Please enter a tag</div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button id="update-tag-cancel" class="button">Cancel</button>
            <button id="update-tag-save" class="button button-primary">Save</button>
          </div>
        </div>
      </div>

      <!-- Tag Update Success Modal -->
      <div id="tag-update-success-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Tags updated successfully!</p>
          <div class="modal-buttons">
            <button id="tag-update-continue-btn" class="button is-primary">Continue</button>
          </div>
        </div>
      </div>

      <!-- Tag Removal Notification Modal -->
      <div id="tag-removal-notification-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p id="tag-removal-message">Tag removed and images deselected!</p>
          <div class="modal-buttons">
            <button id="tag-removal-continue-btn" class="button is-primary">Continue</button>
          </div>
        </div>
      </div>

      <!-- Delete Image Confirmation Modal -->
      <div id="delete-image-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Delete Images</h2>
            <button id="delete-image-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to delete <span id="delete-count">0</span> selected image(s)?</p>
            <p class="warning-text">This action cannot be undone. Images will be permanently removed from the database and file system.</p>
          </div>
          <div class="modal-footer">
            <button id="cancel-delete-btn" class="button">Cancel</button>
            <button id="confirm-delete-btn" class="button button--danger">Delete Images</button>
          </div>
        </div>
      </div>

      <!-- Tag Removal Confirmation Modal -->
      <div id="tag-removal-confirm-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Remove Tag from Selection Pool</h2>
            <button id="tag-removal-confirm-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Do you want to remove all images with the "<span id="tag-removal-tag-name"></span>" tag from the selection pool?</p>
            <p class="warning-text">This will remove <span id="tag-removal-image-count">0</span> image(s) from your current selection.</p>
          </div>
          <div class="modal-footer">
            <button id="tag-removal-cancel-btn" class="button">No, Keep Images</button>
            <button id="tag-removal-confirm-btn" class="button button--danger">Yes, Remove Images</button>
          </div>
        </div>
      </div>

      <!-- Clear All Confirmation Modal -->
      <div id="clear-all-confirm-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Clear All Selections</h2>
            <button id="clear-all-confirm-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to clear all selections and search filters?</p>
            <p class="warning-text">This will remove <span id="clear-all-selection-count">0</span> selected image(s) and <span id="clear-all-tag-count">0</span> search tag(s).</p>
          </div>
          <div class="modal-footer">
            <button id="clear-all-cancel-btn" class="button">Cancel</button>
            <button id="clear-all-confirm-btn" class="button button--danger">Clear All</button>
          </div>
        </div>
      </div>

  <script>
    // --- Constants & State ---
    // Application Version - Increment for each update
    const APP_VERSION = '1.1.0';
    
    // Update version display dynamically
    const versionElement = document.getElementById('app-version');
    if (versionElement) {
        versionElement.textContent = `v${APP_VERSION}`;
    }
    // Update page title
    document.title = `Image Library ‚Äî Minimal Shell v${APP_VERSION}`;

    const API_URL = 'http://localhost:3000';
    const navLinks = {
        library: document.getElementById('nav-library'),
        upload: document.getElementById('nav-upload'),
        project: document.getElementById('nav-project'),
        admin: document.getElementById('nav-admin'),
    };

    // Broken image tracking
    let brokenImages = [];
    let brokenImageNotificationShown = false;
    let brokenImageNotificationDismissed = localStorage.getItem('brokenImageNotificationDismissed') === 'true';

    // Broken image functions
    function trackBrokenImage(imageId, imageSrc) {
        if (!brokenImages.find(img => img.id === imageId)) {
            brokenImages.push({ id: imageId, src: imageSrc });
            updateBrokenImageNotification();
        }
    }

    function updateBrokenImageNotification() {
        const notification = document.getElementById('broken-image-notification');
        const countElement = document.getElementById('broken-count');

        // Only show notification if user hasn't dismissed it permanently
        if (brokenImages.length > 0 && !brokenImageNotificationDismissed) {
            countElement.textContent = brokenImages.length;
            notification.classList.remove('hidden');

            // Log broken images for debugging
            console.warn(`${brokenImages.length} images failed to load:`, brokenImages);
        } else {
            notification.classList.add('hidden');
        }
    }

    function clearBrokenImageTracking() {
        brokenImages = [];
        updateBrokenImageNotification();
    }

    // Function to reset notification dismissal (for development/testing)
    function resetBrokenImageNotificationDismissal() {
        brokenImageNotificationDismissed = false;
        localStorage.removeItem('brokenImageNotificationDismissed');
        updateBrokenImageNotification();
        console.log('Broken image notification dismissal reset - notifications will show again');
    }
    const pages = {
        library: document.getElementById('page-library'),
        upload: document.getElementById('page-upload'),
        project: document.getElementById('page-project'),
        admin: document.getElementById('page-admin'),
    };
    const fileInput = document.getElementById('file-input');
    const previewGrid = document.getElementById('preview-grid');
    const clearAllButton = document.getElementById('clear-all');
    const dropzone = document.getElementById('dropzone');
    const subjInput = document.getElementById('subj-input');
    const subjChips = document.getElementById('subj-chips');

    // Objective metadata inputs
    const objBookInput = document.getElementById('obj-book');
    const objPageInput = document.getElementById('obj-page');
    const objRowInput = document.getElementById('obj-row');
    const objColumnInput = document.getElementById('obj-column');
    const objTypeInput = document.getElementById('obj-type');
    const objMaterialInput = document.getElementById('obj-material');
    const objWidthInput = document.getElementById('obj-width');
    const objLengthInput = document.getElementById('obj-length');
    const objRemarkInput = document.getElementById('obj-remark');
    const objBrandInput = document.getElementById('obj-brand');
    const objColorInput = document.getElementById('obj-color');
    const objChips = document.getElementById('obj-chips');
    const autoFillBtn = document.getElementById('auto-fill-btn');
    const modal = document.getElementById('lightbox-modal');
    const modalImg = document.getElementById('lightbox-image');
    const lightboxTags = document.getElementById('lightbox-tags');
    const closeModal = document.querySelector('.modal-close');
    const prevButton = document.querySelector('.prev');
    const nextButton = document.querySelector('.next');
    const uploadButton = document.getElementById('upload-button');
    const librarySearchInput = document.getElementById('library-search-input');
    const libraryGrid = document.getElementById('library-grid');
    
    // Pagination state
    let currentPage = 0;
    let imagesPerRow = 0;
    let allImagesToDisplay = []; // Store all images for pagination
    const ROWS_PER_PAGE = 3;
    const librarySearchChips = document.getElementById('library-search-chips');
    const autocompleteDropdown = document.getElementById('autocomplete-dropdown');

    // Header title element for dynamic updates
    const libraryTitle = document.querySelector('#page-library .title');
    const clearAllTagsBtn = document.getElementById('clear-all-tags');
    // Removed searchModeRadios - using default OR mode

    // Selection and project elements
    const selectionControls = document.getElementById('selection-controls');
    const selectAllBtn = document.getElementById('select-all-btn');
    const deselectAllBtn = document.getElementById('deselect-all-btn');
    const updateTagBtn = document.getElementById('update-tag-btn');
    const deleteImageBtn = document.getElementById('delete-image-btn');
    const viewPoolBtn = document.getElementById('view-pool-btn');
    const backToLibraryBtn = document.getElementById('back-to-library-btn');
    const addToProjectBtn = document.getElementById('add-to-project-btn');
    const selectionCount = document.getElementById('selection-count');
    const projectNameModal = document.getElementById('project-name-modal');
    const projectNameInput = document.getElementById('project-name-input');
    const cancelProjectBtn = document.getElementById('cancel-project-btn');
    const createProjectBtn = document.getElementById('create-project-btn');
    const projectList = document.getElementById('project-list');

    // Project created confirmation modal elements
    const projectCreatedModal = document.getElementById('project-created-modal');
    const projectSuccessMessage = document.getElementById('project-success-message');
    const addMoreProjectsBtn = document.getElementById('add-more-projects-btn');
    const goToProjectBtn = document.getElementById('go-to-project-btn');

    // Project search elements
    const projectSearchInput = document.getElementById('project-search-input');
    const projectFilterBtn = document.getElementById('project-filter-btn');

    // Project view toggle elements
    const projectViewToggleBtn = document.getElementById('project-view-toggle-btn');
    const toggleIcon = document.getElementById('toggle-icon');
    const toggleText = document.getElementById('toggle-text');

    // Project detail overlay elements
    const projectDetailModal = document.getElementById('project-detail-modal');
    const closeProjectDetailBtn = document.getElementById('close-project-detail');
    const projectDetailName = document.getElementById('project-detail-name');
    const projectDetailDate = document.getElementById('project-detail-date');
    const projectDetailCount = document.getElementById('project-detail-count');
    const projectDetailOwner = document.getElementById('project-detail-owner');
    const projectDetailTags = document.getElementById('project-detail-tags');
    const projectDetailGrid = document.getElementById('project-detail-grid');

    // Share project modal elements
    const shareProjectModal = document.getElementById('share-project-modal');
    const shareProjectClose = document.getElementById('share-project-close');
    const shareProjectName = document.getElementById('share-project-name');
    const shareEmailInput = document.getElementById('share-email-input');
    const shareMessageInput = document.getElementById('share-message-input');
    const cancelShareBtn = document.getElementById('cancel-share-btn');
    const sendShareBtn = document.getElementById('send-share-btn');
    const emailSendingOverlay = document.getElementById('email-sending-overlay');

    // Update tag modal elements
    const updateTagModal = document.getElementById('update-tag-modal');
    const updateTagClose = document.getElementById('update-tag-close');
    const originalTagsList = document.getElementById('original-tags-list');
    const newTagsList = document.getElementById('new-tags-list');
    const newTagInput = document.getElementById('new-tag-input');
    const addNewTagBtn = document.getElementById('add-new-tag-btn');
    const removeAllTagsBtn = document.getElementById('remove-all-tags-btn');
    const tagWarning = document.getElementById('tag-warning');
    const updateTagCancel = document.getElementById('update-tag-cancel');
    const updateTagSave = document.getElementById('update-tag-save');

    // Delete image modal elements
    const deleteImageModal = document.getElementById('delete-image-modal');
    const deleteImageClose = document.getElementById('delete-image-close');
    const deleteCount = document.getElementById('delete-count');
    const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
    const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
    const tagUpdateSuccessModal = document.getElementById('tag-update-success-modal');
    const tagUpdateContinueBtn = document.getElementById('tag-update-continue-btn');
    const tagRemovalNotificationModal = document.getElementById('tag-removal-notification-modal');
    const tagRemovalMessage = document.getElementById('tag-removal-message');
    const tagRemovalContinueBtn = document.getElementById('tag-removal-continue-btn');

    // Tag removal confirmation modal elements
    const tagRemovalConfirmModal = document.getElementById('tag-removal-confirm-modal');
    const tagRemovalConfirmClose = document.getElementById('tag-removal-confirm-close');
    const tagRemovalTagName = document.getElementById('tag-removal-tag-name');
    const tagRemovalImageCount = document.getElementById('tag-removal-image-count');
    const tagRemovalCancelBtn = document.getElementById('tag-removal-cancel-btn');
    const tagRemovalConfirmBtn = document.getElementById('tag-removal-confirm-btn');

    // Clear all confirmation modal elements
    const clearAllConfirmModal = document.getElementById('clear-all-confirm-modal');
    const clearAllConfirmClose = document.getElementById('clear-all-confirm-close');
    const clearAllSelectionCount = document.getElementById('clear-all-selection-count');
    const clearAllTagCount = document.getElementById('clear-all-tag-count');
    const clearAllCancelBtn = document.getElementById('clear-all-cancel-btn');
    const clearAllConfirmBtn = document.getElementById('clear-all-confirm-btn');

    // Image preview overlay elements
    const imagePreviewOverlay = document.getElementById('image-preview-overlay');
    const previewOverlayImg = document.getElementById('preview-overlay-img');
    const previewOverlayClose = document.getElementById('preview-overlay-close');
    const previewNavLeft = document.getElementById('preview-nav-left');
    const previewNavRight = document.getElementById('preview-nav-right');

    let filesToUpload = [];
    let currentImageIndex = 0;
    let imageSources = [];
    let libraryImages = []; // Store current library images for lightbox navigation
    let searchTags = []; // Store current search tags as chips
    let selectedImages = []; // Store selected image IDs for project creation
    let tagSelectedImages = []; // Store images selected by tags (always show tag icon)
    let imageSelectionSource = {}; // Track how each image was selected: 'manual' or search tag name

    // Update tag modal state
    let tagsToRemove = new Set(); // Track individual tags marked for removal
    let removeAllTags = false; // Track if "Remove All Tags" was clicked
    let tagsToAdd = new Set(); // Track new tags to be added
    let imageSelectionOrder = {}; // Track selection timestamps for ordering
    let tagCreationOrder = {}; // Track when each tag was first created/used
    let projects = []; // Store created projects
    let isPoolView = false; // Track if we're viewing selection pool
    let forceLibraryView = false; // Flag to prevent auto-switching to pool view
    let lastCreatedProject = null; // Store the last created project for navigation
    let isDetailedProjectView = false; // Track if we're in detailed project view mode
    let autocompleteVisible = false; // Track if autocomplete dropdown is visible
    let autocompleteHighlightIndex = -1; // Track highlighted item in autocomplete
    let autocompleteItems = []; // Store current autocomplete suggestions
    let currentUser = null; // Store current logged-in user

    // Selection Pool preview navigation
    let currentPreviewImages = []; // Array of images for navigation
    let currentPreviewIndex = 0; // Current image index in preview
    let isSelectionPoolPreview = false; // Track if we're in Selection Pool preview mode

    // --- Function Definitions ---

    function groupImagesByTagsAndSort(images) {
        console.log('=== groupImagesByTagsAndSort START ===');
        console.log('Input images:', images.map(img => `${img.id}: [${img.tags?.join(',') || 'untagged'}] uploaded: ${img.uploadTime}`));
        console.log('Tag creation order:', tagCreationOrder);


        // Create groups by tag in reverse chronological order (latest tag first)
        const result = [];

        // Get all tags that have been input (from tagCreationOrder) and sort by input timestamp
        const allInputTags = Object.keys(tagCreationOrder).sort((a, b) => {
            const timestampA = tagCreationOrder[a] || 0;
            const timestampB = tagCreationOrder[b] || 0;
            return timestampB - timestampA; // Latest tag first (most recently input)
        });

        console.log('All input tags in reverse chronological order (latest input first):', allInputTags.map(tag => `${tag}: ${tagCreationOrder[tag]}`));

        // Track which images we've already added to prevent duplicates
        const addedImageIds = new Set();

        // For each tag in reverse chronological order (latest first), add ALL images that have this tag
        allInputTags.forEach(tag => {
            const imagesWithThisTag = images.filter(image => {
                const imageTags = image.tags || [];
                return imageTags.includes(tag);
            });

            // Sort images within this tag group by upload time (earliest first)
            imagesWithThisTag.sort((a, b) => {
                const uploadTimeA = a.uploadTime || 0;
                const uploadTimeB = b.uploadTime || 0;
                return uploadTimeA - uploadTimeB; // Earliest upload first
            });

            console.log(`Tag "${tag}" images:`, imagesWithThisTag.map(img =>
                `${img.id} (uploaded: ${img.uploadTime})`
            ));

            // Add these images to result (preventing duplicates across tag groups)
            imagesWithThisTag.forEach(image => {
                if (!addedImageIds.has(image.id)) {
                    result.push(image);
                    addedImageIds.add(image.id);
                }
            });
        });

        // Add ALL manually selected images that haven't been added yet (preserve manual selections)
        const manuallySelectedImages = images.filter(image => {
            const isManuallySelected = selectedImages.includes(image.id) && !tagSelectedImages.includes(image.id);
            return isManuallySelected && !addedImageIds.has(image.id);
        });

        console.log('Manually selected images not yet added:', manuallySelectedImages.map(img => `${img.id} (manual selection, tags: [${img.tags?.join(',') || 'untagged'}])`));

        // Add manually selected images at the end (preventing duplicates)
        manuallySelectedImages.forEach(image => {
            if (!addedImageIds.has(image.id)) {
                result.push(image);
                addedImageIds.add(image.id);
            }
        });

        // Add ALL tag-selected images that haven't been added yet
        const tagSelectedOnlyImages = images.filter(image => {
            const isTagSelected = tagSelectedImages.includes(image.id);
            return isTagSelected && !addedImageIds.has(image.id);
        });

        tagSelectedOnlyImages.forEach(image => {
            if (!addedImageIds.has(image.id)) {
                result.push(image);
                addedImageIds.add(image.id);
            }
        });

        console.log('Final sequence (with untagged manual selections):', result.map(img =>
            `${img.id}: [${img.tags?.join(',') || 'untagged'}] uploaded: ${img.uploadTime}`
        ));
        console.log('=== groupImagesByTagsAndSort END ===');

        // Show missing images in alert
        const missingImages = images.filter(img => !result.find(r => r.id === img.id));
        if (missingImages.length > 0) {
            alert('MISSING IMAGES FOUND:\n' +
                  'Input: ' + images.length + ' images\n' +
                  'Output: ' + result.length + ' images\n' +
                  'Missing IDs: ' + missingImages.map(img => img.id).join(', ') + '\n' +
                  'Missing tags: ' + JSON.stringify(missingImages.map(img => ({id: img.id, tags: img.tags})), null, 2));
        }

        return result;
    }

    function addTagGroupHeaders(images) {
        // Track which tags we've already added headers for
        const addedTagHeaders = new Set();
        const tagGroups = new Map();

        // Group images by ALL their tags (not just first tag)
        images.forEach(image => {
            const imageTags = image.tags || [];
            imageTags.forEach(tag => {
                if (!tagGroups.has(tag)) {
                    tagGroups.set(tag, []);
                }
                tagGroups.get(tag).push(image);
            });
        });

        // Add headers based on current search tags and all input tags
        const currentSearchTags = searchTags.map(tag => tag.text);

        // In pool view, show ALL search tags (green chips) that are currently active
        // In library view with search, show only matching tags
        const tagsToShow = isPoolView ? currentSearchTags :
                          currentSearchTags.length > 0 ? currentSearchTags :
                          Object.keys(tagCreationOrder).sort((a, b) => {
                              const timestampA = tagCreationOrder[a] || 0;
                              const timestampB = tagCreationOrder[b] || 0;
                              return timestampB - timestampA; // Latest tag first
                          });

        // Create a container for tag headers (button-style)
        const tagHeaderContainer = document.createElement('div');
        tagHeaderContainer.className = 'tag-headers-container';

        // Add headers for each tag that has images, showing all current search tags in pool view
        tagsToShow.forEach(tag => {
            // Skip the "car" tag to remove its header
            if (tag === 'car') {
                return;
            }

            const imagesWithThisTag = images.filter(image => {
                const imageTags = image.tags || [];
                return imageTags.includes(tag);
            });

            if (imagesWithThisTag.length > 0 && !addedTagHeaders.has(tag)) {
                const tagHeader = document.createElement('span');
                tagHeader.className = 'tag-group-header';
                tagHeader.textContent = `${tag} (${imagesWithThisTag.length})`;
                tagHeaderContainer.appendChild(tagHeader);
                addedTagHeaders.add(tag);
            }
        });

        // Add header for untagged images if any exist
        const untaggedImages = images.filter(image => {
            const imageTags = image.tags || [];
            return imageTags.length === 0;
        });

        if (untaggedImages.length > 0 && !addedTagHeaders.has('Untagged')) {
            const tagHeader = document.createElement('span');
            tagHeader.className = 'tag-group-header';
            tagHeader.textContent = 'Untagged Images';
            tagHeaderContainer.appendChild(tagHeader);
            addedTagHeaders.add('Untagged');
        }

        // Only add the container if it has headers
        if (tagHeaderContainer.children.length > 0) {
            libraryGrid.appendChild(tagHeaderContainer);
        }
    }

    function updateLibraryTitle(isPoolView = false) {
        if (isPoolView) {
            libraryTitle.textContent = 'Image Library (Selection Pool)';
        } else {
            libraryTitle.textContent = 'Image Library';
        }
    }

    function updateSearchInputVisibility() {
        const searchInput = document.getElementById('library-search-input');
        const clearAllBtn = document.getElementById('clear-all-tags');
        const libraryTitle = document.querySelector('#page-library .title');

        // Check if we're in Selection Pool view by multiple criteria
        const isSelectionPool = libraryTitle && libraryTitle.textContent.includes('Selection Pool');
        const hasTagSearch = searchTags.length > 0;
        const hasSelectedImages = selectedImages.length > 0;

        console.log('updateSearchInputVisibility - isPoolView:', isPoolView, 'isSelectionPool:', isSelectionPool, 'hasTagSearch:', hasTagSearch, 'hasSelectedImages:', hasSelectedImages);

        if (isPoolView || isSelectionPool || (hasTagSearch && hasSelectedImages)) {
            // DISABLE search input and clear button in Selection Pool view
            searchInput.disabled = true;
            clearAllBtn.disabled = true;

            // Add visual styling for disabled state
            searchInput.style.opacity = '0.5';
            searchInput.style.cursor = 'not-allowed';
            clearAllBtn.style.opacity = '0.5';
            clearAllBtn.style.cursor = 'not-allowed';

            console.log('Search input/clear DISABLED for Selection Pool view');
        } else {
            // ENABLE search controls in regular Library view
            searchInput.disabled = false;
            clearAllBtn.disabled = false;

            // Remove visual styling for disabled state
            searchInput.style.opacity = '1';
            searchInput.style.cursor = 'text';
            clearAllBtn.style.opacity = '1';
            clearAllBtn.style.cursor = 'pointer';

            console.log('Search controls ENABLED for regular Library view');
        }
    }

    // Calculate how many images fit per row based on grid width
    function calculateImagesPerRow() {
        if (!libraryGrid || libraryGrid.offsetWidth === 0) {
            // Fallback: estimate based on 150px card width + 8px gap
            imagesPerRow = Math.floor((window.innerWidth * 0.88) / 158); // 88% of viewport width
            return;
        }
        const gridWidth = libraryGrid.offsetWidth;
        const cardWidth = 150; // From CSS: grid-template-columns: repeat(auto-fill, 150px)
        const gap = 8; // From CSS: gap: 8px
        imagesPerRow = Math.floor((gridWidth + gap) / (cardWidth + gap));
        if (imagesPerRow < 1) imagesPerRow = 1; // Minimum 1 image per row
    }

    // Show loading skeleton cards
    function showLoadingSkeletons() {
        const skeletonCount = imagesPerRow * ROWS_PER_PAGE;
        for (let i = 0; i < skeletonCount; i++) {
            const skeleton = document.createElement('div');
            skeleton.className = 'preview-card library-card skeleton-card';
            skeleton.innerHTML = '<div class="skeleton-shimmer"></div>';
            libraryGrid.appendChild(skeleton);
        }
    }

    // Create an image card (normal or greyscale indicator)
    function createImageCard(image, index, imageSrc, currentSearchTags, isGreyscaleIndicator = false) {
        const card = document.createElement('div');
        card.className = 'preview-card library-card';
        card.dataset.imageId = image.id;
        
        if (isGreyscaleIndicator) {
            card.classList.add('greyscale-indicator');
        }

        const img = document.createElement('img');
        img.src = imageSrc;
        
        if (isGreyscaleIndicator) {
            // Greyscale images are non-clickable visual indicators
            img.style.filter = 'grayscale(100%)';
            img.style.opacity = '0.6';
            img.style.pointerEvents = 'none';
            card.style.pointerEvents = 'none';
            card.style.cursor = 'default';
        } else {
            // Normal images are clickable
            img.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Image clicked:', image.id, 'isPoolView:', isPoolView, 'index:', index);
                toggleImageSelection(image.id, card);
            });
            img.style.cursor = 'pointer';
            if (isPoolView) {
                card.style.cursor = 'pointer';
            }
        }

        card.appendChild(img);
        
        // Add "chosen" overlay text for greyscale indicators (after image so it appears on top)
        if (isGreyscaleIndicator) {
            const chosenOverlay = document.createElement('div');
            chosenOverlay.className = 'chosen-overlay';
            chosenOverlay.textContent = 'chosen';
            card.appendChild(chosenOverlay);
        }

        // Add hover tooltip for width/length dimensions
        if (image.width || image.length) {
            const dimensionTooltip = document.createElement('div');
            dimensionTooltip.className = 'dimension-tooltip';
            const widthText = image.width ? `Width: ${image.width}` : '';
            const lengthText = image.length ? `Length: ${image.length}` : '';
            const separator = (widthText && lengthText) ? ' | ' : '';
            dimensionTooltip.textContent = widthText + separator + lengthText;
            card.appendChild(dimensionTooltip);
        }

        // Add eye icon for image preview (only for non-greyscale images)
        if (!isGreyscaleIndicator) {
            const eyeIcon = document.createElement('div');
            eyeIcon.className = 'image-preview-eye';
            eyeIcon.textContent = '1:1';
            eyeIcon.title = 'Preview full size image';

            eyeIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                const libraryTitle = document.querySelector('#page-library .title');
                const isSelectionPoolView = isPoolView || (libraryTitle && libraryTitle.textContent.includes('Selection Pool'));

                console.log('Lens clicked - isPoolView:', isPoolView, 'isSelectionPoolView:', isSelectionPoolView);

                if (isSelectionPoolView) {
                    console.log('Opening Selection Pool preview for image:', image.id, 'at index:', index);
                    showSelectionPoolPreview(image, allImagesToDisplay, index);
                } else {
                    console.log('Opening regular library preview for image:', image.id);
                    showImagePreviewOverlay(imageSrc, image);
                }
            });

            card.appendChild(eyeIcon);
        }

        // Add booklet icon for lightbox preview (only in Selection Pool view and non-greyscale)
        if (isPoolView && !isGreyscaleIndicator) {
            const bookletIcon = document.createElement('div');
            bookletIcon.className = 'image-preview-booklet';
            bookletIcon.textContent = 'üìñ';
            bookletIcon.title = 'Open lightbox with navigation';

            bookletIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Booklet clicked, opening lightbox for index:', index);
                openLibraryLightbox(index);
            });

            card.appendChild(bookletIcon);
        }

        // Add tag overlay - show only subjective tags (exclude objective metadata like width/length)
        const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
        const isTagSelected = tagSelectedImages.includes(image.id);
        const allImageTags = image.tags || [];
        
        // Filter out objective metadata tags (width, length, book, page, row, column, type, material, remark, brand, color)
        const objectivePrefixes = ['width:', 'length:', 'book:', 'page:', 'row:', 'column:', 'type:', 'material:', 'remark:', 'brand:', 'color:'];
        const subjectiveTags = allImageTags.filter(tag => {
            const tagLower = tag.toLowerCase();
            return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
        });

        if (subjectiveTags.length > 0) {
            const tagOverlay = document.createElement('div');
            tagOverlay.className = 'tag-overlay';

            // Check if any of the matching tags are subjective
            const matchingSubjectiveTags = matchingTags.filter(tag => {
                const tagLower = tag.toLowerCase();
                return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
            });

            // Always show all tags (or first 3 + count), but highlight if there are matches
            if (matchingSubjectiveTags.length > 0) {
                tagOverlay.classList.add('has-matches');
            }

            // Show first 3 subjective tags
            tagOverlay.textContent = subjectiveTags.slice(0, 3).join(', ');
            if (subjectiveTags.length > 3) {
                tagOverlay.textContent += ` +${subjectiveTags.length - 3}`;
            }

            card.appendChild(tagOverlay);
        }

        // Add creator email display (only for non-greyscale images)
        if (!isGreyscaleIndicator && image.ownership) {
            const creatorOverlay = document.createElement('div');
            creatorOverlay.className = 'creator-overlay';
            creatorOverlay.textContent = `üë§ ${image.ownership}`;
            creatorOverlay.title = `Created by: ${image.ownership}`;
            card.appendChild(creatorOverlay);
        }

        // Handle selection state (only for non-greyscale images)
        if (!isGreyscaleIndicator) {
            const wasAlreadySelected = selectedImages.includes(image.id);
            const hasMatchingTags = currentSearchTags.length > 0 && matchingTags.length > 0;

            // Handle selection logic (same for both pool view and library view)
            if (wasAlreadySelected || hasMatchingTags) {
                card.classList.add('selected');

                // Add pool-view class if in pool view for styling
                if (isPoolView) {
                    card.classList.add('pool-view');
                }

                // Add visual indicator for selection type - prioritize tag selection
                if (isTagSelected) {
                    card.classList.add('tag-selection');
                } else if (hasMatchingTags) {
                    card.classList.add('tag-selection');
                } else if (wasAlreadySelected) {
                    card.classList.add('manual-selection');
                }

                // Only add to selectedImages if not already there
                if (!wasAlreadySelected) {
                    selectedImages.push(image.id);
                }
            }
        }

        return card;
    }

    // Display a page of images (3 rows)
    function displayImagePage(loadedImages, currentSearchTags) {
        const imagesToShow = imagesPerRow * ROWS_PER_PAGE;
        const startIndex = currentPage * imagesToShow;
        const endIndex = startIndex + imagesToShow;
        const pageImages = loadedImages.slice(startIndex, endIndex);

        // Check if we should show selected images at front (library view with selections, not pool view, first page only)
        const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
        const shouldShowSelectedAtFront = !isPoolView && allSelectedImageIds.length > 0 && currentPage === 0;
        
        if (shouldShowSelectedAtFront) {
            // First, display selected images at the front (in color, clickable)
            // Get selected images in their original order from loadedImages
            const selectedImagesData = loadedImages.filter(({ image }) => allSelectedImageIds.includes(image.id));
            selectedImagesData.forEach(({ image, index, imageSrc }) => {
                const card = createImageCard(image, index, imageSrc, currentSearchTags, false);
                libraryGrid.appendChild(card);
            });
        }

        // Then display page images (selected ones will appear as greyscale indicators in their original positions)
        pageImages.forEach(({ image, index, imageSrc }) => {
            const isSelected = allSelectedImageIds.includes(image.id);
            // Only show as greyscale if we're showing selected at front AND this image is selected
            // AND we're on the first page (to avoid showing greyscale on later pages)
            const isGreyscaleIndicator = shouldShowSelectedAtFront && isSelected;
            
            const card = createImageCard(image, index, imageSrc, currentSearchTags, isGreyscaleIndicator);
            libraryGrid.appendChild(card);
        });

        // Calculate displayed count for button
        let displayedCount = startIndex + pageImages.length;
        if (shouldShowSelectedAtFront) {
            // Add selected images count to displayed count
            displayedCount += allSelectedImageIds.length;
        }

        // Add or update "Load More" button
        updateLoadMoreButton(loadedImages.length, displayedCount);
    }

    // Update or add "Load More" and "Load All" buttons
    function updateLoadMoreButton(totalImages, displayedCount) {
        // Remove existing buttons if any
        const existingLoadMoreBtn = document.getElementById('load-more-btn');
        const existingLoadAllBtn = document.getElementById('load-all-btn');
        if (existingLoadMoreBtn) {
            existingLoadMoreBtn.remove();
        }
        if (existingLoadAllBtn) {
            existingLoadAllBtn.remove();
        }

        // Only show buttons if there are more images to load
        if (displayedCount < totalImages) {
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'load-buttons-container';
            
            // Load More button
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.id = 'load-more-btn';
            loadMoreBtn.className = 'load-more-button';
            loadMoreBtn.textContent = 'Load More';
            loadMoreBtn.addEventListener('click', () => {
                loadMoreImages();
            });
            buttonContainer.appendChild(loadMoreBtn);
            
            // Load All button
            const loadAllBtn = document.createElement('button');
            loadAllBtn.id = 'load-all-btn';
            loadAllBtn.className = 'load-all-button';
            loadAllBtn.textContent = 'Load All (but it takes time)';
            loadAllBtn.addEventListener('click', () => {
                loadAllImages();
            });
            buttonContainer.appendChild(loadAllBtn);
            
            libraryGrid.appendChild(buttonContainer);
        }
    }

    // Load more images (3 more rows)
    function loadMoreImages() {
        currentPage++;
        // Recalculate images per row in case window was resized
        calculateImagesPerRow();
        
        const loadedImages = libraryImages
            .map((libImg, idx) => {
                const originalImage = allImagesToDisplay.find(img => img.id === libImg.id);
                if (!originalImage || !libImg.loaded) return null;
                return {
                    image: originalImage,
                    index: idx,
                    imageSrc: libImg.src
                };
            })
            .filter(item => item !== null);

        const currentSearchTags = searchTags.map(tag => tag.text);
        displayImagePage(loadedImages, currentSearchTags);
    }

    // Load all remaining images
    function loadAllImages() {
        // Recalculate images per row in case window was resized
        calculateImagesPerRow();
        
        const loadedImages = libraryImages
            .map((libImg, idx) => {
                const originalImage = allImagesToDisplay.find(img => img.id === libImg.id);
                if (!originalImage || !libImg.loaded) return null;
                return {
                    image: originalImage,
                    index: idx,
                    imageSrc: libImg.src
                };
            })
            .filter(item => item !== null);

        const currentSearchTags = searchTags.map(tag => tag.text);
        
        // Clear grid and display all images
        libraryGrid.innerHTML = '';
        
        // Display all images
        loadedImages.forEach(({ image, index, imageSrc }) => {
            const card = document.createElement('div');
            card.className = 'preview-card library-card';
            card.dataset.imageId = image.id;

            const img = document.createElement('img');
            img.src = imageSrc;

            img.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleImageSelection(image.id, card);
            });

            img.style.cursor = 'pointer';
            if (isPoolView) {
                card.style.cursor = 'pointer';
            }

            card.appendChild(img);

            if (image.width || image.length) {
                const dimensionTooltip = document.createElement('div');
                dimensionTooltip.className = 'dimension-tooltip';
                const widthText = image.width ? `Width: ${image.width}` : '';
                const lengthText = image.length ? `Length: ${image.length}` : '';
                const separator = (widthText && lengthText) ? ' | ' : '';
                dimensionTooltip.textContent = widthText + separator + lengthText;
                card.appendChild(dimensionTooltip);
            }

            const eyeIcon = document.createElement('div');
            eyeIcon.className = 'image-preview-eye';
            eyeIcon.textContent = '1:1';
            eyeIcon.title = 'Preview full size image';

            eyeIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const libraryTitle = document.querySelector('#page-library .title');
                const isSelectionPoolView = isPoolView || (libraryTitle && libraryTitle.textContent.includes('Selection Pool'));

                if (isSelectionPoolView) {
                    showSelectionPoolPreview(image, allImagesToDisplay, index);
                } else {
                    showImagePreviewOverlay(imageSrc, image);
                }
            });

            card.appendChild(eyeIcon);

            if (isPoolView) {
                const bookletIcon = document.createElement('div');
                bookletIcon.className = 'image-preview-booklet';
                bookletIcon.textContent = 'üìñ';
                bookletIcon.title = 'Open lightbox with navigation';

                bookletIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openLibraryLightbox(index);
                });

                card.appendChild(bookletIcon);
            }

            const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
            const isTagSelected = tagSelectedImages.includes(image.id);
            const allImageTags = image.tags || [];
            
            const objectivePrefixes = ['width:', 'length:', 'book:', 'page:', 'row:', 'column:', 'type:', 'material:', 'remark:', 'brand:', 'color:'];
            const subjectiveTags = allImageTags.filter(tag => {
                const tagLower = tag.toLowerCase();
                return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
            });

            if (subjectiveTags.length > 0) {
                const tagOverlay = document.createElement('div');
                tagOverlay.className = 'tag-overlay';

                const matchingSubjectiveTags = matchingTags.filter(tag => {
                    const tagLower = tag.toLowerCase();
                    return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
                });

                if (matchingSubjectiveTags.length > 0) {
                    tagOverlay.classList.add('has-matches');
                }

                tagOverlay.textContent = subjectiveTags.slice(0, 3).join(', ');
                if (subjectiveTags.length > 3) {
                    tagOverlay.textContent += ` +${subjectiveTags.length - 3}`;
                }

                card.appendChild(tagOverlay);
            }

            const wasAlreadySelected = selectedImages.includes(image.id);
            const hasMatchingTags = currentSearchTags.length > 0 && matchingTags.length > 0;

            if (wasAlreadySelected || hasMatchingTags) {
                card.classList.add('selected');

                if (isPoolView) {
                    card.classList.add('pool-view');
                }

                if (isTagSelected) {
                    card.classList.add('tag-selection');
                } else if (hasMatchingTags) {
                    card.classList.add('tag-selection');
                } else if (wasAlreadySelected) {
                    card.classList.add('manual-selection');
                }

                if (!wasAlreadySelected) {
                    selectedImages.push(image.id);
                }
            }

            libraryGrid.appendChild(card);
        });
        
        // Update currentPage to reflect that all images are displayed
        const imagesToShow = imagesPerRow * ROWS_PER_PAGE;
        currentPage = Math.ceil(loadedImages.length / imagesToShow) - 1;
        
        // Remove buttons since all images are now loaded
        updateLoadMoreButton(loadedImages.length, loadedImages.length);
    }
    
    // Recalculate images per row on window resize
    window.addEventListener('resize', () => {
        if (allImagesToDisplay.length > 0) {
            calculateImagesPerRow();
        }
    });

    async function displayLibraryImages() {
        console.log('=== displayLibraryImages START ===');
        console.log('displayLibraryImages called, selectedImages at start:', selectedImages.length);
        console.log('isPoolView at start:', isPoolView);

        const searchMode = 'OR'; // Default to OR mode since radio buttons removed
        const currentSearchTags = searchTags.map(tag => tag.text);
        console.log('currentSearchTags:', currentSearchTags);

        try {
            // Clear broken image tracking for new load
            clearBrokenImageTracking();

            // Get all images first
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const allImagesResponse = await fetch(`${API_URL}/images`, {
                headers: headers
            });
            const allImages = await allImagesResponse.json();


            let imagesToDisplay = [];

            if (isPoolView && currentSearchTags.length === 0) {
                console.log('=== POOL VIEW LOGIC (NO SEARCH TAGS) ===');
                console.log('selectedImages:', selectedImages);
                console.log('tagSelectedImages:', tagSelectedImages);
                // Pool view without search tags - show ALL selected images (both manual and tag-selected)
                const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
                console.log('allSelectedImageIds combined:', allSelectedImageIds);
                imagesToDisplay = allImages.filter(img => allSelectedImageIds.includes(img.id));
                console.log('Pool view filtered images:', imagesToDisplay.length, '(manual + tag selected)');

                console.log('Pool view without search tags - showing all selected images by selection order');
                // Sort by selection order (most recently selected first)
                imagesToDisplay.sort((a, b) => {
                    const orderA = imageSelectionOrder[a.id] || 0;
                    const orderB = imageSelectionOrder[b.id] || 0;
                    return orderB - orderA; // Latest selection first
                });

                console.log('Pool view processing completed');
            } else if (isPoolView && currentSearchTags.length > 0) {
                console.log('=== POOL VIEW LOGIC (WITH SEARCH TAGS) ===');
                console.log('Processing tags first, then combining with existing selections');

                // First, process the search tags to get tag-matching images
                console.log('Fetching tag-matching images for tags:', currentSearchTags);
                const sessionToken = localStorage.getItem('sessionToken');
                const headers = {};
                if (sessionToken) {
                    headers['Authorization'] = `Bearer ${sessionToken}`;
                }
                const tagResponse = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`, {
                    headers: headers
                });

                if (!tagResponse.ok) {
                    throw new Error(`Tag search failed: ${tagResponse.status} ${tagResponse.statusText}`);
                }

                const tagMatchingImages = await tagResponse.json();
                console.log('Tag-matching images found:', tagMatchingImages.length);

                // Update tag-selected images (add new ones, keep existing ones)
                const newTagSelectedImages = tagMatchingImages.map(img => img.id);
                console.log('newTagSelectedImages from tags:', newTagSelectedImages);
                console.log('selectedImages before tag processing:', selectedImages);
                console.log('tagSelectedImages before tag processing:', tagSelectedImages);
                const currentTimestamp = Date.now();

                // Track how each image was selected
                const searchTagsString = currentSearchTags.join(',');
                tagMatchingImages.forEach(image => {
                    if (!imageSelectionSource[image.id]) {
                        imageSelectionSource[image.id] = searchTagsString;
                    }
                });

                // Track selection timestamps for new tag-selected images
                newTagSelectedImages.forEach(imageId => {
                    if (!tagSelectedImages.includes(imageId)) {
                        imageSelectionOrder[imageId] = currentTimestamp;
                    }
                });

                tagSelectedImages = [...new Set([...tagSelectedImages, ...newTagSelectedImages])];

                // DON'T add tag images to selectedImages - keep them separate
                // selectedImages = manual selections only
                // tagSelectedImages = tag selections only
                // Combine them only for display purposes

                console.log('selectedImages after tag processing:', selectedImages);
                console.log('tagSelectedImages after tag processing:', tagSelectedImages);

                // Now combine ALL selections for pool view display
                const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
                console.log('allSelectedImageIds combined for pool view:', allSelectedImageIds);
                imagesToDisplay = allImages.filter(img => allSelectedImageIds.includes(img.id));

                // Group by tags since we have search tags active
                imagesToDisplay = groupImagesByTagsAndSort(imagesToDisplay);

                console.log('Pool view with tags processing completed, final images:', imagesToDisplay.length);
            } else if (currentSearchTags.length === 0) {
                console.log('=== LIBRARY VIEW WITH NO TAGS ===');
                // Library view with no search tags - show all images, latest first
                // DON'T clear tagSelectedImages here - preserve historical tag selections
                imagesToDisplay = allImages;

                // Sort by image ID in descending order (latest uploads first)
                imagesToDisplay.sort((a, b) => b.id - a.id);

                console.log('Library view with no active tags, sorted latest first, preserving tagSelectedImages:', tagSelectedImages.length);
            } else {
                // Library view with search tags - show tag-matching + manually selected images
                console.log('Fetching tag-matching images for tags:', currentSearchTags);
                const sessionToken2 = localStorage.getItem('sessionToken');
                const headers2 = {};
                if (sessionToken2) {
                    headers2['Authorization'] = `Bearer ${sessionToken2}`;
                }
                const tagResponse = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`, {
                    headers: headers2
                });

                if (!tagResponse.ok) {
                    throw new Error(`Tag search failed: ${tagResponse.status} ${tagResponse.statusText}`);
                }

                const tagMatchingImages = await tagResponse.json();
                console.log('Tag-matching images found:', tagMatchingImages.length);

                // Get manually selected images that might not match tags
                const manuallySelectedImages = allImages.filter(img => selectedImages.includes(img.id));
                console.log('Manually selected images:', manuallySelectedImages.length);

                // Combine tag-matching and manually selected images (remove duplicates)
                const combinedImageIds = new Set();
                imagesToDisplay = [];

                // Update tag-selected images (add new ones, keep existing ones)
                const newTagSelectedImages = tagMatchingImages.map(img => img.id);
                console.log('newTagSelectedImages from tags:', newTagSelectedImages);
                console.log('selectedImages before tag processing:', selectedImages);
                console.log('tagSelectedImages before tag processing:', tagSelectedImages);
                const currentTimestamp = Date.now();

                // Track how each image was selected - attribute to the current search operation
                // For this search operation, all matching images are attributed to the search tags being used
                const searchTagsString = currentSearchTags.join(','); // Create a unique identifier for this search
                tagMatchingImages.forEach(image => {
                    // Only set the source if this image wasn't already selected by a previous search
                    if (!imageSelectionSource[image.id]) {
                        imageSelectionSource[image.id] = searchTagsString;
                    }
                });

                // Track selection timestamps for new tag-selected images
                newTagSelectedImages.forEach(imageId => {
                    if (!tagSelectedImages.includes(imageId)) {
                        // New tag selection - record timestamp
                        imageSelectionOrder[imageId] = currentTimestamp;
                    }
                });

                tagSelectedImages = [...new Set([...tagSelectedImages, ...newTagSelectedImages])];

                // DON'T add tag images to selectedImages - keep them separate
                // selectedImages = manual selections only
                // tagSelectedImages = tag selections only

                console.log('selectedImages after tag processing:', selectedImages);
                console.log('tagSelectedImages after tag processing:', tagSelectedImages);

                // Add tag-matching images
                tagMatchingImages.forEach(img => {
                    if (!combinedImageIds.has(img.id)) {
                        combinedImageIds.add(img.id);
                        imagesToDisplay.push(img);
                    }
                });

                // Add manually selected images that weren't already included
                manuallySelectedImages.forEach(img => {
                    if (!combinedImageIds.has(img.id)) {
                        combinedImageIds.add(img.id);
                        imagesToDisplay.push(img);
                    }
                });

                // Group images by tags and sort by tag creation order
                imagesToDisplay = groupImagesByTagsAndSort(imagesToDisplay);

                console.log('Combined images to display:', imagesToDisplay.length, '(grouped by tags and sorted)');
                console.log('Tag-selected images:', tagSelectedImages);
            }

            // Update header based on view type - check if we're showing selection pool
            console.log('=== TITLE UPDATE LOGIC ===');
            console.log('About to update title - isPoolView:', isPoolView);
            console.log('currentSearchTags.length:', currentSearchTags.length);

            const showingSelectionPool = isShowingSelectionPool();
            console.log('isShowingSelectionPool():', showingSelectionPool);

            if (isPoolView) {
                // Always show Selection Pool title when explicitly in pool view
                console.log('Setting title to Selection Pool (explicit pool view)');
                updateLibraryTitle(true);
            } else if (showingSelectionPool && !forceLibraryView) {
                console.log('Setting title to Selection Pool (showing selection pool)');
                updateLibraryTitle(true); // Selection Pool (active search or pool view)
            } else if (currentSearchTags.length > 0 && forceLibraryView) {
                console.log('STAYING in Library view despite search tags (user requested)');
                console.log('currentSearchTags:', currentSearchTags);
                updateLibraryTitle(false); // Keep library title
                forceLibraryView = false; // Reset flag after use
            } else {
                console.log('Setting title to regular Library');
                updateLibraryTitle(false); // Full library
            }

            // Update search input visibility based on view type
            updateSearchInputVisibility();

            // SAFETY CHECK: Always disable search input/clear button if title shows Selection Pool
            setTimeout(() => {
                const libraryTitle = document.querySelector('#page-library .title');
                if (libraryTitle && libraryTitle.textContent.includes('Selection Pool')) {
                    const searchInput = document.getElementById('library-search-input');
                    const clearAllBtn = document.getElementById('clear-all-tags');

                    searchInput.disabled = true;
                    clearAllBtn.disabled = true;

                    searchInput.style.opacity = '0.5';
                    searchInput.style.cursor = 'not-allowed';
                    clearAllBtn.style.opacity = '0.5';
                    clearAllBtn.style.cursor = 'not-allowed';

                    console.log('SAFETY CHECK: Search controls disabled for Selection Pool');
                }
            }, 100);

            const images = imagesToDisplay;
            
            // Store all images for pagination
            allImagesToDisplay = images;
            currentPage = 0; // Reset pagination when loading new images
            
            // Calculate images per row based on grid width
            calculateImagesPerRow();

            libraryGrid.innerHTML = '';
            libraryImages = []; // Reset library images array
            // Keep existing selected images - don't reset selectedImages array

            // Special handling for pool view with no images
            if (isPoolView && images.length === 0) {
                const noImagesMessage = document.createElement('div');
                noImagesMessage.className = 'no-images-message';
                noImagesMessage.style.textAlign = 'center';
                noImagesMessage.style.padding = '40px';
                noImagesMessage.style.color = '#666';
                noImagesMessage.innerHTML = '<p>No images in selection pool.</p><p>You can use "Back to Library" to return to the main library and select more images.</p>';
                libraryGrid.appendChild(noImagesMessage);
                return; // Exit early if no images
            }
            
            // Show loading skeleton cards
            showLoadingSkeletons();

            // Check which tags have matches and update chip colors
            await updateTagChipColors(currentSearchTags, searchMode);

            // Add tag group headers in Selection Pool view OR when there are search tags active
            if ((isPoolView || currentSearchTags.length > 0) && images.length > 0) {
                addTagGroupHeaders(images);
            }

            // Process images with broken image detection
            const imagePromises = images.map(async (image, index) => {
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;

                // Test if image loads
                return new Promise((resolve) => {
                    const testImg = new Image();
                    testImg.onload = () => resolve({ image, index, imageSrc, loaded: true });
                    testImg.onerror = () => {
                        trackBrokenImage(image.id, imageSrc);
                        resolve({ image, index, imageSrc, loaded: false });
                    };
                    testImg.src = imageSrc;
                });
            });

            // Wait for all image load tests to complete
            const imageResults = await Promise.all(imagePromises);

            // Add ALL images to libraryImages (including broken ones) to preserve selections
            imageResults.forEach(({ image, index, imageSrc, loaded }) => {
                libraryImages.push({
                    src: imageSrc,
                    index: index,
                    tags: image.tags || [],
                    id: image.id,
                    loaded: loaded
                });
            });

            // Store all loaded images for pagination
            const loadedImages = imageResults.filter(result => result.loaded);
            
            // Clear loading skeletons and display first page
            libraryGrid.innerHTML = '';
            displayImagePage(loadedImages, currentSearchTags);

            // Show selection controls if there are images and search is active OR if we have selections
            // SPECIAL CASE: Always show controls in pool view, even with no images/selections
            if ((images.length > 0 && (currentSearchTags.length > 0 || selectedImages.length > 0)) || isPoolView) {
                selectionControls.classList.remove('is-hidden');
                updateSelectionState(); // This will call updateButtonVisibility()
            } else {
                selectionControls.classList.add('is-hidden');
                // Only clear selectedImages if we're not in pool view and have no search tags
                if (!isPoolView && currentSearchTags.length === 0) {
                    selectedImages = [];
                }
                updateButtonVisibility(); // Ensure buttons are correct even when no selections
                updateClearButtonState(); // Ensure Clear All button is disabled when no selections
            }

            console.log('displayLibraryImages completed, selectedImages at end:', selectedImages);
        } catch (error) {
            console.error('Error fetching images:', error);
            console.error('Error details:', {
                message: error.message,
                stack: error.stack,
                isPoolView: isPoolView,
                selectedImages: selectedImages,
                searchTags: searchTags
            });
            
            // Show user-friendly error message with retry button
            libraryGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <p style="font-size: 16px; margin-bottom: 8px;">‚ùå Error loading images</p>
                    <p style="font-size: 14px; color: #999; margin-bottom: 16px;">${error.message || 'Please check your connection and try again.'}</p>
                    <button class="button" onclick="displayLibraryImages()" style="margin-top: 8px;">Retry</button>
                </div>
            `;

            // Reset states to prevent getting stuck
            if (isPoolView) {
                console.log('Resetting pool view state due to error');
                isPoolView = false;
                viewPoolBtn.classList.remove('is-hidden');
                backToLibraryBtn.classList.add('is-hidden');
                selectAllBtn.classList.remove('is-hidden');
                deselectAllBtn.classList.remove('is-hidden');
            }
        }
    }

    async function updateTagChipColors(tags, searchMode) {
        for (const tagText of tags) {
            try {
                const sessionToken = localStorage.getItem('sessionToken');
                const headers = {};
                if (sessionToken) {
                    headers['Authorization'] = `Bearer ${sessionToken}`;
                }
                const response = await fetch(`${API_URL}/images?tags=${tagText}&mode=OR`, {
                    headers: headers
                });
                const images = await response.json();
                const hasMatches = images.length > 0;
                const imageCount = images.length;

                // Update the chip color and count based on matches
                const chip = Array.from(librarySearchChips.querySelectorAll('.search-chip')).find(
                    chip => {
                        // Extract tag name from "tagname (count)" format
                        const chipText = chip.textContent.replace(/[√óx]$/, '').trim();
                        const tagName = chipText.replace(/\s*\(\d+\)$/, '');
                        return tagName === tagText;
                    }
                );

                if (chip) {
                    // Update the chip text with new count
                    const deleteBtn = chip.querySelector('.chip-delete');
                    chip.textContent = `${tagText} (${imageCount})`;
                    if (deleteBtn) {
                        chip.appendChild(deleteBtn); // Re-add the delete button
                    }

                    // Update color classes
                    if (hasMatches) {
                        chip.classList.remove('no-matches');
                        chip.classList.add('has-matches');
                    } else {
                        chip.classList.remove('has-matches');
                        chip.classList.add('no-matches');
                    }
                }

                // Update searchTags array
                const tagIndex = searchTags.findIndex(tag => tag.text === tagText);
                if (tagIndex !== -1) {
                    searchTags[tagIndex].hasMatches = hasMatches;
                }
            } catch (error) {
                console.error(`Error checking matches for tag "${tagText}":`, error);
            }
        }
    }

    function navigateTo(pageName) {
        const confirmModal = document.getElementById('confirm-modal');
        // Do not navigate if the confirmation modal is visible
        if (confirmModal && !confirmModal.classList.contains('is-hidden')) {
            return;
        }
        Object.values(pages).forEach(page => page.classList.add('is-hidden'));
        document.querySelectorAll('.menu__item').forEach(link => link.classList.remove('is-active'));
        pages[pageName].classList.remove('is-hidden');
        navLinks[pageName].classList.add('is-active');

        if (pageName === 'library') {
            clearBrokenImageTracking();
            initializeFreshSearchInput();
            displayLibraryImages();
        } else if (pageName === 'project') {
            displayProjects();
        } else if (pageName === 'admin') {
            loadAdminUsers();
        }
    }

    function handleFiles(files) {
        for (const file of files) {
            if (!file.type.startsWith('image/')) continue;
            filesToUpload.push(file);

            const reader = new FileReader();
            reader.onload = (e) => {
                const card = document.createElement('div');
                card.className = 'preview-card';

                const img = document.createElement('img');
                img.src = e.target.result;
                img.addEventListener('click', (event) => {
                    const allImages = Array.from(previewGrid.querySelectorAll('img'));
                    const clickedIndex = allImages.indexOf(event.target);
                    openModal(clickedIndex);
                });

                const del = document.createElement('button');
                del.type = 'button';
                del.className = 'delete-btn';
                del.textContent = '√ó';
                del.addEventListener('click', () => {
                    const indexToRemove = filesToUpload.indexOf(file);
                    if (indexToRemove > -1) {
                        filesToUpload.splice(indexToRemove, 1);
                    }
                    card.remove();
                });

                // Add 1:1 icon for full-size preview
                const previewIcon = document.createElement('div');
                previewIcon.className = 'image-preview-eye';
                previewIcon.textContent = '1:1';
                previewIcon.title = 'Preview full size image';
                const imageSrc = e.target.result; // Store image source for preview
                previewIcon.addEventListener('click', (evt) => {
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Show image in overlay at original size
                    showImagePreviewOverlay(imageSrc, null);
                });

                card.appendChild(del);
                card.appendChild(img);
                card.appendChild(previewIcon);
                previewGrid.appendChild(card);
            };
            reader.readAsDataURL(file);
        }
    }

    function addSubjChip(label) {
        const text = (label || '').toLowerCase().trim();
        if (!text) return;
        if ([...subjChips.querySelectorAll('.chip')].some(c => c.textContent.replace(/[√óx]$/, '').trim() === text)) return;
        const chip = document.createElement('span');
        chip.className = 'chip is-subjective';
        chip.textContent = text;
        chip.tabIndex = 0;
        chip.addEventListener('click', () => chip.classList.toggle('is-selected'));
        const x = document.createElement('button');
        x.type = 'button';
        x.className = 'x';
        x.textContent = '√ó';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        subjChips.appendChild(chip);
    }

    function handleSubjCommit() {
        const parts = subjInput.value.split(',');
        parts.forEach(p => addSubjChip(p));
        subjInput.value = '';
    }

    function handleObjCommit(input) {
        const value = input.value.trim();
        if (value) {
            // Get prefix from data attribute or determine from input id
            const prefix = input.getAttribute('data-prefix') || '';
            // Create tag with prefix (e.g., "book:Album-01" or just "Album-01" if no prefix)
            const tagValue = prefix ? `${prefix}${value}` : value;
            addObjChip(tagValue);
            input.value = '';
        }
    }

    function addObjChip(text) {
        if (!text.trim()) return;

        const chip = document.createElement('div');
        chip.className = 'chip chip--objective';
        chip.textContent = text.trim();

        const x = document.createElement('span');
        x.className = 'chip-remove';
        x.textContent = '√ó';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        objChips.appendChild(chip);
    }

    function autoFillMetadata() {
        // Sample data arrays for random selection
        const sampleData = {
            books: ['Album-01', 'Collection-A', 'Stamps-2024', 'Vintage-Set', 'Modern-Series'],
            pages: ['12', '25', '8', '33', '15', '7', '41'],
            rows: ['1', '2', '3', '4', '5'],
            columns: ['1', '2', '3', '4'],
            types: ['stamp', 'coin', 'banknote', 'postcard', 'photo', 'document'],
            materials: ['paper', 'metal', 'plastic', 'fabric', 'wood', 'ceramic'],
            widths: ['25', '15', '40', '30', '20', '50'],
            lengths: ['30', '20', '25', '35', '25', '30'],
            remarks: [
                'excellent condition, rare find',
                'mint condition, first edition',
                'good condition, slight wear',
                'vintage piece, collector item',
                'pristine condition, never used',
                'historical significance, well preserved'
            ],
            brands: ['royal-mail', 'usps', 'canada-post', 'deutsche-post', 'japan-post'],
            colors: ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'black', 'white']
        };

        // Random selection function
        const random = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // Fill all fields with random sample data (without prefixes in input values)
        if (objBookInput) objBookInput.value = random(sampleData.books);
        if (objPageInput) objPageInput.value = random(sampleData.pages);
        if (objRowInput) objRowInput.value = random(sampleData.rows);
        if (objColumnInput) objColumnInput.value = random(sampleData.columns);
        if (objTypeInput) objTypeInput.value = random(sampleData.types);
        if (objMaterialInput) objMaterialInput.value = random(sampleData.materials);
        if (objWidthInput) objWidthInput.value = random(sampleData.widths);
        if (objLengthInput) objLengthInput.value = random(sampleData.lengths);
        if (objRemarkInput) objRemarkInput.value = random(sampleData.remarks);
        if (objBrandInput) objBrandInput.value = random(sampleData.brands);
        if (objColorInput) objColorInput.value = random(sampleData.colors);

        // Visual feedback
        autoFillBtn.textContent = 'Filled!';
        autoFillBtn.style.background = '#4caf50';
        setTimeout(() => {
            autoFillBtn.textContent = 'Auto Fill';
            autoFillBtn.style.background = '#2196f3';
        }, 1500);
    }

    function updateArrowVisibility() {
        const totalImages = imageSources.length;
        prevButton.style.display = (currentImageIndex > 0 && totalImages > 1) ? 'block' : 'none';
        nextButton.style.display = (currentImageIndex < totalImages - 1 && totalImages > 1) ? 'block' : 'none';
    }

    function openModal(index) {
        currentImageIndex = index;
        imageSources = Array.from(previewGrid.querySelectorAll('img')).map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        updateArrowVisibility();
    }

    function hideModal() {
        modal.classList.add('is-hidden');
    }

    // --- Library Lightbox Functions ---

    function openLibraryLightbox(index) {
        currentImageIndex = index;
        imageSources = libraryImages.map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showLibraryImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        updateArrowVisibility();
    }

    // --- Search Tag Chip Functions ---

    async function addSearchTagChip(tagText, hasMatches = true) {
        const text = tagText.toLowerCase().trim();
        if (!text) return;

        // Check if tag already exists
        if (searchTags.some(tag => tag.text === text)) return;

        // Reset forceLibraryView when user actively adds new tags
        // This allows auto-switching to Selection Pool after "Back to Library"
        forceLibraryView = false;
        console.log('Reset forceLibraryView to false when adding new tag:', text);

        // Track tag input timestamp for ordering (most recent input first)
        const currentTimestamp = Date.now();
        tagCreationOrder[text] = currentTimestamp;
        console.log(`Tag "${text}" input at timestamp:`, currentTimestamp);
        
        // Save the updated tag order
        saveTagCreationOrder();

        // Add to searchTags array
        searchTags.push({ text: text, hasMatches: hasMatches });

        // Create chip element with count
        const chip = document.createElement('span');
        chip.className = hasMatches ? 'chip search-chip' : 'chip search-chip no-matches';

        // Get image count for this tag
        let imageCount = 0;
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images?tags=${text}&mode=OR`, {
                headers: headers
            });
            const images = await response.json();
            imageCount = images.length;
        } catch (error) {
            console.error(`Error getting count for tag "${text}":`, error);
        }

        chip.textContent = `${text} (${imageCount})`;
        chip.tabIndex = 0;

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'chip-delete';
        deleteBtn.textContent = '√ó';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();

            // Check if we're showing Selection Pool (either pool view or search with selections) - show confirmation
            if (isShowingSelectionPool()) {
                showTagRemovalConfirmation(tagText);
            } else {
                removeSearchTagChip(tagText);
            }
        });

        chip.appendChild(deleteBtn);
        librarySearchChips.appendChild(chip);
        updateClearButtonState();
    }

    function removeSearchTagChipInPoolView(tagText) {
        console.log('=== removeSearchTagChipInPoolView START ===');
        console.log('Removing tag in pool view:', tagText, 'MUST stay in pool view');
        
        const originalPoolView = isPoolView; // Preserve original state
        
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);
        console.log('After removing tag, searchTags.length:', searchTags.length);

        // Remove from tagCreationOrder (this tag is no longer tracked)
        delete tagCreationOrder[tagText];
        saveTagCreationOrder();

        // Find images that have the removed tag and remove them from selected images
        const imagesToRemove = [];
        
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesToRemove.push(imageId);
            }
        });

        // Remove these images from selections
        selectedImages = selectedImages.filter(id => !imagesToRemove.includes(id));
        tagSelectedImages = tagSelectedImages.filter(id => !imagesToRemove.includes(id));

        // Remove selection timestamps for removed images
        imagesToRemove.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        console.log('Removed images with tag "' + tagText + '":', imagesToRemove);
        console.log('Remaining selectedImages:', selectedImages.length);

        // Show notification about tag removal and image deselection
        if (imagesToRemove.length > 0) {
            showTagRemovalNotification(tagText, imagesToRemove.length);
        }

        // Remove chip from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            // Extract tag name from "tagname (count)" format
            const chipText = chip.textContent.replace(/[√óx]$/, '').trim();
            const tagName = chipText.replace(/\s*\(\d+\)$/, '');
            if (tagName === tagText) {
                chip.remove();
            }
        });

        // Update search input manually (avoid triggering events)
        const remainingTags = searchTags.map(tag => tag.text).join(', ');
        librarySearchInput.value = remainingTags;
        
        // Force preserve pool view state
        isPoolView = originalPoolView;
        console.log('Forced isPoolView back to:', isPoolView);
        
        updateClearButtonState();
        
        // Directly refresh pool view without calling any functions that might reset state
        console.log('About to refresh pool view display');
        displayLibraryImages();
        
        // Double-check pool view state after display
        if (!isPoolView && originalPoolView) {
            console.log('WARNING: isPoolView was reset! Forcing it back to true');
            isPoolView = true;
            updateLibraryTitle(true);
        }
        
        console.log('=== removeSearchTagChipInPoolView END ===');
        console.log('Final isPoolView:', isPoolView);
    }

    function removeSearchTagChip(tagText) {
        console.log('=== removeSearchTagChip START ===');
        console.log('removeSearchTagChip called for tag:', tagText, 'isPoolView:', isPoolView);
        
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);
        console.log('After removing tag, searchTags.length:', searchTags.length);

        // Remove from tagCreationOrder (this tag is no longer tracked)
        delete tagCreationOrder[tagText];
        saveTagCreationOrder();

        // Find images that have the removed tag and remove them from selected images
        const imagesToRemove = [];
        
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesToRemove.push(imageId);
            }
        });

        // Remove these images from selections
        selectedImages = selectedImages.filter(id => !imagesToRemove.includes(id));
        tagSelectedImages = tagSelectedImages.filter(id => !imagesToRemove.includes(id));

        // Remove selection timestamps for removed images
        imagesToRemove.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        console.log('Removed images with tag "' + tagText + '":', imagesToRemove);
        console.log('Remaining selectedImages:', selectedImages.length);

        // Show notification about tag removal and image deselection
        if (imagesToRemove.length > 0) {
            showTagRemovalNotification(tagText, imagesToRemove.length);
        }

        // Remove chip from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            // Extract tag name from "tagname (count)" format
            const chipText = chip.textContent.replace(/[√óx]$/, '').trim();
            const tagName = chipText.replace(/\s*\(\d+\)$/, '');
            if (tagName === tagText) {
                chip.remove();
            }
        });

        // Update search input and refresh results
        console.log('About to call updateSearchInput, isPoolView:', isPoolView);
        updateSearchInput();
        console.log('After updateSearchInput, isPoolView:', isPoolView);
        
        updateClearButtonState();
        console.log('After updateClearButtonState, isPoolView:', isPoolView);
        
        // Stay in selection pool view if we were there
        const wasInPoolView = isPoolView;
        console.log('wasInPoolView saved as:', wasInPoolView);
        
        if (wasInPoolView) {
            // Keep in pool view and refresh to show remaining selected images
            console.log('About to call displayLibraryImages in pool view mode');
            displayLibraryImages();
        } else {
            // If we were in library view, refresh the library view
            console.log('About to call displayLibraryImages in library view mode');
            displayLibraryImages();
        }
        
        console.log('=== removeSearchTagChip END ===');
        console.log('Final isPoolView:', isPoolView);
    }



    function clearAllSearchChips() {
        console.log('=== clearAllSearchChips CALLED ===');
        console.log('clearAllSearchChips called - clearing everything and returning to main library');
        console.log('Before clear - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'tagSelectedImages:', tagSelectedImages.length, 'isPoolView:', isPoolView);

        // Clear all search tags
        searchTags = [];
        tagSelectedImages = []; // Clear tag-selected images
        imageSelectionSource = {}; // Clear selection source tracking
        librarySearchChips.innerHTML = '';


        // Clear all selected images
        selectedImages = [];

        // Clear all selection timestamps
        imageSelectionOrder = {};

        // Remove visual selection styling from all cards
        const cards = document.querySelectorAll('.library-card');
        cards.forEach(card => {
            card.classList.remove('selected');
            card.classList.remove('manual-selection');
            card.classList.remove('tag-selection');
        });

        // Ensure we're in main library view (not pool view)
        console.log('clearAllSearchChips - SETTING isPoolView = false');
        isPoolView = false;

        // Update UI states
        updateClearButtonState();
        updateSelectionState();

        // Refresh to show full library with no selections or filters
        displayLibraryImages();

        console.log('After clear - returned to main library with no selections or filters');
        console.log('Final state - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'isPoolView:', isPoolView);
        console.log('=== clearAllSearchChips END ===');
    }



    function updateSearchInput() {
        // Mark as programmatic update to prevent triggering clearAllSearchChips
        librarySearchInput.dataset.programmaticUpdate = 'true';
        librarySearchInput.value = searchTags.map(tag => tag.text).join(', ');
        
        // Remove the flag using requestAnimationFrame for better reliability
        requestAnimationFrame(() => {
            setTimeout(() => {
                delete librarySearchInput.dataset.programmaticUpdate;
            }, 50);
        });
    }

    function updateClearButtonState() {
        // Simple: disable button when 0 selected images
        const totalSelections = [...new Set([...selectedImages, ...tagSelectedImages])].length;

        if (totalSelections === 0) {
            clearAllTagsBtn.disabled = true;
            clearAllTagsBtn.style.opacity = '0.5';
            clearAllTagsBtn.style.cursor = 'not-allowed';
            clearAllTagsBtn.style.backgroundColor = '#ccc';
        } else {
            clearAllTagsBtn.disabled = false;
            clearAllTagsBtn.style.opacity = '1';
            clearAllTagsBtn.style.cursor = 'pointer';
            clearAllTagsBtn.style.backgroundColor = '';
        }
    }

    function initializeFreshSearchInput() {
        // Clear any cached or remembered values
        librarySearchInput.value = '';
        librarySearchInput.defaultValue = '';

        // Clear any browser autocomplete cache for this session
        if (librarySearchInput.form) {
            librarySearchInput.form.reset();
        }

        // Force clear any browser-stored values
        setTimeout(() => {
            librarySearchInput.value = '';
        }, 0);

        // Clear search chips and reset state
        clearAllSearchChips();
    }

    function getMatchingTags(imageTags, searchTags) {
        if (!imageTags || !searchTags || searchTags.length === 0) {
            return [];
        }

        // Return tags that are both in the image and in the search
        return imageTags.filter(imageTag =>
            searchTags.some(searchTag =>
                searchTag.toLowerCase() === imageTag.toLowerCase()
            )
        );
    }

    function displayLightboxTags(index) {
        if (index >= libraryImages.length || index < 0) {
            lightboxTags.innerHTML = '';
            return;
        }

        const currentImage = libraryImages[index];
        const imageTags = currentImage.tags || [];

        lightboxTags.innerHTML = '';

        if (imageTags.length === 0) {
            lightboxTags.innerHTML = '<span class="no-tags">No tags</span>';
            return;
        }

        // Create tag chips for lightbox
        imageTags.forEach(tagText => {
            const chip = document.createElement('span');
            chip.className = 'lightbox-tag-chip';
            chip.textContent = tagText;

            // Highlight if it matches current search
            const currentSearchTags = searchTags.map(tag => tag.text);
            if (currentSearchTags.some(searchTag =>
                searchTag.toLowerCase() === tagText.toLowerCase())) {
                chip.classList.add('highlighted');
            }

            lightboxTags.appendChild(chip);
        });
    }

    // --- Selection and Project Management Functions ---

    function toggleImageSelection(imageId, cardElement) {
        // Allow selection/deselection in both library and pool view

        const isSelected = selectedImages.includes(imageId);
        const isTagSelected = tagSelectedImages.includes(imageId);

        if (isSelected) {
            // Deselect - allow full deselection for both manual and tag-selected images
            selectedImages = selectedImages.filter(id => id !== imageId);
            cardElement.classList.remove('selected', 'manual-selection', 'tag-selection');

            // Remove from selection order tracking and source tracking
            delete imageSelectionOrder[imageId];
            delete imageSelectionSource[imageId];

            // Don't automatically re-select tag images - allow them to be fully deselected
        } else {
            // Select
            selectedImages.push(imageId);
            cardElement.classList.add('selected');

            // Remove pool-deselected class to restore red borders
            cardElement.classList.remove('pool-deselected');

            // Track selection timestamp for ordering (latest first in pool view)
            imageSelectionOrder[imageId] = Date.now();

            // Track as manual selection
            imageSelectionSource[imageId] = 'manual';

            // Update CSS class based on selection type
            cardElement.classList.remove('manual-selection', 'tag-selection');
            if (isTagSelected) {
                cardElement.classList.add('tag-selection');
            } else {
                cardElement.classList.add('manual-selection');
            }
        }

        updateSelectionState();
    }

    function updateSelectionState() {
        selectionCount.textContent = `${selectedImages.length} selected`;
        addToProjectBtn.disabled = selectedImages.length === 0;
        updateButtonVisibility();
        updateClearButtonState(); // Update Clear All button state when selections change
    }

    function isShowingSelectionPool() {
        // We're showing selection pool if:
        // 1. We have active search tags AND selections (manual or tag-based), OR
        // 2. We're in pool view
        const hasActiveTags = searchTags.length > 0;
        const hasSelections = selectedImages.length > 0 || tagSelectedImages.length > 0;
        return isPoolView || (hasActiveTags && hasSelections);
    }



    function updateButtonVisibility() {
        console.log('updateButtonVisibility called, isPoolView:', isPoolView, 'selectedImages.length:', selectedImages.length);
        console.log('searchTags.length:', searchTags.length);

        // In pool view, consider both manual and tag selections
        const hasSelections = isPoolView ?
            (selectedImages.length > 0 || tagSelectedImages.length > 0) :
            selectedImages.length > 0;

        console.log('=== BUTTON VISIBILITY DEBUG ===');
        console.log('isPoolView:', isPoolView);
        console.log('selectedImages.length:', selectedImages.length);
        console.log('tagSelectedImages.length:', tagSelectedImages.length);
        console.log('hasSelections calculated:', hasSelections);
        const showingSelectionPool = isShowingSelectionPool();

        // Check if we're actually showing Selection Pool (either explicit pool view OR search results with selections)
        const actuallyShowingSelectionPool = isPoolView || showingSelectionPool;

        if (isPoolView) {
            // Pool view: Show all buttons (Select All, Deselect All, Back to Library, Add to Project)
            viewPoolBtn.classList.add('is-hidden');
            viewPoolBtn.disabled = true;

            backToLibraryBtn.classList.remove('is-hidden');
            backToLibraryBtn.disabled = false;

            // Keep Select All and Deselect All visible in pool view
            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false;

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            // Show Add to Project button in pool view
            addToProjectBtn.classList.remove('is-hidden');
            addToProjectBtn.disabled = !hasSelections; // Dimmed when no selections

            console.log('Pool view - Add to Project button:');
            console.log('  - hidden:', addToProjectBtn.classList.contains('is-hidden'));
            console.log('  - disabled:', addToProjectBtn.disabled);
            console.log('  - hasSelections:', hasSelections);

            console.log('Set buttons for pool view - showing all buttons');
        } else {
            // Library view: Show library controls, hide back button
            viewPoolBtn.classList.remove('is-hidden');

            // Change button text and behavior based on context
            if (searchTags.length > 0 && !isPoolView) {
                // Library view with active tags - show "Back to Library"
                viewPoolBtn.textContent = 'Back to Library';
                viewPoolBtn.disabled = false;
            } else {
                // Normal library view - show "View Selection Pool"
                viewPoolBtn.textContent = 'View Selection Pool';
                viewPoolBtn.disabled = !hasSelections; // Dimmed when no selections
            }

            backToLibraryBtn.classList.add('is-hidden');
            backToLibraryBtn.disabled = true;

            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false; // Always enabled in library view

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            // Show Add to Project button in library view when there are selections
            if (hasSelections) {
                addToProjectBtn.classList.remove('is-hidden');
                addToProjectBtn.disabled = false;
                console.log('Library view - Add to Project button SHOWN (has selections)');
            } else {
                addToProjectBtn.classList.add('is-hidden');
                addToProjectBtn.disabled = true;
                console.log('Library view - Add to Project button HIDDEN (no selections)');
            }

            // Hide Update Tag button in library view
            updateTagBtn.classList.add('is-hidden');

            console.log('Set buttons for library view, showingSelectionPool:', showingSelectionPool);
        }

        // Update Tag button: Show when actually displaying Selection Pool (regardless of isPoolView flag)
        if (actuallyShowingSelectionPool && hasSelections) {
            updateTagBtn.classList.remove('is-hidden');
            updateTagBtn.disabled = false;
        } else {
            updateTagBtn.classList.add('is-hidden');
            updateTagBtn.disabled = true;
        }

        // Delete Image button: Show when actually displaying Selection Pool and has selections
        if (actuallyShowingSelectionPool && hasSelections) {
            deleteImageBtn.classList.remove('is-hidden');
            deleteImageBtn.disabled = false;
        } else {
            deleteImageBtn.classList.add('is-hidden');
            deleteImageBtn.disabled = true;
        }

        // Log final button states for debugging
        console.log('Final button states:');
        console.log('viewPoolBtn - hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
        console.log('backToLibraryBtn - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
        console.log('selectAllBtn - hidden:', selectAllBtn.classList.contains('is-hidden'), 'disabled:', selectAllBtn.disabled);
        console.log('deselectAllBtn - hidden:', deselectAllBtn.classList.contains('is-hidden'), 'disabled:', deselectAllBtn.disabled);
        console.log('addToProjectBtn - hidden:', addToProjectBtn.classList.contains('is-hidden'), 'disabled:', addToProjectBtn.disabled);
        console.log('updateTagBtn - hidden:', updateTagBtn.classList.contains('is-hidden'), 'disabled:', updateTagBtn.disabled);
    }

    function selectAllImages() {
        const cards = document.querySelectorAll('.library-card');
        selectedImages = [];
        const currentTimestamp = Date.now();

        cards.forEach(card => {
            const imageId = parseInt(card.dataset.imageId);
            selectedImages.push(imageId);

            // Track selection timestamp for ordering
            imageSelectionOrder[imageId] = currentTimestamp;

            // Track as manual selection (select all is considered manual)
            imageSelectionSource[imageId] = 'manual';

            // Add selected class
            card.classList.add('selected');

            // Remove pool-deselected class to restore red borders
            card.classList.remove('pool-deselected');

            // Determine and apply the correct selection type class
            const isTagSelected = tagSelectedImages.includes(imageId);
            card.classList.remove('manual-selection', 'tag-selection');

            if (isTagSelected) {
                card.classList.add('tag-selection');
            } else {
                card.classList.add('manual-selection');
            }
        });

        updateSelectionState();
    }

    function deselectAllImages() {
        // Safety check: Don't execute if no selections
        if (selectedImages.length === 0) {
            console.warn('deselectAllImages called but no images are selected');
            return;
        }

        const cards = document.querySelectorAll('.library-card');

        // Clear selection timestamps for all deselected images
        selectedImages.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        selectedImages = [];

        cards.forEach(card => {
            if (isPoolView) {
                // In Selection Pool, remove red borders but keep icons
                card.classList.remove('selected');
                card.classList.add('pool-deselected');
            } else {
                // In Library view, remove all selection-related classes completely
                card.classList.remove('selected');
                card.classList.remove('manual-selection');
                card.classList.remove('tag-selection');
                card.classList.remove('pool-deselected');
            }
        });

        updateSelectionState();
    }



    function handleViewPoolClick() {
        if (viewPoolBtn.textContent === 'Back to Library') {
            // Show full library but preserve tag selection history
            showFullLibrary();
        } else {
            // View selection pool
            viewSelectionPool();
        }
    }

    async function viewSelectionPool() {
        console.log('=== viewSelectionPool START ===');
        console.log('selectedImages:', selectedImages);
        console.log('selectedImages.length:', selectedImages.length);

        if (selectedImages.length === 0) {
            alert('No images selected. Please select some images first.');
            return;
        }

        console.log('Setting isPoolView to true');
        isPoolView = true;

        // Update header to show Selection Pool
        updateLibraryTitle(true);

        // Use the main display function which now handles pool view
        await displayLibraryImages();
        console.log('=== viewSelectionPool END ===');
    }

    function showFullLibrary() {
        console.log('=== showFullLibrary START ===');
        console.log('Showing full library while preserving green tag chips for user reference');

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection status for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== showFullLibrary END ===');
    }

    function backToFullLibrary() {
        console.log('=== backToFullLibrary START ===');
        console.log('Returning to full library while preserving green tag chips for user reference');
        console.log('backToFullLibrary called - preserving tagSelectedImages:', tagSelectedImages);

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection history for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== backToFullLibrary END ===');
    }

    function backToLibrary() {
        try {
            console.log('=== backToLibrary START ===');
            console.log('selectedImages before:', selectedImages);
            console.log('searchTags before:', searchTags);
            console.log('tagSelectedImages before:', tagSelectedImages);
            console.log('isPoolView before:', isPoolView);

            // Safety check: Don't execute if button should be disabled
            if (backToLibraryBtn.disabled) {
                console.error('backToLibrary called but button is disabled! This should not happen.');
                console.log('Button state - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                return;
            }

            // Check if we're actually in pool view
            if (!isPoolView) {
                console.warn('backToLibrary called but isPoolView is already false!');
                console.log('Current button states:');
                console.log('viewPoolBtn hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
                console.log('backToLibraryBtn hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                // Force correct button state
                updateButtonVisibility();
                return;
            }

            isPoolView = false;
            forceLibraryView = true; // Prevent auto-switching back to pool view
            console.log('Set isPoolView to false and forceLibraryView to true');
            console.log('About to update title to Library view');

            // Update header back to normal library view
            updateLibraryTitle(false);
            console.log('Title updated to Library view');

            // PRESERVE search tags and selections when going back to library
            // Users should see all their search tags still visible and functional
            if (searchTags.length > 0) {
                console.log('Preserving search tags and all selections in library view');

                // Merge tag-selected images into selectedImages to preserve all selections
                const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];
                selectedImages = allSelectedImages;

                // Update selection source for merged images
                tagSelectedImages.forEach(imageId => {
                    if (!imageSelectionSource[imageId]) {
                        imageSelectionSource[imageId] = 'tag-merged';
                    }
                });

                // Keep tagSelectedImages as they are for proper display in library view
                console.log('Search tags and selections preserved:', selectedImages.length, 'tags:', searchTags.length);
            }

            // Refresh library view (will show all images with preserved selections)
            console.log('Calling displayLibraryImages...');
            displayLibraryImages().then(() => {
                console.log('displayLibraryImages completed successfully');
                console.log('tagSelectedImages after:', tagSelectedImages);
                console.log('=== backToLibrary END ===');
            }).catch(error => {
                console.error('Error in displayLibraryImages:', error);
                alert('Error returning to library. Please refresh the page.');
            });

        } catch (error) {
            console.error('Error in backToLibrary:', error);
            alert('Error returning to library. Please refresh the page.');
        }
    }

    function showProjectNameModal() {
        console.log('Selected images before modal:', selectedImages);
        console.log('Tag-selected images before modal:', tagSelectedImages);

        // Safety check: Don't execute if no selections (check both manual and tag selections)
        const totalSelections = selectedImages.length + tagSelectedImages.length;
        if (totalSelections === 0) {
            console.warn('showProjectNameModal called but no images are selected');
            alert('Please select at least one image.');
            return;
        }

        console.log(`Total selections for project: ${totalSelections} (${selectedImages.length} manual + ${tagSelectedImages.length} tag-based)`);

        projectNameInput.value = '';
        projectNameModal.classList.remove('is-hidden');
        projectNameInput.focus();
    }

    function hideProjectNameModal() {
        projectNameModal.classList.add('is-hidden');
        projectNameInput.value = '';
    }

    function showProjectCreatedModal(projectName, imageCount) {
        projectSuccessMessage.textContent = `Project "${projectName}" created with ${imageCount} images! What would you like to do next?`;
        projectCreatedModal.classList.remove('is-hidden');
    }

    function hideProjectCreatedModal() {
        projectCreatedModal.classList.add('is-hidden');
        lastCreatedProject = null;
    }

    function showProjectDetailModal(project) {
        console.log('=== SHOWPROJECTDETAILMODAL START ===');
        console.log('Opening project detail modal for:', project);

        // Store project ID for reference
        projectDetailModal.dataset.projectId = project.id;

        // Update header information
        projectDetailName.textContent = `üìÅ ${project.name}`;
        projectDetailDate.textContent = `üìÖ Created: ${new Date(project.created_at).toLocaleDateString()}`;
        if (project.ownership && projectDetailOwner) {
            projectDetailOwner.textContent = `üë§ Created by: ${project.ownership}`;
            projectDetailOwner.style.display = 'inline';
        } else if (projectDetailOwner) {
            projectDetailOwner.style.display = 'none';
        }

        // Generate detailed count with breakdown using the formatting function
        // Pass the project as fallback for existing projects without breakdown data
        console.log('Project detail - project:', project);
        console.log('Project detail - selection_breakdown:', project.selection_breakdown);
        const countText = formatSelectionBreakdown(project.selection_breakdown, project);
        console.log('Project detail - countText:', countText);
        projectDetailCount.textContent = countText;

        // Get unique tags from project images
        const projectTags = getProjectTags(project.image_ids);
        projectDetailTags.textContent = `üè∑Ô∏è Tags: ${projectTags.join(', ') || 'No tags'}`;

        // Load project images
        loadProjectImages(project.image_ids);

        // Show modal
        projectDetailModal.classList.remove('is-hidden');
    }

    function hideProjectDetailModal() {
        projectDetailModal.classList.add('is-hidden');
        projectDetailGrid.innerHTML = '';
        delete projectDetailModal.dataset.projectId;
    }

    function getProjectTags(imageIds) {
        const allTags = new Set();
        imageIds.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags) {
                image.tags.forEach(tag => allTags.add(tag));
            }
        });
        return Array.from(allTags);
    }

    function generateSelectionBreakdown() {
        // Get current search tags
        const currentSearchTags = searchTags.map(tag => tag.text);

        console.log('generateSelectionBreakdown - currentSearchTags:', currentSearchTags);
        console.log('generateSelectionBreakdown - selectedImages:', selectedImages);
        console.log('generateSelectionBreakdown - imageSelectionSource:', imageSelectionSource);

        // Count images by how they were selected
        const tagCounts = {};
        let manuallySelectedCount = 0;

        selectedImages.forEach(imageId => {
            const selectionSource = imageSelectionSource[imageId];

            if (selectionSource === 'manual') {
                manuallySelectedCount++;
            } else if (selectionSource) {
                // This was selected by a search operation
                // The selectionSource contains the search tags used (comma-separated)
                const searchTagsUsed = selectionSource.split(',');

                // For breakdown, we want to show which specific search tag this image should be attributed to
                // Find which of the current search tags this image actually has
                const image = libraryImages.find(img => img.id === imageId);
                if (image && image.tags) {
                    // Find the first current search tag that this image has
                    const matchingTag = currentSearchTags.find(tag => image.tags.includes(tag));
                    if (matchingTag) {
                        tagCounts[matchingTag] = (tagCounts[matchingTag] || 0) + 1;
                    } else {
                        // Image was selected by search but doesn't match current tags (shouldn't happen)
                        manuallySelectedCount++;
                    }
                } else {
                    manuallySelectedCount++;
                }
            } else {
                // No selection source recorded, treat as manual
                manuallySelectedCount++;
            }
        });

        console.log('generateSelectionBreakdown - tagCounts:', tagCounts);
        console.log('generateSelectionBreakdown - manuallySelectedCount:', manuallySelectedCount);

        return {
            tagCounts,
            manuallySelectedCount,
            totalImages: selectedImages.length
        };
    }

    function generateBreakdownFromProject(project) {
        // For existing projects without breakdown data, analyze the images
        const imageIds = project.image_ids || [];
        const tagCounts = {};
        let totalImages = imageIds.length;

        console.log('generateBreakdownFromProject - imageIds:', imageIds);
        console.log('generateBreakdownFromProject - libraryImages.length:', libraryImages.length);

        // Count images by tag
        imageIds.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            console.log(`Image ${imageId}:`, image ? `found with tags: ${image.tags}` : 'not found');
            if (image && image.tags) {
                image.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        });

        console.log('generateBreakdownFromProject - tagCounts:', tagCounts);

        return {
            tagCounts,
            manuallySelectedCount: 0, // Can't determine for existing projects
            totalImages
        };
    }

    function formatSelectionBreakdown(breakdown, project = null) {
        console.log('formatSelectionBreakdown called with breakdown:', breakdown, 'project:', project);

        // If no breakdown provided, try to generate one from project data
        if (!breakdown && project) {
            console.log('No breakdown provided, generating from project...');
            breakdown = generateBreakdownFromProject(project);
        }

        if (!breakdown) {
            console.log('No breakdown available, using simple format');
            return `üìä Total Images: ${project?.image_ids?.length || 0}`;
        }

        console.log('Using breakdown:', breakdown);

        const tagBreakdowns = [];

        // Add tag counts
        Object.entries(breakdown.tagCounts || {}).forEach(([tag, count]) => {
            tagBreakdowns.push(`${tag} - ${count} image${count !== 1 ? 's' : ''}`);
        });

        // Add manually selected count (only if we have the data)
        if (breakdown.manuallySelectedCount > 0) {
            tagBreakdowns.push(`${breakdown.manuallySelectedCount} manually selected`);
        }

        // If no tag breakdowns but we have images, they must be manually selected (for existing projects)
        if (tagBreakdowns.length === 0 && breakdown.totalImages > 0 && !breakdown.tagCounts) {
            tagBreakdowns.push(`${breakdown.totalImages} manually selected`);
        }

        let result = `üìä Total Images: ${breakdown.totalImages}`;
        if (tagBreakdowns.length > 0) {
            result += ` (${tagBreakdowns.join(', ')})`;
        }

        console.log('Final formatted result:', result);
        return result;
    }

    async function loadProjectImages(imageIds) {
        projectDetailGrid.innerHTML = '';

        try {
            // Get all images from API
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images`, {
                headers: headers
            });
            if (!response.ok) throw new Error('Failed to fetch images');
            const allImages = await response.json();

            // Filter to only project images
            const projectImages = allImages.filter(img => imageIds.includes(img.id));

            projectImages.forEach(image => {
                const card = document.createElement('div');
                card.className = 'project-image-card';

                const img = document.createElement('img');
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                img.alt = `Image ${image.id}`;

                // Test image loading before displaying
                const testImg = new Image();
                testImg.onload = () => {
                    img.src = imageSrc;

                    // Add click handler for lightbox
                    img.addEventListener('click', () => {
                        // Open lightbox for this image
                        openProjectImageLightbox(image, projectImages);
                    });

                    card.appendChild(img);
                };
                testImg.onerror = () => {
                    // Skip broken images in project view
                    console.warn(`Project image failed to load: ${imageSrc} (ID: ${image.id})`);
                    // Don't append the img to the card
                };
                testImg.src = imageSrc;

                // Add tag overlay - show tags on project images (same style as library)
                const imageTags = image.tags || [];
                if (imageTags.length > 0) {
                    const tagOverlay = document.createElement('div');
                    tagOverlay.className = 'tag-overlay';

                    // Show first 3 tags for project images
                    tagOverlay.textContent = imageTags.slice(0, 3).join(', ');
                    if (imageTags.length > 3) {
                        tagOverlay.textContent += ` +${imageTags.length - 3}`;
                    }

                    card.appendChild(tagOverlay);
                }

                // Create icons container
                const iconsContainer = document.createElement('div');
                iconsContainer.className = 'project-image-icons';

                // Determine selection type and add appropriate icons
                const isTagSelected = tagSelectedImages.includes(image.id);
                const isManualSelected = selectedImages.includes(image.id) && !isTagSelected;

                if (isTagSelected) {
                    const tagIcon = document.createElement('div');
                    tagIcon.className = 'project-image-icon';
                    tagIcon.textContent = 'üè∑Ô∏è';
                    tagIcon.title = 'Selected by tags';
                    iconsContainer.appendChild(tagIcon);
                }

                if (isManualSelected) {
                    const handIcon = document.createElement('div');
                    handIcon.className = 'project-image-icon';
                    handIcon.textContent = 'üëÜ';
                    handIcon.title = 'Manually selected';
                    iconsContainer.appendChild(handIcon);
                }

                if (iconsContainer.children.length > 0) {
                    card.appendChild(iconsContainer);
                }

                projectDetailGrid.appendChild(card);
            });

        } catch (error) {
            console.error('Error loading project images:', error);
            projectDetailGrid.innerHTML = '<p>Error loading project images.</p>';
        }
    }

    function openProjectImageLightbox(image, projectImages) {
        // Set up lightbox for project images with proper src format
        const imageIndex = projectImages.findIndex(img => img.id === image.id);

        // Format project images for lightbox (add src property)
        const formattedImages = projectImages.map(img => ({
            ...img,
            src: `${API_URL}/${img.filepath.replace(/\\/g, '/')}`
        }));

        // Temporarily set for lightbox navigation
        libraryImages = formattedImages;
        openLibraryLightbox(imageIndex);
    }

    function filterProjects(searchTerm) {
        const projectCards = document.querySelectorAll('.project-card');
        projectCards.forEach(card => {
            const projectTitle = card.querySelector('.project-title').textContent.toLowerCase();
            if (projectTitle.includes(searchTerm)) {
                card.style.display = 'block';
            } else {
                card.style.display = 'none';
            }
        });
    }

    // Image Preview Overlay Functions
    function showImagePreviewOverlay(imageSrc, image) {
        // Set up regular library preview (no navigation)
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = image ? `Full size preview of image ${image.id}` : 'Full size preview';

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        imagePreviewOverlay.classList.add('show');

        // Hide navigation arrows for regular library view
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');

        // Prevent body scrolling when overlay is open (but allow overlay scrolling)
        document.body.style.overflow = 'hidden';

        // Add pan event listeners
        addPanEventListeners();

        if (image) {
            console.log('Regular image preview overlay opened for image:', image.id);
        } else {
            console.log('Image preview overlay opened for uploaded image');
        }
    }

    function hideImagePreviewOverlay() {
        imagePreviewOverlay.classList.remove('show');
        previewOverlayImg.src = '';

        // Restore body scrolling
        document.body.style.overflow = '';

        // Remove pan event listeners
        removePanEventListeners();

        // Reset Selection Pool preview state
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        // Hide navigation arrows
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');
    }

    // Pan functionality variables
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    // Pan functionality functions
    function addPanEventListeners() {
        imagePreviewOverlay.addEventListener('mousedown', startPan);
        imagePreviewOverlay.addEventListener('mousemove', doPan);
        imagePreviewOverlay.addEventListener('mouseup', endPan);
        imagePreviewOverlay.addEventListener('mouseleave', endPan);

        // Prevent default drag behavior on images
        previewOverlayImg.addEventListener('dragstart', (e) => e.preventDefault());
    }

    function removePanEventListeners() {
        imagePreviewOverlay.removeEventListener('mousedown', startPan);
        imagePreviewOverlay.removeEventListener('mousemove', doPan);
        imagePreviewOverlay.removeEventListener('mouseup', endPan);
        imagePreviewOverlay.removeEventListener('mouseleave', endPan);
    }

    function startPan(e) {
        // Don't start panning if clicking on the close button
        if (e.target.id === 'preview-overlay-close') return;

        isPanning = true;
        imagePreviewOverlay.classList.add('panning');

        startX = e.clientX;
        startY = e.clientY;
        scrollLeft = imagePreviewOverlay.scrollLeft;
        scrollTop = imagePreviewOverlay.scrollTop;

        e.preventDefault();
    }

    function doPan(e) {
        if (!isPanning) return;

        e.preventDefault();

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        imagePreviewOverlay.scrollLeft = scrollLeft - deltaX;
        imagePreviewOverlay.scrollTop = scrollTop - deltaY;
    }

    function endPan() {
        isPanning = false;
        imagePreviewOverlay.classList.remove('panning');
    }

    // Selection Pool Preview Functions
    function showSelectionPoolPreview(clickedImage, allImages, clickedIndex) {
        console.log('showSelectionPoolPreview called with:', {
            clickedImage: clickedImage.id,
            allImagesCount: allImages.length,
            clickedIndex: clickedIndex
        });

        // Set up navigation data
        currentPreviewImages = allImages;
        currentPreviewIndex = clickedIndex;
        isSelectionPoolPreview = true;

        // Show the clicked image
        const imageSrc = `${API_URL}/${clickedImage.filepath.replace(/\\/g, '/')}`;
        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = `Full size preview of image ${clickedImage.id}`;

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        // Show overlay first
        imagePreviewOverlay.classList.add('show');

        // Update navigation arrows visibility (after overlay is shown)
        updateNavigationArrows();

        // Prevent body scrolling and add pan functionality
        document.body.style.overflow = 'hidden';
        addPanEventListeners();

        console.log('Selection Pool preview opened for image:', clickedImage.id, 'at index:', clickedIndex);
        console.log('Navigation arrows should be visible now');
    }

    function updateNavigationArrows() {
        console.log('updateNavigationArrows called:', {
            currentPreviewIndex: currentPreviewIndex,
            totalImages: currentPreviewImages.length,
            isSelectionPoolPreview: isSelectionPoolPreview
        });

        if (!isSelectionPoolPreview) {
            // Hide arrows for regular library preview
            previewNavLeft.classList.add('hidden');
            previewNavRight.classList.add('hidden');
            console.log('Hiding arrows - not Selection Pool preview');
            return;
        }

        // Show/hide arrows based on current position in Selection Pool
        if (currentPreviewIndex <= 0) {
            previewNavLeft.classList.add('hidden');
            console.log('Hiding left arrow - at first image');
        } else {
            previewNavLeft.classList.remove('hidden');
            console.log('Showing left arrow');
        }

        if (currentPreviewIndex >= currentPreviewImages.length - 1) {
            previewNavRight.classList.add('hidden');
            console.log('Hiding right arrow - at last image');
        } else {
            previewNavRight.classList.remove('hidden');
            console.log('Showing right arrow');
        }

        console.log('Navigation arrows updated');
    }

    function navigatePreview(direction) {
        if (!isSelectionPoolPreview) return;

        let newIndex = currentPreviewIndex;

        if (direction === 'left' && currentPreviewIndex > 0) {
            newIndex = currentPreviewIndex - 1;
        } else if (direction === 'right' && currentPreviewIndex < currentPreviewImages.length - 1) {
            newIndex = currentPreviewIndex + 1;
        }

        if (newIndex !== currentPreviewIndex) {
            currentPreviewIndex = newIndex;
            const newImage = currentPreviewImages[newIndex];
            const newImageSrc = `${API_URL}/${newImage.filepath.replace(/\\/g, '/')}`;

            previewOverlayImg.src = newImageSrc;
            previewOverlayImg.alt = `Full size preview of image ${newImage.id}`;

            // Reset scroll position for new image
            imagePreviewOverlay.scrollTop = 0;
            imagePreviewOverlay.scrollLeft = 0;

            // Update arrow visibility
            updateNavigationArrows();

            console.log('Navigated to image:', newImage.id, 'at index:', newIndex);
        }
    }

    async function createProject() {
        const projectName = projectNameInput.value.trim();

        // Combine both manual and tag-based selections
        const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];

        console.log('Creating project with selected images:', selectedImages);
        console.log('Creating project with tag-selected images:', tagSelectedImages);
        console.log('Creating project with combined images:', allSelectedImages);

        if (!projectName) {
            alert('Please enter a project name.');
            return;
        }

        // Check if we have selected images (check combined selections)
        if (allSelectedImages.length === 0) {
            alert('Please select at least one image before creating a project.');
            return;
        }

        // Check if project name already exists
        if (projects.some(p => p.name.toLowerCase() === projectName.toLowerCase())) {
            alert('A project with this name already exists.');
            return;
        }

        // Store the count before clearing selection
        const imageCount = allSelectedImages.length;

        try {
            // Generate selection breakdown before saving
            const breakdown = generateSelectionBreakdown();
            const newProject = await saveProjectToAPI(projectName, [...allSelectedImages], breakdown);
            displayProjects();

            // Store the created project for navigation
            lastCreatedProject = newProject;

            // Hide project name modal first, then clear selection
            hideProjectNameModal();
            deselectAllImages();

            // Show success confirmation modal
            showProjectCreatedModal(projectName, imageCount);
        } catch (error) {
            alert('Failed to create project. Please try again.');
        }
    }

    async function loadProjectsFromAPI() {
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/projects`, {
                headers: headers
            });
            if (response.ok) {
                projects = await response.json();
                console.log('Loaded projects from API:', projects.length);
            } else {
                console.error('Failed to load projects:', response.statusText);
                projects = [];
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            projects = [];
        }
    }

    async function saveProjectToAPI(projectName, imageIds, breakdown = null) {
        try {
            const projectData = {
                name: projectName,
                image_ids: imageIds
            };

            // Add breakdown metadata if provided
            if (breakdown) {
                projectData.selection_breakdown = breakdown;
            }

            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json',
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/projects`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(projectData)
            });

            if (response.ok) {
                const newProject = await response.json();
                projects.push(newProject);
                console.log('Project saved to API:', newProject);
                return newProject;
            } else {
                console.error('Failed to save project:', response.statusText);
                throw new Error('Failed to save project');
            }
        } catch (error) {
            console.error('Error saving project:', error);
            throw error;
        }
    }

    async function deleteProjectFromAPI(projectId) {
        try {
            const response = await fetch(`${API_URL}/projects/${projectId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                projects = projects.filter(p => p.id !== projectId);
                console.log('Project deleted from API:', projectId);
                return true;
            } else {
                console.error('Failed to delete project:', response.statusText);
                throw new Error('Failed to delete project');
            }
        } catch (error) {
            console.error('Error deleting project:', error);
            throw error;
        }
    }

    function toggleProjectView() {
        isDetailedProjectView = !isDetailedProjectView;

        // Update toggle button appearance
        if (isDetailedProjectView) {
            projectViewToggleBtn.classList.add('detailed-mode');
            toggleIcon.textContent = 'üìä';
            toggleText.textContent = 'Present View';
        } else {
            projectViewToggleBtn.classList.remove('detailed-mode');
            toggleIcon.textContent = 'üìã';
            toggleText.textContent = 'Detailed View';
        }

        // Update project list classes
        if (isDetailedProjectView) {
            projectList.classList.add('detailed-view');
        } else {
            projectList.classList.remove('detailed-view');
        }

        // Refresh the project display
        displayProjects();
    }

    async function toggleEmailHistory(projectId, toggleButton, emailList) {
        if (emailList.classList.contains('expanded')) {
            // Collapse
            emailList.classList.remove('expanded');
            toggleButton.textContent = 'Show All';
        } else {
            // Expand and load email history
            try {
                const response = await fetch(`${API_URL}/projects/${projectId}/email-history`);
                if (response.ok) {
                    const emailHistory = await response.json();

                    emailList.innerHTML = '';

                    if (emailHistory.length === 0) {
                        emailList.innerHTML = '<div class="email-history-item">No emails sent yet</div>';
                    } else {
                        emailHistory.forEach(email => {
                            const emailItem = document.createElement('div');
                            emailItem.className = 'email-history-item';

                            const date = new Date(email.sent_at);
                            const statusClass = email.success ? 'success' : 'failed';
                            const statusText = email.success ? 'Sent' : 'Failed';

                            emailItem.innerHTML = `
                                <div class="email-recipient">${email.recipient_email}</div>
                                <div class="email-date">${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                                <span class="email-status ${statusClass}">${statusText}</span>
                            `;

                            emailList.appendChild(emailItem);
                        });
                    }

                    emailList.classList.add('expanded');
                    toggleButton.textContent = 'Hide All';
                } else {
                    console.error('Failed to load email history');
                    emailList.innerHTML = '<div class="email-history-item">Failed to load email history</div>';
                    emailList.classList.add('expanded');
                    toggleButton.textContent = 'Hide All';
                }
            } catch (error) {
                console.error('Error loading email history:', error);
                emailList.innerHTML = '<div class="email-history-item">Error loading email history</div>';
                emailList.classList.add('expanded');
                toggleButton.textContent = 'Hide All';
            }
        }
    }

    async function loadLastEmailInfo(projectId, emailSection) {
        console.log('=== LOAD LAST EMAIL INFO START ===');
        console.log('Loading last email info for project:', projectId);

        try {
            const response = await fetch(`${API_URL}/projects/${projectId}/email-history`);
            console.log('Email history API response status:', response.status);

            if (response.ok) {
                const emailHistory = await response.json();
                console.log('Email history data:', emailHistory);

                if (emailHistory.length > 0) {
                    const lastEmail = emailHistory[0]; // Most recent email
                    console.log('Last email:', lastEmail);

                    const lastEmailRow = document.createElement('div');
                    lastEmailRow.className = 'project-detail-row';

                    const date = new Date(lastEmail.sent_at);
                    const statusText = lastEmail.success ? '‚úÖ' : '‚ùå';

                    lastEmailRow.innerHTML = `<strong>üìß Last email:</strong> ${lastEmail.recipient_email} (${date.toLocaleDateString()}) ${statusText}`;
                    emailSection.appendChild(lastEmailRow);
                    console.log('Last email row added to section');
                } else {
                    console.log('No email history found');
                    const noEmailRow = document.createElement('div');
                    noEmailRow.className = 'project-detail-row';
                    noEmailRow.innerHTML = '<strong>üìß Last email:</strong> No emails sent yet';
                    emailSection.appendChild(noEmailRow);
                }
            } else {
                console.log('Email history API failed:', response.status);
            }
        } catch (error) {
            console.error('Error loading last email info:', error);
        }

        console.log('=== LOAD LAST EMAIL INFO END ===');
    }

    async function displayProjects() {
        if (projects.length === 0) {
            projectList.innerHTML = '<p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>';
            return;
        }

        projectList.innerHTML = '';

        // Sort projects by creation date - latest first (top-left corner)
        const sortedProjects = [...projects].sort((a, b) => {
            // Sort by ID in descending order (assuming higher ID = more recent)
            return b.id - a.id;
        });

        for (const project of sortedProjects) {
            const projectCard = document.createElement('div');
            projectCard.className = isDetailedProjectView ? 'project-card detailed-view' : 'project-card';

            // Project card header with title and metadata
            const cardHeader = document.createElement('div');
            cardHeader.className = 'project-card-header';

            const titleSection = document.createElement('div');
            titleSection.className = 'project-title-section';

            const projectTitle = document.createElement('h3');
            projectTitle.className = 'project-title';
            projectTitle.textContent = project.name;

            if (isDetailedProjectView) {
                // Detailed view: Show comprehensive information
                const detailedInfo = document.createElement('div');
                detailedInfo.className = 'project-detailed-info';

                // Creation date
                const date = new Date(project.created_at);
                const dateRow = document.createElement('div');
                dateRow.className = 'project-detail-row';
                dateRow.innerHTML = `<strong>üìÖ Created:</strong> ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                detailedInfo.appendChild(dateRow);

                // Image count
                const countRow = document.createElement('div');
                countRow.className = 'project-detail-row';
                countRow.innerHTML = `<strong>üìä Images:</strong> ${project.image_ids.length} images`;
                detailedInfo.appendChild(countRow);

                // Creator/Owner
                if (project.ownership) {
                    const ownerRow = document.createElement('div');
                    ownerRow.className = 'project-detail-row';
                    ownerRow.innerHTML = `<strong>üë§ Created by:</strong> ${project.ownership}`;
                    detailedInfo.appendChild(ownerRow);
                }

                // Email history section
                const emailSection = document.createElement('div');
                emailSection.className = 'email-history-section';

                // Load and show last email info immediately
                loadLastEmailInfo(project.id, emailSection);

                const emailHeader = document.createElement('div');
                emailHeader.className = 'email-history-header';
                emailHeader.innerHTML = '<strong>üìß Email History:</strong>';

                const emailToggle = document.createElement('button');
                emailToggle.className = 'email-history-toggle';
                emailToggle.textContent = 'Show All';
                emailToggle.dataset.projectId = project.id;

                const emailList = document.createElement('div');
                emailList.className = 'email-history-list';
                emailList.id = `email-history-${project.id}`;

                emailToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleEmailHistory(project.id, emailToggle, emailList);
                });

                emailHeader.appendChild(emailToggle);
                emailSection.appendChild(emailHeader);
                emailSection.appendChild(emailList);
                detailedInfo.appendChild(emailSection);

                titleSection.appendChild(projectTitle);
                titleSection.appendChild(detailedInfo);
            } else {
                // Present view: Show basic metadata
                const projectMeta = document.createElement('div');
                projectMeta.className = 'project-meta';

                const imageCount = document.createElement('span');
                imageCount.className = 'project-image-count';
                imageCount.textContent = `${project.image_ids.length} images`;

                const createdDate = document.createElement('span');
                createdDate.className = 'project-created-date';
                const date = new Date(project.created_at);
                createdDate.textContent = `Created ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

                const creatorEmail = document.createElement('span');
                creatorEmail.className = 'project-creator-email';
                creatorEmail.textContent = project.ownership ? `by ${project.ownership}` : '';

                projectMeta.appendChild(imageCount);
                projectMeta.appendChild(createdDate);
                if (project.ownership) {
                    projectMeta.appendChild(creatorEmail);
                }
                titleSection.appendChild(projectTitle);
                titleSection.appendChild(projectMeta);
            }

            const actionSection = document.createElement('div');
            actionSection.className = 'project-actions';

            const shareBtn = document.createElement('button');
            shareBtn.className = 'button share-project-btn';
            shareBtn.innerHTML = '';
            shareBtn.title = 'Share project via email';
            shareBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                showShareProjectModal(project);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'button delete-project-btn';
            deleteBtn.innerHTML = 'üóëÔ∏è';
            deleteBtn.title = 'Delete project';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                deleteProject(project.id);
            });

            actionSection.appendChild(shareBtn);
            actionSection.appendChild(deleteBtn);
            cardHeader.appendChild(titleSection);
            cardHeader.appendChild(actionSection);

            // Only show image preview in present view
            if (!isDetailedProjectView) {
                // Project images preview (first few images)
                const projectPreview = document.createElement('div');
                projectPreview.className = 'project-preview';

                // Get image data for this project
                try {
                    const sessionToken = localStorage.getItem('sessionToken');
                    const headers = {};
                    if (sessionToken) {
                        headers['Authorization'] = `Bearer ${sessionToken}`;
                    }
                    const response = await fetch(`${API_URL}/images`, {
                        headers: headers
                    });
                    const allImages = await response.json();
                    const projectImageData = allImages.filter(img => project.image_ids.includes(img.id));

                    // Show first 6 images as preview
                    const previewImages = projectImageData.slice(0, 6);
                    previewImages.forEach(image => {
                        const previewImg = document.createElement('img');
                        previewImg.className = 'project-preview-image';
                        previewImg.src = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                        projectPreview.appendChild(previewImg);
                    });

                    // Add "more" indicator if there are more images
                    if (projectImageData.length > 6) {
                        const moreIndicator = document.createElement('div');
                        moreIndicator.className = 'project-more-indicator';
                        moreIndicator.textContent = `+${projectImageData.length - 6} more`;
                        projectPreview.appendChild(moreIndicator);
                    }
                } catch (error) {
                    console.error('Error loading project images:', error);
                }

                projectCard.appendChild(cardHeader);
                projectCard.appendChild(projectPreview);
            } else {
                // Detailed view: Only show header
                projectCard.appendChild(cardHeader);
            }

            // Add click handler to open project detail modal
            projectCard.addEventListener('click', () => {
                showProjectDetailModal(project);
            });

            // Make project card look clickable
            projectCard.style.cursor = 'pointer';

            projectList.appendChild(projectCard);
        }
    }

    async function deleteProject(projectId) {
        const project = projects.find(p => p.id === projectId);
        if (project && confirm(`Are you sure you want to delete the project "${project.name}"?`)) {
            try {
                await deleteProjectFromAPI(projectId);
                displayProjects();
            } catch (error) {
                alert('Failed to delete project. Please try again.');
            }
        }
    }

    async function refreshEmailHistoryDisplays(projectId) {
        console.log('=== REFRESH EMAIL HISTORY START ===');
        console.log('Refreshing email history displays for project:', projectId);
        console.log('isDetailedProjectView:', isDetailedProjectView);
        console.log('projectDetailModal hidden:', projectDetailModal.classList.contains('is-hidden'));

        // 1. Update email history in detailed project view
        if (isDetailedProjectView) {
            console.log('Updating email history in detailed project view');
            await updateProjectEmailHistory(projectId);
        }

        // 2. Refresh project detail modal if it's open for this project
        if (!projectDetailModal.classList.contains('is-hidden')) {
            const currentProjectId = projectDetailModal.dataset.projectId;
            console.log('Current modal project ID:', currentProjectId, 'Target project ID:', projectId);
            if (currentProjectId == projectId) {
                console.log('Refreshing project detail modal');
                const project = projects.find(p => p.id == projectId);
                if (project) {
                    showProjectDetailModal(project);
                } else {
                    console.log('Project not found in projects array');
                }
            } else {
                console.log('Modal is open but for different project');
            }
        }

        console.log('=== REFRESH EMAIL HISTORY END ===');
    }

    async function updateProjectEmailHistory(projectId) {
        console.log('=== UPDATE PROJECT EMAIL HISTORY START ===');
        console.log('Updating email history for project:', projectId);

        // Find the project card for this project ID
        const projectCards = document.querySelectorAll('.project-card.detailed-view');

        for (const card of projectCards) {
            // Find the email history section in this card
            const emailSection = card.querySelector('.email-history-section');
            if (emailSection) {
                // Check if this card is for the target project by looking at the toggle button
                const toggleButton = emailSection.querySelector('.email-history-toggle');
                if (toggleButton && toggleButton.dataset.projectId == projectId) {
                    console.log('Found matching project card, updating email history');

                    // Clear existing last email info
                    const existingEmailRow = emailSection.querySelector('.project-detail-row');
                    if (existingEmailRow) {
                        existingEmailRow.remove();
                    }

                    // Add updated last email info
                    await loadLastEmailInfo(projectId, emailSection);

                    // If email history is expanded, refresh it too
                    const emailList = emailSection.querySelector('.email-history-list');
                    if (emailList && emailList.classList.contains('expanded')) {
                        console.log('Email history is expanded, refreshing list');
                        await toggleEmailHistory(projectId, toggleButton, emailList);
                        await toggleEmailHistory(projectId, toggleButton, emailList); // Toggle twice to refresh
                    }

                    break;
                }
            }
        }

        console.log('=== UPDATE PROJECT EMAIL HISTORY END ===');
    }

    // Autocomplete Functions
    async function showAutocomplete(query) {
        if (query.length < 2) {
            hideAutocomplete();
            return;
        }

        try {
            const response = await fetch(`${API_URL}/tags?q=${encodeURIComponent(query)}`);
            if (!response.ok) {
                throw new Error('Failed to fetch tags');
            }

            const tags = await response.json();
            autocompleteItems = tags.slice(0, 10); // Limit to 10 suggestions

            if (autocompleteItems.length === 0) {
                hideAutocomplete();
                return;
            }

            renderAutocomplete();
            autocompleteDropdown.classList.add('show');
            autocompleteVisible = true;
            autocompleteHighlightIndex = -1;

        } catch (error) {
            console.error('Error fetching autocomplete suggestions:', error);
            hideAutocomplete();
        }
    }

    function renderAutocomplete() {
        autocompleteDropdown.innerHTML = '';

        autocompleteItems.forEach((tag, index) => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.dataset.index = index;

            item.innerHTML = `
                <span class="autocomplete-item-name">${tag.name}</span>
                <span class="autocomplete-item-count">${tag.usage_count}</span>
            `;

            item.addEventListener('click', () => {
                selectAutocompleteItem(tag.name);
            });

            autocompleteDropdown.appendChild(item);
        });
    }

    function hideAutocomplete() {
        autocompleteDropdown.classList.remove('show');
        autocompleteVisible = false;
        autocompleteHighlightIndex = -1;
        autocompleteItems = [];
    }

    function selectAutocompleteItem(tagName) {
        const currentValue = librarySearchInput.value;
        const lastCommaIndex = currentValue.lastIndexOf(',');

        let newValue;
        if (lastCommaIndex === -1) {
            // No comma, replace entire value
            newValue = tagName;
        } else {
            // Replace text after last comma
            newValue = currentValue.substring(0, lastCommaIndex + 1) + ' ' + tagName;
        }

        librarySearchInput.value = newValue;
        hideAutocomplete();
        librarySearchInput.focus();
    }

    function highlightAutocompleteItem(direction) {
        if (!autocompleteVisible || autocompleteItems.length === 0) return;

        // Remove previous highlight
        const items = autocompleteDropdown.querySelectorAll('.autocomplete-item');
        items.forEach(item => item.classList.remove('highlighted'));

        // Update highlight index
        if (direction === 'down') {
            autocompleteHighlightIndex = Math.min(autocompleteHighlightIndex + 1, autocompleteItems.length - 1);
        } else if (direction === 'up') {
            autocompleteHighlightIndex = Math.max(autocompleteHighlightIndex - 1, -1);
        }

        // Apply new highlight
        if (autocompleteHighlightIndex >= 0) {
            items[autocompleteHighlightIndex].classList.add('highlighted');
        }
    }

    function selectHighlightedItem() {
        if (autocompleteHighlightIndex >= 0 && autocompleteHighlightIndex < autocompleteItems.length) {
            selectAutocompleteItem(autocompleteItems[autocompleteHighlightIndex].name);
            return true;
        }
        return false;
    }

    // Authentication Functions
    async function checkAuthentication() {
        const sessionToken = localStorage.getItem('sessionToken');

        if (!sessionToken) {
            window.location.href = '/login.html';
            return false;
        }

        try {
            const response = await fetch(`${API_URL}/auth/verify-session`, {
                headers: { 'Authorization': `Bearer ${sessionToken}` }
            });

            if (!response.ok) {
                localStorage.removeItem('sessionToken');
                window.location.href = '/login.html';
                return false;
            }

            const result = await response.json();
            currentUser = result.user;

            // Show/hide admin menu item based on admin role
            const adminLink = document.getElementById('nav-admin');
            const settingsLink = document.getElementById('nav-settings');
            if (currentUser.role === 'admin') {
                if (adminLink) adminLink.classList.remove('is-hidden');
                if (settingsLink) settingsLink.style.display = 'block';
            } else {
                if (adminLink) adminLink.classList.add('is-hidden');
                if (settingsLink) settingsLink.style.display = 'none';
            }

            // Update email display in headers
            updateUserEmailDisplay();

            return true;

        } catch (error) {
            console.error('Authentication check failed:', error);
            localStorage.removeItem('sessionToken');
            window.location.href = '/login.html';
            return false;
        }
    }

    function updateUserEmailDisplay() {
        const emailDisplays = [
            document.getElementById('user-email-display'),
            document.getElementById('user-email-display-upload'),
            document.getElementById('user-email-display-project'),
            document.getElementById('user-email-display-admin')
        ];

        const email = currentUser ? currentUser.email : '';
        
        emailDisplays.forEach(display => {
            if (display) {
                display.textContent = email;
                display.style.display = email ? 'block' : 'none';
            }
        });
    }

    function openSettings() {
        if (currentUser && currentUser.role === 'admin') {
            navigateTo('admin');
        } else {
            alert('Admin access required');
        }
    }

    // Admin Panel Functions
    async function loadAdminUsers() {
        const sessionToken = localStorage.getItem('sessionToken');
        const adminLoading = document.getElementById('admin-loading');
        const adminUsersContent = document.getElementById('admin-users-content');
        const adminMessage = document.getElementById('admin-message');
        
        if (!sessionToken) {
            window.location.href = '/login.html';
            return;
        }

        adminLoading.classList.remove('hidden');
        adminUsersContent.classList.add('hidden');
        adminMessage.classList.add('hidden');

        try {
            const response = await fetch(`${API_URL}/admin/users`, {
                headers: { 'Authorization': `Bearer ${sessionToken}` }
            });
            
            if (response.status === 401 || response.status === 403) {
                window.location.href = '/login.html';
                return;
            }
            
            if (!response.ok) {
                throw new Error('Failed to load users');
            }
            
            const users = await response.json();
            displayAdminUsers(users);
            
        } catch (error) {
            console.error('Error loading users:', error);
            showAdminMessage('Failed to load users', 'error');
        } finally {
            adminLoading.classList.add('hidden');
            adminUsersContent.classList.remove('hidden');
        }
    }

    function displayAdminUsers(users) {
        const usersTbody = document.getElementById('admin-users-tbody');
        usersTbody.innerHTML = '';
        
        users.forEach(user => {
            const row = document.createElement('tr');
            
            const statusClass = `status-${user.status}`;
            
            row.innerHTML = `
                <td>${user.email}</td>
                <td><span class="status-badge ${statusClass}">${user.status}</span></td>
                <td>${formatAdminDate(user.created_at)}</td>
                <td>${formatAdminDate(user.last_login)}</td>
                <td>-</td>
            `;
            
            usersTbody.appendChild(row);
        });
    }

    function formatAdminDate(dateString) {
        if (!dateString) return 'Never';
        return new Date(dateString).toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' });
    }

    function showAdminMessage(text, type = 'success') {
        const adminMessage = document.getElementById('admin-message');
        adminMessage.textContent = text;
        adminMessage.className = `admin-message ${type}`;
        adminMessage.classList.remove('hidden');
        
        setTimeout(() => {
            adminMessage.classList.add('hidden');
        }, 5000);
    }

    async function logout() {
        console.log('üö™ Logout function called');
        const sessionToken = localStorage.getItem('sessionToken');
        console.log('Session token:', sessionToken ? 'exists' : 'not found');

        // Call backend logout endpoint to invalidate session
        if (sessionToken) {
            try {
                console.log('üì° Calling backend logout endpoint...');
                const response = await fetch(`${API_URL}/auth/logout`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${sessionToken}` }
                });
                console.log('Backend logout response:', response.status);
            } catch (error) {
                console.error('Error calling logout endpoint:', error);
                // Continue with logout even if backend call fails
            }
        }

        // Clear session token
        console.log('üßπ Clearing session token...');
        localStorage.removeItem('sessionToken');

        // Clear current user
        currentUser = null;
        console.log('üë§ Current user cleared');

        // Clear email display
        updateUserEmailDisplay();

        // Redirect to login page
        console.log('üîÑ Redirecting to login page...');
        window.location.href = '/login.html';
    }

    // Make functions globally available
    window.openSettings = openSettings;
    window.logout = logout;

    // Add event listener for logout button as backup
    document.addEventListener('DOMContentLoaded', function() {
        const logoutBtn = document.getElementById('nav-logout');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('üö™ Logout button clicked via event listener (sidebar footer)');
                logout();
            });
        }
    });

    // Share Project Functions
    function showShareProjectModal(project) {
        shareProjectName.textContent = project.name;
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        shareProjectModal.classList.remove('is-hidden');
        shareEmailInput.focus();

        // Store project data for sharing
        shareProjectModal.dataset.projectId = project.id;
        shareProjectModal.dataset.projectName = project.name;
    }

    function hideShareProjectModal() {
        shareProjectModal.classList.add('is-hidden');
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        delete shareProjectModal.dataset.projectId;
        delete shareProjectModal.dataset.projectName;
    }

    // Update Tag Modal Functions
    function showUpdateTagModal() {
        console.log('showUpdateTagModal called');

        // Reset state
        tagsToRemove.clear();
        removeAllTags = false;
        tagsToAdd.clear();

        // Hide success modal if visible
        tagUpdateSuccessModal.classList.add('is-hidden');

        // Reset Remove All Tags button
        const removeAllBtn = document.getElementById('remove-all-tags-btn');
        removeAllBtn.textContent = 'Remove All Tags';
        removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

        // Get all unique tags from selected images
        const originalTags = new Set();
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags) {
                image.tags.forEach(tag => originalTags.add(tag));
            }
        });

        const sortedTags = Array.from(originalTags).sort();
        const tagCount = sortedTags.length;

        // Update modal header with tag count
        const updateTagHeader = document.querySelector('#update-tag-modal h2');
        if (updateTagHeader) {
            updateTagHeader.textContent = `Update Tags {#${tagCount}}`;
        }

        // Populate original tags list with X buttons based on selection count
        populateOriginalTagsList(sortedTags);

        // Clear new tags list and input
        newTagsList.innerHTML = '';
        newTagInput.value = '';
        tagWarning.classList.add('is-hidden');

        // Show modal
        updateTagModal.classList.remove('is-hidden');
    }

    function updateTagCount() {
        // Count all tags: original tags (not marked for removal) + new tags
        const originalTagElements = originalTagsList.querySelectorAll('.tag-item-removable:not(.marked-for-removal)');
        const newTagElements = newTagsList.querySelectorAll('.tag-item');
        const totalCount = originalTagElements.length + newTagElements.length;
        
        // Update modal header with tag count
        const updateTagHeader = document.querySelector('#update-tag-modal h2');
        if (updateTagHeader) {
            updateTagHeader.textContent = `Update Tags {#${totalCount}}`;
        }
    }

    function populateOriginalTagsList(tags) {
        originalTagsList.innerHTML = '';

        // Determine which tags are common to ALL selected images
        const commonTags = getCommonTagsFromSelectedImages();

        tags.forEach(tag => {
            const tagElement = document.createElement('div');
            tagElement.className = 'tag-item-removable';

            const tagText = document.createElement('span');
            tagText.textContent = tag;
            tagElement.appendChild(tagText);

            // Show X button if this tag is common to ALL selected images
            const isCommonTag = commonTags.includes(tag);
            if (isCommonTag) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => removeIndividualTag(tag);
                tagElement.appendChild(removeBtn);
            }

            originalTagsList.appendChild(tagElement);
        });
        
        // Update tag count after populating
        updateTagCount();
    }

    function getCommonTagsFromSelectedImages() {
        if (selectedImages.length === 0) return [];

        // Get tags from first image
        const firstImage = libraryImages.find(img => img.id === selectedImages[0]);
        if (!firstImage || !firstImage.tags) return [];

        let commonTags = [...firstImage.tags];

        // For each subsequent image, keep only tags that are also in that image
        for (let i = 1; i < selectedImages.length; i++) {
            const image = libraryImages.find(img => img.id === selectedImages[i]);
            if (!image || !image.tags) {
                return []; // If any image has no tags, no tags are common
            }
            commonTags = commonTags.filter(tag => image.tags.includes(tag));
        }

        return commonTags;
    }

    function hideUpdateTagModal() {
        updateTagModal.classList.add('is-hidden');
        originalTagsList.innerHTML = '';
        newTagsList.innerHTML = '';
        newTagInput.value = '';
        tagWarning.classList.add('is-hidden');

        // Reset state
        tagsToRemove.clear();
        removeAllTags = false;
        tagsToAdd.clear();

        // Reset Remove All Tags button
        const removeAllBtn = document.getElementById('remove-all-tags-btn');
        removeAllBtn.textContent = 'Remove All Tags';
        removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

        // Hide success modal if visible
        tagUpdateSuccessModal.classList.add('is-hidden');
    }

    function removeIndividualTag(tag) {
        const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
        const tagElement = Array.from(tagElements).find(element =>
            element.querySelector('span').textContent === tag
        );

        if (!tagElement) return;

        // Toggle removal state
        if (tagsToRemove.has(tag)) {
            // Currently marked for removal - undo it
            console.log('Unmarking tag for removal:', tag);
            tagsToRemove.delete(tag);
            tagElement.classList.remove('marked-for-removal');
        } else {
            // Not marked for removal - mark it
            console.log('Marking tag for removal:', tag);
            tagsToRemove.add(tag);
            tagElement.classList.add('marked-for-removal');
        }
        
        // Update tag count after removal state change
        updateTagCount();
    }

    function removeAllTagsFromSelected() {
        const removeAllBtn = document.getElementById('remove-all-tags-btn');

        if (!removeAllTags) {
            // Mark all tags for removal
            console.log('Marking all tags for removal');
            removeAllTags = true;
            removeAllBtn.textContent = 'Undo Remove All';
            removeAllBtn.style.backgroundColor = '#ff9800'; // Orange for undo

            // Visual feedback - dim all tags
            const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
            tagElements.forEach(element => {
                element.classList.add('marked-for-removal');
            });
        } else {
            // Undo remove all tags
            console.log('Undoing remove all tags');
            removeAllTags = false;
            removeAllBtn.textContent = 'Remove All Tags';
            removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

            // Remove visual feedback
            const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
            tagElements.forEach(element => {
                element.classList.remove('marked-for-removal');
            });
        }
        
        // Update tag count after remove all/undo
        updateTagCount();
    }

    function addNewTags() {
        const inputValue = newTagInput.value.trim();

        if (!inputValue) {
            tagWarning.classList.remove('is-hidden');
            setTimeout(() => {
                tagWarning.classList.add('is-hidden');
            }, 3000);
            return;
        }

        tagWarning.classList.add('is-hidden');

        // Split by comma and clean up tags
        const newTags = inputValue.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);

        newTags.forEach(tag => {
            if (!tagsToAdd.has(tag)) {
                tagsToAdd.add(tag);

                // Add to visual list with X button
                const tagElement = document.createElement('div');
                tagElement.className = 'tag-item tag-item-removable';

                const tagText = document.createElement('span');
                tagText.textContent = tag;
                tagElement.appendChild(tagText);

                const removeBtn = document.createElement('button');
                removeBtn.className = 'tag-remove-btn';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = () => removeNewTag(tag, tagElement);
                tagElement.appendChild(removeBtn);

                newTagsList.appendChild(tagElement);
            }
        });

        // Clear input
        newTagInput.value = '';
        updateTagCount(); // Update count after adding new tags
    }

    function removeNewTag(tag, tagElement) {
        console.log('Removing new tag:', tag);
        tagsToAdd.delete(tag);
        tagElement.remove();
        updateTagCount(); // Update count when tag is removed
    }

    function showTagUpdateSuccess() {
        // Show success modal
        tagUpdateSuccessModal.classList.remove('is-hidden');
    }

    function hideTagUpdateSuccess() {
        tagUpdateSuccessModal.classList.add('is-hidden');
    }

    function showTagRemovalNotification(tagText, deselectedCount) {
        // Update the message with specific details
        tagRemovalMessage.textContent = `Tag "${tagText}" removed and ${deselectedCount} image${deselectedCount !== 1 ? 's' : ''} deselected!`;

        // Show the notification modal
        tagRemovalNotificationModal.classList.remove('is-hidden');

        // Auto-hide after 3 seconds
        setTimeout(() => {
            hideTagRemovalNotification();
        }, 3000);
    }

    function hideTagRemovalNotification() {
        tagRemovalNotificationModal.classList.add('is-hidden');
    }

    // Tag Removal Confirmation Functions
    function showTagRemovalConfirmation(tagText) {
        // Count how many images have this tag from both selected and tag-selected images
        const imagesWithTag = [];
        const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];

        allSelectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesWithTag.push(imageId);
            }
        });

        // Update modal content
        tagRemovalTagName.textContent = tagText;
        tagRemovalImageCount.textContent = imagesWithTag.length;

        // Store tag for removal action
        tagRemovalConfirmModal.dataset.tagToRemove = tagText;

        // Show modal
        tagRemovalConfirmModal.classList.remove('is-hidden');
    }

    function hideTagRemovalConfirmModal() {
        tagRemovalConfirmModal.classList.add('is-hidden');
        delete tagRemovalConfirmModal.dataset.tagToRemove;
    }

    function confirmTagRemoval() {
        const tagToRemove = tagRemovalConfirmModal.dataset.tagToRemove;
        if (tagToRemove) {
            // Hide confirmation modal first
            hideTagRemovalConfirmModal();

            // Remove the tag using pool view function to stay in pool
            removeSearchTagChipInPoolView(tagToRemove);
        }
    }

    // Clear All Confirmation Functions
    function showClearAllConfirmation() {
        // Count current selections and tags
        const totalSelections = selectedImages.length + tagSelectedImages.length;
        const uniqueSelections = [...new Set([...selectedImages, ...tagSelectedImages])].length;
        const totalTags = searchTags.length;

        // Update modal content
        clearAllSelectionCount.textContent = uniqueSelections;
        clearAllTagCount.textContent = totalTags;

        // Show modal
        clearAllConfirmModal.classList.remove('is-hidden');
    }

    function hideClearAllConfirmModal() {
        clearAllConfirmModal.classList.add('is-hidden');
    }

    function confirmClearAll() {
        // Hide confirmation modal first
        hideClearAllConfirmModal();

        // Execute the clear all action
        clearAllSearchChips();
    }


    async function saveTagUpdates() {
        console.log('=== SAVE TAG UPDATES START ===');
        console.log('Selected images:', selectedImages);
        console.log('Selected images count:', selectedImages.length);
        console.log('Tags to remove:', Array.from(tagsToRemove));
        console.log('Remove all tags:', removeAllTags);
        console.log('Tags to add:', Array.from(tagsToAdd));

        // Check if there are any changes
        if (!removeAllTags && tagsToRemove.size === 0 && tagsToAdd.size === 0) {
            console.log('No changes to save');
            hideUpdateTagModal();
            return;
        }

        try {
            let successCount = 0;
            let errorCount = 0;
            const updateResults = [];

            // Process each selected image
            for (const imageId of selectedImages) {
                try {
                    console.log(`--- Processing image ${imageId} ---`);
                    const image = libraryImages.find(img => img.id === imageId);
                    if (!image) {
                        console.warn(`Image ${imageId} not found in libraryImages`);
                        continue;
                    }

                    const originalTags = image.tags ? [...image.tags] : [];
                    console.log(`Original tags for image ${imageId}:`, originalTags);

                    let currentTags = [...originalTags];

                    // Handle tag removal
                    if (removeAllTags) {
                        currentTags = [];
                        console.log(`Removing all tags from image ${imageId}`);
                    } else {
                        // Remove individual tags
                        tagsToRemove.forEach(tagToRemove => {
                            const beforeLength = currentTags.length;
                            currentTags = currentTags.filter(tag => tag !== tagToRemove);
                            const afterLength = currentTags.length;
                            if (beforeLength !== afterLength) {
                                console.log(`Removed tag "${tagToRemove}" from image ${imageId}`);
                            }
                        });
                    }

                    // Add new tags
                    tagsToAdd.forEach(tagToAdd => {
                        if (!currentTags.includes(tagToAdd)) {
                            currentTags.push(tagToAdd);
                            console.log(`Added tag "${tagToAdd}" to image ${imageId}`);
                        }
                    });

                    console.log(`Final tags for image ${imageId}:`, currentTags);

                    // Update the image in backend
                    await updateImageTags(imageId, currentTags);

                    // Update local image object
                    image.tags = currentTags;

                    successCount++;
                    updateResults.push({ imageId, status: 'success', tags: currentTags });
                    console.log(`‚úì Successfully updated image ${imageId}`);

                } catch (imageError) {
                    errorCount++;
                    updateResults.push({ imageId, status: 'error', error: imageError.message });
                    console.error(`‚úó Failed to update image ${imageId}:`, imageError);
                }
            }

            console.log('=== UPDATE SUMMARY ===');
            console.log(`Total images processed: ${selectedImages.length}`);
            console.log(`Successful updates: ${successCount}`);
            console.log(`Failed updates: ${errorCount}`);
            console.log('Update results:', updateResults);

            if (errorCount > 0) {
                console.warn(`${errorCount} images failed to update. Check the logs above for details.`);
                alert(`Warning: ${errorCount} out of ${selectedImages.length} images failed to update. Check the browser console for details.`);
            }

            console.log('Tag updates completed. Refreshing display...');

            // Refresh the library display
            await displayLibraryImages();

            // Close update tag modal first
            hideUpdateTagModal();

            // Show success modal
            showTagUpdateSuccess();

            console.log('=== SAVE TAG UPDATES END ===');

        } catch (error) {
            console.error('Critical error during tag updates:', error);
            alert('Failed to update tags. Please try again.');
        }
    }

    async function updateImageTags(imageId, tags) {
        console.log(`Updating tags for image ${imageId}:`, tags);
        console.log(`Making PUT request to: ${API_URL}/images/${imageId}/tags`);

        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json',
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images/${imageId}/tags`, {
                method: 'PUT',
                headers: headers,
                body: JSON.stringify({ tags: tags })
            });

            console.log(`Response status: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Server error response:`, errorText);
                throw new Error(`Failed to update tags for image ${imageId}: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const result = await response.json();
            console.log(`Successfully updated tags for image ${imageId}:`, result);
            return result;
        } catch (error) {
            console.error(`Network or parsing error for image ${imageId}:`, error);
            throw error;
        }
    }

    // Delete Image Functions
    function showDeleteImageModal() {
        const totalSelected = selectedImages.length + tagSelectedImages.length;
        deleteCount.textContent = totalSelected;
        deleteImageModal.classList.remove('is-hidden');
    }

    function hideDeleteImageModal() {
        deleteImageModal.classList.add('is-hidden');
    }

    async function deleteSelectedImages() {
        try {
            // Get all selected image IDs (both manual and tag-selected)
            const allSelectedIds = [...new Set([...selectedImages, ...tagSelectedImages])];

            if (allSelectedIds.length === 0) {
                alert('No images selected for deletion.');
                return;
            }

            console.log(`Deleting ${allSelectedIds.length} images:`, allSelectedIds);

            // Delete each image
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            for (const imageId of allSelectedIds) {
                const response = await fetch(`${API_URL}/images/${imageId}`, {
                    method: 'DELETE',
                    headers: headers
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Failed to delete image ${imageId}:`, errorText);
                    console.error(`Response status: ${response.status}, Status text: ${response.statusText}`);
                    throw new Error(`Failed to delete image ${imageId}: ${response.status} ${response.statusText} - ${errorText}`);
                }

                console.log(`Successfully deleted image ${imageId}`);
            }

            // Clear all selections
            selectedImages = [];
            tagSelectedImages = [];
            imageSelectionSource = {};
            imageSelectionOrder = {};

            // Hide delete modal
            hideDeleteImageModal();

            // Return to library view with zero selections
            showingSelectionPool = false;
            isPoolView = false;

            // Refresh the library display
            await displayLibraryImages();

            console.log(`Successfully deleted ${allSelectedIds.length} images and returned to library`);

        } catch (error) {
            console.error('Error deleting images:', error);
            alert('Failed to delete some images. Please try again.');
        }
    }

    async function shareProject() {
        const email = shareEmailInput.value.trim();
        const message = shareMessageInput.value.trim();
        const projectId = shareProjectModal.dataset.projectId;
        const projectName = shareProjectModal.dataset.projectName;

        if (!email) {
            alert('Please enter a recipient email address.');
            shareEmailInput.focus();
            return;
        }

        if (!email.includes('@') || !email.includes('.')) {
            alert('Please enter a valid email address.');
            shareEmailInput.focus();
            return;
        }

        // Show loading state and overlay
        sendShareBtn.disabled = true;
        sendShareBtn.textContent = 'Sending...';
        hideShareProjectModal();
        emailSendingOverlay.classList.remove('is-hidden');

        try {
            // Get the project data to include breakdown in email
            const project = projects.find(p => p.id == projectId);
            const breakdownText = formatSelectionBreakdown(project?.selection_breakdown, project);

            console.log('=== EMAIL SHARING ===');
            console.log('Project for email:', project);
            console.log('Breakdown text being sent:', breakdownText);

            const emailData = {
                recipient_email: email,
                message: message,
                breakdown_text: breakdownText  // Send formatted breakdown to backend
            };

            console.log('Email data being sent to backend:', emailData);

            const response = await fetch(`${API_URL}/projects/${projectId}/share`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(emailData)
            });

            if (response.ok) {
                emailSendingOverlay.classList.add('is-hidden');
                alert(`Project "${projectName}" has been shared successfully with ${email}!`);

                // Refresh email history displays immediately
                await refreshEmailHistoryDisplays(projectId);
            } else {
                const error = await response.text();
                throw new Error(error || 'Failed to share project');
            }
        } catch (error) {
            console.error('Error sharing project:', error);
            emailSendingOverlay.classList.add('is-hidden');
            alert('Failed to share project. Please try again.');
        } finally {
            // Reset button state
            sendShareBtn.disabled = false;
            sendShareBtn.textContent = 'Send Email';
            emailSendingOverlay.classList.add('is-hidden');
        }
    }

    // --- Event Listeners ---

    navLinks.library.addEventListener('click', (e) => { e.preventDefault(); navigateTo('library'); });
    navLinks.upload.addEventListener('click', (e) => { e.preventDefault(); navigateTo('upload'); });
    navLinks.project.addEventListener('click', (e) => { e.preventDefault(); navigateTo('project'); });
    if (navLinks.admin) {
        navLinks.admin.addEventListener('click', (e) => { 
            e.preventDefault(); 
            if (currentUser && currentUser.role === 'admin') {
                navigateTo('admin'); 
            } else {
                alert('Admin access required');
            }
        });
    }

    // Initialize: Load images when page first loads (if library page is visible)
    if (pages.library && !pages.library.classList.contains('is-hidden')) {
        console.log('Initial page load - loading library images');
        displayLibraryImages().catch(error => {
            console.error('Error loading images on initial page load:', error);
        });
    }

    // Broken image notification dismiss
    document.getElementById('dismiss-notification').addEventListener('click', () => {
        // Hide notification immediately
        document.getElementById('broken-image-notification').classList.add('hidden');

        // Set persistent dismissal flag so it won't show again
        brokenImageNotificationDismissed = true;
        localStorage.setItem('brokenImageNotificationDismissed', 'true');

        console.log('Broken image notification dismissed permanently');
    });

    fileInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
    });

    clearAllButton.addEventListener('click', () => {
        previewGrid.innerHTML = '';
        filesToUpload = [];
        fileInput.value = '';
    });

    subjInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSubjCommit();
        } else if (e.key === 'Backspace' && subjInput.value === '') {
            const chips = subjChips.querySelectorAll('.chip');
            const last = chips[chips.length - 1];
            if (last) subjChips.removeChild(last);
        }
    });

    // Add event listeners for all objective metadata inputs
    [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objWidthInput, objLengthInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
        if (input) {
            input.addEventListener('keydown', (e) => {
                // Special handling for width and length inputs - Tab should move focus without clearing
                if ((input === objWidthInput || input === objLengthInput) && e.key === 'Tab') {
                    // Allow Tab to work normally (move to next field) without clearing input
                    // Only commit if Enter or comma is pressed
                    if (e.key === 'Enter' || e.key === ',') {
                        e.preventDefault();
                        handleObjCommit(input);
                    }
                    // Tab key will work normally (no preventDefault)
                    return;
                }
                
                if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
                    e.preventDefault();
                    handleObjCommit(input);
                }
            });
        }
    });

    // Auto-fill button event listener
    autoFillBtn.addEventListener('click', autoFillMetadata);

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.add('is-dragover'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.remove('is-dragover'), false);
    });
    dropzone.addEventListener('drop', (e) => {
        handleFiles(e.dataTransfer.files);
    }, false);

    window.addEventListener('paste', (e) => {
        if (pages.upload.classList.contains('is-hidden')) return;
        handleFiles(e.clipboardData.files);
        dropzone.classList.add('is-dragover');
        setTimeout(() => dropzone.classList.remove('is-dragover'), 150);
    });

    prevButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex - 1);
        } else {
            showImage(currentImageIndex - 1);
        }
    });

    nextButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex + 1);
        } else {
            showImage(currentImageIndex + 1);
        }
    });

    closeModal.addEventListener('click', hideModal);


    // Add keyboard support for Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (!modal.classList.contains('is-hidden')) {
                hideModal();
            } else if (!tagRemovalConfirmModal.classList.contains('is-hidden')) {
                hideTagRemovalConfirmModal();
            } else if (!clearAllConfirmModal.classList.contains('is-hidden')) {
                hideClearAllConfirmModal();
            } else if (feelingsWarningModal && !feelingsWarningModal.classList.contains('is-hidden')) {
                feelingsWarningModal.classList.add('is-hidden');
                if (subjInput) {
                    subjInput.focus();
                }
            } else if (noImagesWarningModal && !noImagesWarningModal.classList.contains('is-hidden')) {
                noImagesWarningModal.classList.add('is-hidden');
                if (fileInput) {
                    fileInput.click();
                }
            } else if (dimensionWarningModal && !dimensionWarningModal.classList.contains('is-hidden')) {
                dimensionWarningModal.classList.add('is-hidden');
                if (objWidthInput) {
                    objWidthInput.focus();
                }
            }
        }
    });

    const loadingOverlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const uploadMoreBtn = document.getElementById('upload-more-btn');
    const goToLibraryBtn = document.getElementById('go-to-library-btn');
    const feelingsWarningModal = document.getElementById('feelings-warning-modal');
    const okFeelingsBtn = document.getElementById('ok-feelings-btn');
    const noImagesWarningModal = document.getElementById('no-images-warning-modal');
    const okNoImagesBtn = document.getElementById('ok-no-images-btn');
    const dimensionWarningModal = document.getElementById('dimension-warning-modal');
    const okDimensionBtn = document.getElementById('ok-dimension-btn');

    function clearUploadUI() {
        previewGrid.innerHTML = '';
        subjChips.innerHTML = '';
        objChips.innerHTML = '';

        // Clear all objective metadata inputs
        [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objWidthInput, objLengthInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
            if (input) input.value = '';
        });

        filesToUpload = [];
        fileInput.value = '';
    }

    uploadMoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
    });

    goToLibraryBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
        navigateTo('library');
    });

    // Handle OK button for feelings warning modal
    if (okFeelingsBtn && feelingsWarningModal) {
        okFeelingsBtn.addEventListener('click', () => {
            feelingsWarningModal.classList.add('is-hidden');
            // Focus on subjective input
            if (subjInput) {
                subjInput.focus();
            }
        });
    }

    // Handle OK button for no images warning modal
    if (okNoImagesBtn && noImagesWarningModal) {
        okNoImagesBtn.addEventListener('click', () => {
            noImagesWarningModal.classList.add('is-hidden');
            // Focus on file input
            if (fileInput) {
                fileInput.click();
            }
        });
    }

    // Handle OK button for dimension warning modal
    if (okDimensionBtn && dimensionWarningModal) {
        okDimensionBtn.addEventListener('click', () => {
            dimensionWarningModal.classList.add('is-hidden');
            // Focus on width input
            if (objWidthInput) {
                objWidthInput.focus();
            }
        });
    }

    // Handle OK button for feelings warning modal
    if (okFeelingsBtn) {
        okFeelingsBtn.addEventListener('click', () => {
            feelingsWarningModal.classList.add('is-hidden');
            // Focus on subjective input
            if (subjInput) {
                subjInput.focus();
            }
        });
    }

    uploadButton.addEventListener('click', async () => {
        const subjTags = Array.from(subjChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[√óx]$/, '').trim());
        const objTags = Array.from(objChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[√óx]$/, '').trim());
        
        // Get width/length values from input fields
        const widthValue = objWidthInput ? objWidthInput.value.trim() : '';
        const lengthValue = objLengthInput ? objLengthInput.value.trim() : '';
        
        // Check if width/length are already in chips
        const hasWidthInChips = objTags.some(tag => tag.toLowerCase().startsWith('width:'));
        const hasLengthInChips = objTags.some(tag => tag.toLowerCase().startsWith('length:'));
        
        // Add width/length from input fields if they exist and aren't already in chips
        if (widthValue && !hasWidthInChips) {
            // Add prefix if not already present
            const widthTag = widthValue.toLowerCase().startsWith('width:') ? widthValue : `width:${widthValue}`;
            objTags.push(widthTag);
        }
        if (lengthValue && !hasLengthInChips) {
            // Add prefix if not already present
            const lengthTag = lengthValue.toLowerCase().startsWith('length:') ? lengthValue : `length:${lengthValue}`;
            objTags.push(lengthTag);
        }
        
        // Process all other objective inputs and add prefixes if needed
        const objectiveInputs = [
            { input: objBookInput, prefix: 'book:' },
            { input: objPageInput, prefix: 'page:' },
            { input: objRowInput, prefix: 'row:' },
            { input: objColumnInput, prefix: 'column:' },
            { input: objTypeInput, prefix: 'type:' },
            { input: objMaterialInput, prefix: 'material:' },
            { input: objRemarkInput, prefix: 'remark:' },
            { input: objBrandInput, prefix: 'brand:' },
            { input: objColorInput, prefix: 'color:' }
        ];
        
        objectiveInputs.forEach(({ input, prefix }) => {
            if (input && input.value.trim()) {
                const value = input.value.trim();
                const hasInChips = objTags.some(tag => tag.toLowerCase().startsWith(prefix));
                if (!hasInChips) {
                    // Add prefix if not already present
                    const tag = value.toLowerCase().startsWith(prefix) ? value : `${prefix}${value}`;
                    objTags.push(tag);
                }
            }
        });
        
        const allTags = [...subjTags, ...objTags];

        if (filesToUpload.length === 0) {
            // Show warning modal instead of alert
            if (noImagesWarningModal) {
                noImagesWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        // Validate that at least one subjective tag (feeling) is added
        if (subjTags.length === 0) {
            // Show warning modal instead of alert
            if (feelingsWarningModal) {
                feelingsWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        // Validate that at least one dimension field (width or length) is filled
        if (!widthValue && !lengthValue && !hasWidthInChips && !hasLengthInChips) {
            // Show warning modal instead of alert
            if (dimensionWarningModal) {
                dimensionWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        const formData = new FormData();
        filesToUpload.forEach(file => {
            formData.append('images', file);
        });
        formData.append('tags', JSON.stringify(allTags));

        uploadButton.disabled = true;
        loadingOverlay.classList.remove('is-hidden');

        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                headers: headers,
                body: formData
            });

            loadingOverlay.classList.add('is-hidden');

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${errorText}`);
            }

            // Track tag creation timestamps for uploaded images
            const currentTimestamp = Date.now();
            allTags.forEach(tag => {
                if (!tagCreationOrder[tag]) {
                    tagCreationOrder[tag] = currentTimestamp;
                    console.log(`Tag "${tag}" first created during upload at:`, tagCreationOrder[tag]);
                }
            });
            saveTagCreationOrder();

            // Clear the upload form
            clearUploadUI();
            
            // Reload images to show the newly uploaded ones
            await displayLibraryImages();

            // On success, show the custom confirmation dialog
            confirmModal.classList.remove('is-hidden');

        } catch (error) {
            console.error('Error uploading images:', error);
            alert(`An error occurred during upload. Please try again. Details: ${error.message}`);
            loadingOverlay.classList.add('is-hidden');
            uploadButton.disabled = false;
        }
    });





    // Handle tag input with Enter, Tab, comma, and autocomplete navigation
    librarySearchInput.addEventListener('keydown', async (e) => {
        if (autocompleteVisible) {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                highlightAutocompleteItem('down');
                return;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                highlightAutocompleteItem('up');
                return;
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideAutocomplete();
                return;
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectHighlightedItem()) {
                    return; // Item was selected from autocomplete
                }
                // Fall through to normal tag commit if no item highlighted
            }
        }

        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            await handleSearchTagCommit();
        }
        // Note: Backspace functionality for removing tag chips has been disabled
        // Users must use the "x" button on individual chips or "Clear All" button
    });

    // Handle autocomplete on input
    librarySearchInput.addEventListener('input', async (e) => {
        const value = e.target.value;
        const lastCommaIndex = value.lastIndexOf(',');

        // Get the current word being typed (after last comma or from beginning)
        const currentWord = lastCommaIndex === -1
            ? value.trim()
            : value.substring(lastCommaIndex + 1).trim();

        if (currentWord.length >= 2) {
            await showAutocomplete(currentWord);
        } else {
            hideAutocomplete();
        }
    });

    // Hide autocomplete when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-container')) {
            hideAutocomplete();
        }
    });

    // Also handle input changes for real-time search
    librarySearchInput.addEventListener('input', (e) => {
        console.log('=== INPUT EVENT TRIGGERED ===');
        console.log('Input value:', `"${e.target.value}"`);
        console.log('programmaticUpdate flag:', e.target.dataset.programmaticUpdate);
        console.log('isPoolView:', isPoolView);
        
        // IMPORTANT: Only clear chips if this is a USER action, not programmatic update
        // Check if we're in the middle of removing a single tag chip
        // ALSO: Don't clear all chips if we're in pool view to prevent losing pool context
        if (e.target.value === '' && !e.target.dataset.programmaticUpdate && !isPoolView) {
            console.log('CONDITIONS MET - calling clearAllSearchChips()');
            clearAllSearchChips();
        } else {
            console.log('CONDITIONS NOT MET - NOT calling clearAllSearchChips()');
            console.log('- value empty:', e.target.value === '');
            console.log('- not programmatic:', !e.target.dataset.programmaticUpdate);
            console.log('- not pool view:', !isPoolView);
        }
        console.log('=== INPUT EVENT END ===');
    });

    // Ensure input is fresh on focus
    librarySearchInput.addEventListener('focus', () => {
        // Clear any browser-suggested values on focus
        setTimeout(() => {
            if (librarySearchInput.value && searchTags.length === 0) {
                librarySearchInput.value = '';
            }
        }, 0);
    });

    // Prevent browser from storing values
    librarySearchInput.addEventListener('blur', () => {
        // Don't let browser remember the value
        librarySearchInput.setAttribute('autocomplete', 'new-password');
        setTimeout(() => {
            librarySearchInput.setAttribute('autocomplete', 'off');
        }, 100);
    });

    async function handleSearchTagCommit() {
        const inputValue = librarySearchInput.value.trim();
        if (!inputValue) return;

        console.log('=== ADDING TAG ===');
        console.log('Before adding tag - selectedImages:', selectedImages);
        console.log('Before adding tag - tagSelectedImages:', tagSelectedImages);
        console.log('Before adding tag - isPoolView:', isPoolView);

        // Split by comma and add each tag as a chip
        const newTags = inputValue.split(',').map(tag => tag.trim()).filter(tag => tag);
        for (const tagText of newTags) {
            await addSearchTagChip(tagText, true); // Default to has matches, will be updated
        }

        // Clear input and refresh search
        librarySearchInput.value = '';

        console.log('About to call displayLibraryImages after adding tag');
        displayLibraryImages();
    }

    // Removed searchModeRadios event listener - using default OR mode

    // Clear all button (clears both tags and selected images)
    clearAllTagsBtn.addEventListener('click', () => {
        showClearAllConfirmation();
    });

    // Initialize button state
    updateClearButtonState();

    // Tag creation order persistence functions
    function saveTagCreationOrder() {
        try {
            localStorage.setItem('tagCreationOrder', JSON.stringify(tagCreationOrder));
        } catch (error) {
            console.error('Error saving tag creation order:', error);
        }
    }

    function loadTagCreationOrder() {
        try {
            const saved = localStorage.getItem('tagCreationOrder');
            if (saved) {
                tagCreationOrder = JSON.parse(saved);
                console.log('Loaded tag creation order:', tagCreationOrder);
            }
        } catch (error) {
            console.error('Error loading tag creation order:', error);
            tagCreationOrder = {};
        }
    }





    // Initialize search input to be completely fresh
    initializeFreshSearchInput();

    // Load tag creation order from localStorage
    loadTagCreationOrder();

    // Selection and project event listeners
    selectAllBtn.addEventListener('click', selectAllImages);
    deselectAllBtn.addEventListener('click', deselectAllImages);
    updateTagBtn.addEventListener('click', () => {
        console.log('Update Tag button clicked - showing modal');
        showUpdateTagModal();
    });
    deleteImageBtn.addEventListener('click', () => {
        console.log('Delete Image button clicked - showing modal');
        showDeleteImageModal();
    });
    viewPoolBtn.addEventListener('click', handleViewPoolClick);
    backToLibraryBtn.addEventListener('click', backToLibrary);
    addToProjectBtn.addEventListener('click', showProjectNameModal);
    cancelProjectBtn.addEventListener('click', hideProjectNameModal);
    createProjectBtn.addEventListener('click', createProject);

    // Project created confirmation modal event listeners
    addMoreProjectsBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Stay in current view to allow selecting more images for another project
        console.log('User chose to add more projects');
    });

    goToProjectBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Navigate to the project page
        navigateTo('project');
        console.log('User chose to go to project page');
    });

    // Project detail modal event listeners
    closeProjectDetailBtn.addEventListener('click', hideProjectDetailModal);

    // Project search functionality
    projectSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        filterProjects(searchTerm);
    });

    projectFilterBtn.addEventListener('click', () => {
        // Future: Add advanced filtering options
        console.log('Filter button clicked - future feature');
    });

    // Project view toggle event listener
    projectViewToggleBtn.addEventListener('click', toggleProjectView);

    // Image preview overlay event listeners
    previewOverlayClose.addEventListener('click', hideImagePreviewOverlay);

    // Close overlay when clicking outside the image
    imagePreviewOverlay.addEventListener('click', (e) => {
        if (e.target === imagePreviewOverlay) {
            hideImagePreviewOverlay();
        }
    });

    // Navigation arrow event listeners
    previewNavLeft.addEventListener('click', () => {
        navigatePreview('left');
    });

    previewNavRight.addEventListener('click', () => {
        navigatePreview('right');
    });

    // Close overlay with Escape key and add arrow key scrolling/navigation
    document.addEventListener('keydown', (e) => {
        if (imagePreviewOverlay.classList.contains('show')) {
            if (e.key === 'Escape') {
                hideImagePreviewOverlay();
            } else if (isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePreview('left');
            } else if (isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                navigatePreview('right');
            } else if (!isSelectionPoolPreview && e.key === 'ArrowUp') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowDown') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop += 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft += 50;
            }
        }
    });

    // Project name input enter key
    projectNameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            createProject();
        } else if (e.key === 'Escape') {
            hideProjectNameModal();
        }
    });

    // Share project modal event listeners
    shareProjectClose.addEventListener('click', hideShareProjectModal);
    cancelShareBtn.addEventListener('click', hideShareProjectModal);
    sendShareBtn.addEventListener('click', shareProject);

    // Update tag modal event listeners
    updateTagClose.addEventListener('click', hideUpdateTagModal);
    updateTagCancel.addEventListener('click', hideUpdateTagModal);
    updateTagSave.addEventListener('click', saveTagUpdates);
    addNewTagBtn.addEventListener('click', addNewTags);
    removeAllTagsBtn.addEventListener('click', removeAllTagsFromSelected);
    tagUpdateContinueBtn.addEventListener('click', hideTagUpdateSuccess);
    tagRemovalContinueBtn.addEventListener('click', hideTagRemovalNotification);

    // Delete image modal event listeners
    deleteImageClose.addEventListener('click', hideDeleteImageModal);
    cancelDeleteBtn.addEventListener('click', hideDeleteImageModal);
    confirmDeleteBtn.addEventListener('click', deleteSelectedImages);

    // Tag removal confirmation modal event listeners
    tagRemovalConfirmClose.addEventListener('click', hideTagRemovalConfirmModal);
    tagRemovalCancelBtn.addEventListener('click', hideTagRemovalConfirmModal);
    tagRemovalConfirmBtn.addEventListener('click', confirmTagRemoval);

    // Clear all confirmation modal event listeners
    clearAllConfirmClose.addEventListener('click', hideClearAllConfirmModal);
    clearAllCancelBtn.addEventListener('click', hideClearAllConfirmModal);
    clearAllConfirmBtn.addEventListener('click', confirmClearAll);

    // Add tag input enter key support
    newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            addNewTags();
        }
    });

    // Share email input enter key (only Enter, no ESC)
    shareEmailInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            shareProject();
        }
    });

    // Check authentication and load projects on startup
    checkAuthentication().then(isAuthenticated => {
        if (isAuthenticated) {
            loadProjectsFromAPI().then(() => {
                displayProjects();
            });
        }
    });


  </script>
</body>
</html>

