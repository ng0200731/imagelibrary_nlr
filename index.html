<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Library ‚Äî Minimal Shell v1.1.0</title>
  <link rel="stylesheet" href="styles.css?v=1.1.0&bust=20250910106000" />
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Main menu">
      <div class="brand">
        <div class="hamburger">
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
        </div>
        <span>Image Library</span>
      </div>
      <nav class="menu">
        <a id="nav-library" class="menu__item is-active" href="#">Image Library</a>
        <a id="nav-upload" class="menu__item" href="#">Upload Image</a>
        <a id="nav-project" class="menu__item" href="#">Project</a>
        <a id="nav-tags" class="menu__item" href="#">Tags</a>
        <a id="nav-admin" class="menu__item is-hidden" href="#">Admin Panel</a>
        <a id="nav-settings" class="menu__item" href="#" onclick="openSettings()">Settings</a>
      </nav>

      <div class="version-wrapper">
          <span class="version" id="app-version">v1.1.0</span>
      </div>

      <div class="sidebar__footer">
        <button id="nav-logout" class="button button--logout" type="button" onclick="logout()">üö™ Logout</button>
      </div>
    </aside>

    <main class="content">
      <!-- Image Library Page (Default) -->
      <div id="page-library" class="page">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <h1 class="title">Image Library</h1>
              <div class="legend" style="margin-top:8px;">Solid = Objective, Dashed = Subjective</div>
            </div>
            <div id="user-email-display" class="user-email-display"></div>
          </div>

          <!-- Broken Image Notification -->
          <div id="broken-image-notification" class="broken-image-notification hidden">
            <div class="notification-content">
              <span class="notification-icon">‚ö†Ô∏è</span>
              <span class="notification-text">
                <span id="broken-count">0</span> images could not be loaded.
                <span class="notification-reason">Backend server may not be running.</span>
              </span>
              <button id="dismiss-notification" class="notification-dismiss">‚úï</button>
            </div>
          </div>
          <div id="selection-controls" class="selection-controls is-hidden">
            <button id="select-all-btn" class="button" type="button">Select All</button>
            <button id="deselect-all-btn" class="button" type="button">Deselect All</button>
            <button id="view-pool-btn" class="button" type="button">View Selection Pool</button>
            <button id="back-to-library-btn" class="button is-hidden" type="button">Back to Library</button>
            <button id="add-to-project-btn" class="button button--primary" type="button">Add to Project</button>
            <span id="selection-count" class="selection-count">0 selected</span>
          </div>
        </header>
        <section class="panel">
          <div class="search-bar">
            <div class="search-input-row">
              <div class="autocomplete-container">
                <input type="text" id="library-search-input" placeholder="Type a tag and press Enter/Tab"
                       autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       spellcheck="false"
                       data-form-type="other">
                <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
              </div>
              <button id="clear-all-tags" class="button clear-tags-btn" type="button">Clear All</button>
            </div>
            <div id="library-search-chips" class="chips search-chips"></div>
            <button id="update-tag-btn" class="button update-tag-btn is-hidden" type="button">Update Tag</button>
            <button id="delete-image-btn" class="button delete-image-btn is-hidden" type="button">Delete Image</button>

          </div>
          <div id="library-grid" class="preview-grid"></div>
        </section>
      </div>

      <!-- Upload Image Page -->
      <div id="page-upload" class="page is-hidden">
          <header class="content__header">
            <div class="header-content-wrapper">
              <div class="header-left">
                <h1 class="title">Upload Images</h1>
              </div>
              <div id="user-email-display-upload" class="user-email-display"></div>
            </div>
          </header>
          <section class="panel">
            <div id="dropzone" class="upload-area">
              <div class="preview-header">
                <h2 class="panel__title">Selected Images</h2>
                <div class="upload-actions">
                  <input type="file" id="file-input" class="file-input" multiple />
                  <label for="file-input" class="button">Browse Files</label>
                  <button id="clear-all" class="button" type="button">Clear All</button>
                </div>
              </div>
              <p class="text">Browse, drag & drop, or paste images</p>
              <div id="preview-grid" class="preview-grid"></div>
            </div>
            <div class="upload-actions">
                <button id="upload-button" class="button button--primary" type="button">Upload</button>
            </div>
          </section>

          <!-- Layer 3: Tag panels -->
          <section class="panel">
            <div class="apply-scope">
              Apply to: <button id="apply-all" class="button" type="button">All images</button>
              <button id="apply-selected" class="button" type="button">Selected only</button>
              <span class="legend">Solid = Objective, Dashed = Subjective</span>
            </div>

            <div class="tag-panels">
              <div class="tag-panel tag-panel--objective">
                <div class="tag-panel__header is-objective" style="display: none;">
                  OBJECTIVE (FACTS)
                </div>
                <div class="tag-panel__body" style="padding-top: 8px;">
                  <div style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 8px;">
                    <button id="auto-fill-btn" class="button auto-fill-btn" type="button">Auto Fill</button>
                  </div>
                  <!-- Location Fields -->
                  <div class="metadata-section">
                    <h4>Location</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        book: <input id="obj-book" type="text" placeholder="Album-01" data-prefix="book:" />
                      </label>
                      <label class="tag-input">
                        page: <input id="obj-page" type="text" placeholder="15" data-prefix="page:" />
                      </label>
                      <label class="tag-input">
                        row: <input id="obj-row" type="text" placeholder="3" data-prefix="row:" />
                      </label>
                      <label class="tag-input">
                        column: <input id="obj-column" type="text" placeholder="2" data-prefix="column:" />
                      </label>
                    </div>
                  </div>

                  <!-- Item Details -->
                  <div class="metadata-section">
                    <h4>Item Details</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        type: <input id="obj-type" type="text" placeholder="stamp" data-prefix="type:" />
                      </label>
                      <label class="tag-input">
                        material: <input id="obj-material" type="text" placeholder="paper" data-prefix="material:" />
                      </label>
                      <label class="tag-input">
                        width (mm): <input id="obj-width" type="text" placeholder="25" class="dimension-field" data-prefix="width:" />
                      </label>
                      <label class="tag-input">
                        length (mm): <input id="obj-length" type="text" placeholder="30" class="dimension-field" data-prefix="length:" />
                      </label>
                    </div>
                  </div>

                  <!-- Remark -->
                  <div class="metadata-section">
                    <h4>Remark</h4>
                      <label class="tag-input">
                        remark: <input id="obj-remark" type="text" placeholder="excellent condition, rare find" data-prefix="remark:" />
                      </label>
                  </div>

                  <!-- Original Fields -->
                  <div class="metadata-section">
                    <h4>Additional Tags</h4>
                      <label class="tag-input">
                        brand: <input id="obj-brand" type="text" placeholder="nike" data-prefix="brand:" />
                      </label>
                      <label class="tag-input">
                        color: <input id="obj-color" type="text" placeholder="red" data-prefix="color:" />
                      </label>
                  </div>

                  <div id="obj-chips" class="chips"></div>
                </div>
              </div>

              <div class="tag-panel tag-panel--subjective">
                <div class="tag-panel__header is-subjective" style="display: none;">SUBJECTIVE (FEELINGS)</div>
                <div class="tag-panel__body" style="padding-top: 8px;">
                  <div class="subj-inline">
                    <!-- LEFT: original input + hint + chips (acts as one block) -->
                    <div>
                      <label class="tag-input">Add feelings:
                        <input id="subj-input" type="text" placeholder="type and press Enter/Tab" />
                      </label>
                      <div class="hint">Press Enter or Tab to add; Backspace removes last when empty</div>
                      <!-- Chips stay visually stuck to the input; do not affect right column height -->
                      <div id="subj-chips" class="chips"></div>
                    </div>
                    <!-- RIGHT: frequently used feelings (separate block, own height) -->
                    <div>
                      <div class="subj-freq-header">Frequently used</div>
                      <div id="subj-freq-list" class="subj-freq-list"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
      </div>

      <!-- Project Page -->
      <div id="page-project" class="page is-hidden">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <div class="project-header-row">
                <h1 class="title">Projects</h1>
                <div class="project-view-toggle">
                  <button id="project-view-toggle-btn" class="button is-small">
                    <span id="toggle-icon">üìã</span>
                    <span id="toggle-text">Detailed View</span>
                  </button>
                </div>
              </div>
            </div>
            <div class="header-right">
              <div id="user-email-display-project" class="user-email-display"></div>
            </div>
          </div>
        </header>
        <section class="panel">
          <!-- Project Search Bar -->
          <div class="project-search-bar">
            <input type="text" id="project-search-input" placeholder="Search project name..." autocomplete="off">
            <button id="project-filter-btn" class="button" type="button">Filter</button>
          </div>
          <div id="project-list" class="project-list">
            <p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>
          </div>
        </section>
      </div>

      <!-- Admin Panel Page -->
      <div id="page-admin" class="page is-hidden">
        <header class="content__header">
          <div class="header-content-wrapper">
            <div class="header-left">
              <h1 class="title">Admin Panel - User Management</h1>
            </div>
            <div class="header-right">
              <div id="user-email-display-admin" class="user-email-display"></div>
            </div>
          </div>
        </header>
        <section class="panel">
          <div id="admin-message" class="admin-message hidden"></div>
          
          <div class="users-section">
            <div class="section-header">
              User Access Management
            </div>
            
            <div id="admin-loading" class="admin-loading">
              Loading users...
            </div>
            
            <div id="admin-users-content" class="hidden">
              <table class="users-table">
                <thead>
                  <tr>
                    <th>Email</th>
                    <th>Status</th>
                    <th>Registration Date</th>
                    <th>Last Login</th>
                    <th>User Type</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="admin-users-tbody">
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </div>
    </main>
  </div>





  <!-- Lightbox Modal -->
  <div id="lightbox-modal" class="modal is-hidden">
    <span class="modal-close">&times;</span>
    <button id="lightbox-save-btn" class="lightbox-save-btn is-hidden" type="button">Save</button>
    <a class="prev">&#10094;</a>
    <div class="lightbox-content">
      <img class="modal-content" id="lightbox-image">
      <div id="lightbox-tags" class="lightbox-tags"></div>
    </div>
    <a class="next">&#10095;</a>
  </div>

      <!-- Confirmation Dialog -->
      <div id="confirm-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Upload Successful! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="upload-more-btn" class="button">Upload More</button>
            <button id="go-to-library-btn" class="button is-primary">Go to Library</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for Missing Feelings -->
      <div id="feelings-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please add at least one feeling in the "Add feelings" field before uploading.</p>
          <div class="modal-buttons">
            <button id="ok-feelings-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for No Images Selected -->
      <div id="no-images-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please select images to upload.</p>
          <div class="modal-buttons">
            <button id="ok-no-images-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>

      <!-- Warning Dialog for Missing Dimensions -->
      <div id="dimension-warning-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Please fill in at least one dimension field (width or length) before uploading.</p>
          <div class="modal-buttons">
            <button id="ok-dimension-btn" class="button is-primary">OK</button>
          </div>
        </div>
      </div>



      <!-- Loading Overlay -->
      <div id="loading-overlay" class="modal is-hidden">
        <div class="modal-content-text">
          Uploading... Please wait.
        </div>
      </div>

      <!-- Project Name Input Modal -->
      <div id="project-name-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <h3>Create New Project</h3>
          <p>Enter a name for your project:</p>
          <input type="text" id="project-name-input" placeholder="Project name..." maxlength="50">
          <div class="modal-buttons">
            <button id="cancel-project-btn" class="button">Cancel</button>
            <button id="create-project-btn" class="button is-primary">Create Project</button>
          </div>
        </div>
      </div>

      <!-- Project Created Confirmation Modal -->
      <div id="project-created-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p id="project-success-message">Project created successfully! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="add-more-projects-btn" class="button">Add More Projects</button>
            <button id="go-to-project-btn" class="button is-primary">Go to Project</button>
          </div>
        </div>
      </div>

      <!-- Image Preview Overlay -->
      <div id="image-preview-overlay" class="image-preview-overlay">
        <div class="image-preview-content">
          <img id="preview-overlay-img" src="" alt="Full Size Preview">
          <button id="preview-overlay-close" class="image-preview-close">‚úï</button>
          <button id="preview-overlay-settings" class="image-preview-settings hidden">‚öôÔ∏è</button>
          <div id="preview-dimension-info" class="preview-dimension-info hidden"></div>
        </div>
        <!-- Navigation arrows for Selection Pool -->
        <button id="preview-nav-left" class="image-preview-nav-arrow nav-left hidden">‚óÄ</button>
        <button id="preview-nav-right" class="image-preview-nav-arrow nav-right hidden">‚ñ∂</button>
      </div>

      <!-- Settings Modal within Overlay -->
      <div id="real-size-settings-modal" class="real-size-settings-modal is-hidden">
        <div class="real-size-settings-content">
          <div class="real-size-settings-header">
            <h3>Real Size Display Settings</h3>
            <button id="close-settings-modal" class="settings-close-btn">‚úï</button>
          </div>
          <div class="real-size-settings-body">
            <div class="settings-section">
              <label>Detected DPI:</label>
              <div id="detected-dpi-display" class="dpi-display"></div>
            </div>
            <div class="settings-section">
              <label for="manual-dpi-input">Manual DPI Override:</label>
              <input type="number" id="manual-dpi-input" placeholder="Auto-detect" min="72" max="300" step="1">
              <button id="apply-manual-dpi" class="settings-btn">Apply</button>
              <button id="reset-manual-dpi" class="settings-btn secondary">Reset</button>
            </div>
            <div class="settings-section">
              <button id="open-calibration-tool" class="settings-btn primary">Open Calibration Tool</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Calibration Tool Modal -->
      <div id="calibration-tool-modal" class="calibration-tool-modal is-hidden">
        <div class="calibration-tool-content">
          <div class="calibration-tool-header">
            <h3>DPI Calibration Tool</h3>
            <button id="close-calibration-modal" class="calibration-close-btn">‚úï</button>
          </div>
          <div class="calibration-tool-body">
            <div class="calibration-instructions">
              <p><strong>Instructions:</strong></p>
              <ol>
                <li>Place a credit card (85.6mm √ó 53.98mm) or a known-size object on your screen</li>
                <li>Adjust the DPI slider until the displayed size matches the real object</li>
                <li>Click "Save Calibrated DPI" to apply</li>
              </ol>
            </div>
            <div class="calibration-preview">
              <div class="calibration-object" id="calibration-object">
                <div class="calibration-label">Credit Card<br>85.6mm √ó 53.98mm</div>
              </div>
            </div>
            <div class="calibration-controls">
              <label for="calibration-dpi-slider">DPI: <span id="calibration-dpi-value">96</span></label>
              <input type="range" id="calibration-dpi-slider" min="72" max="300" value="96" step="1">
              <div class="calibration-buttons">
                <button id="save-calibrated-dpi" class="settings-btn primary">Save Calibrated DPI</button>
                <button id="cancel-calibration" class="settings-btn secondary">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Project Detail Overlay Modal -->
      <div id="project-detail-modal" class="project-detail-overlay is-hidden">
        <div class="project-detail-content">
          <!-- Project Header (20%) -->
          <div class="project-detail-header">
            <div class="project-info-section">
              <div class="project-title-row">
                <h2 id="project-detail-name">üìÅ Project Name</h2>
                <button id="close-project-detail" class="modal-close-btn">‚úï Close</button>
              </div>
              <div class="project-stats-row">
                <span id="project-detail-date">üìÖ Created: 2024-01-15</span>
                <span id="project-detail-count">üìä Total Images: 12</span>
                <span id="project-detail-owner" style="display: none;">üë§ Created by: </span>
              </div>
              <div class="project-tags-row">
                <span id="project-detail-tags">üè∑Ô∏è Tags: beach, sunset, family</span>
              </div>
            </div>
          </div>

          <!-- Project Image Grid (80%) -->
          <div class="project-detail-grid-container">
            <div id="project-detail-grid" class="project-detail-grid">
              <!-- Project images will be loaded here -->
            </div>
          </div>
        </div>
      </div>

      <!-- Share Project Modal -->
      <div id="share-project-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Share Project</h2>
            <button id="share-project-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Share "<span id="share-project-name"></span>" via email</p>
            <div class="form-group">
              <label for="share-email-input">Recipient Email Address:</label>
              <input type="email" id="share-email-input" placeholder="Enter email address..." required>
            </div>
            <div class="form-group">
              <label for="share-message-input">Optional Message:</label>
              <textarea id="share-message-input" placeholder="Add a personal message (optional)..." rows="3"></textarea>
            </div>
          </div>
          <div class="modal-footer">
            <button id="cancel-share-btn" class="button">Cancel</button>
            <button id="send-share-btn" class="button button-primary">Send Email</button>
          </div>
        </div>
      </div>

      <!-- Email Sending Overlay -->
      <div id="email-sending-overlay" class="email-overlay is-hidden">
        <div class="email-overlay-content">
          <div class="email-spinner"></div>
          <h3>Sending Email...</h3>
          <p>Please wait while we prepare and send your project email.</p>
          <div class="email-progress">
            <div class="email-progress-bar"></div>
          </div>
        </div>
      </div>

      <!-- Update Tag Modal -->
      <div id="update-tag-modal" class="modal-overlay is-hidden">
        <div class="modal-content update-tag-modal-content">
          <div class="modal-header">
            <h2>Update Tags</h2>
            <button id="update-tag-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body update-tag-body">
            <div class="tag-columns">
              <div class="tag-column">
                <h3>Original Tags</h3>
                <div id="original-tags-list" class="tags-list">
                  <!-- Original tags will be populated here -->
                </div>
                <div class="tag-actions-section">
                  <button id="remove-all-tags-btn" class="button remove-all-btn">Remove All Tags</button>
                </div>
              </div>
              <div class="tag-column">
                <h3>New Tags</h3>
                <div id="new-tags-list" class="tags-list">
                  <!-- New tags will be populated here -->
                </div>
                <div class="tag-input-section">
                  <input type="text" id="new-tag-input" placeholder="Add new tags (comma-separated)..." />
                  <button id="add-new-tag-btn" class="button">Add</button>
                </div>
                <div id="tag-warning" class="tag-warning is-hidden">Please enter a tag</div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button id="update-tag-cancel" class="button">Cancel</button>
            <button id="update-tag-save" class="button button-primary">Save</button>
          </div>
        </div>
      </div>

      <!-- Tag Update Success Modal -->
      <div id="tag-update-success-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Tags updated successfully!</p>
          <div class="modal-buttons">
            <button id="tag-update-continue-btn" class="button is-primary">Continue</button>
          </div>
        </div>
      </div>

      <!-- Tag Removal Notification Modal -->
      <div id="tag-removal-notification-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p id="tag-removal-message">Tag removed and images deselected!</p>
          <div class="modal-buttons">
            <button id="tag-removal-continue-btn" class="button is-primary">Continue</button>
          </div>
        </div>
      </div>

      <!-- Delete Image Confirmation Modal -->
      <div id="delete-image-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Delete Images</h2>
            <button id="delete-image-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to delete <span id="delete-count">0</span> selected image(s)?</p>
            <p class="warning-text">This action cannot be undone. Images will be permanently removed from the database and file system.</p>
          </div>
          <div class="modal-footer">
            <button id="cancel-delete-btn" class="button">Cancel</button>
            <button id="confirm-delete-btn" class="button button--danger">Delete Images</button>
          </div>
        </div>
      </div>

      <!-- Tag Removal Confirmation Modal -->
      <div id="tag-removal-confirm-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Remove Tag from Selection Pool</h2>
            <button id="tag-removal-confirm-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Do you want to remove all images with the "<span id="tag-removal-tag-name"></span>" tag from the selection pool?</p>
            <p class="warning-text">This will remove <span id="tag-removal-image-count">0</span> image(s) from your current selection.</p>
          </div>
          <div class="modal-footer">
            <button id="tag-removal-cancel-btn" class="button">No, Keep Images</button>
            <button id="tag-removal-confirm-btn" class="button button--danger">Yes, Remove Images</button>
          </div>
        </div>
      </div>

      <!-- Tag Delete Confirm Modal (lightbox single-tag removal) -->
      <div id="tag-delete-confirm-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Remove tag "<span id="tag-delete-name"></span>" from this image?</p>
          <div class="modal-buttons">
            <button id="tag-delete-cancel-btn" class="button">Cancel</button>
            <button id="tag-delete-confirm-btn" class="button is-primary button--danger">Remove Tag</button>
          </div>
        </div>
      </div>

      <!-- Clear All Confirmation Modal -->
      <div id="clear-all-confirm-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Clear All Selections</h2>
            <button id="clear-all-confirm-close" class="modal-close-btn">‚úï</button>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to clear all selections and search filters?</p>
            <p class="warning-text">This will remove <span id="clear-all-selection-count">0</span> selected image(s) and <span id="clear-all-tag-count">0</span> search tag(s).</p>
          </div>
          <div class="modal-footer">
            <button id="clear-all-cancel-btn" class="button">Cancel</button>
            <button id="clear-all-confirm-btn" class="button button--danger">Clear All</button>
          </div>
        </div>
      </div>

  <script>
    // --- Constants & State ---
    // Application Version - Increment for each update
    const APP_VERSION = '1.1.0';
    
    // Helper function to extract email prefix (part before "@")
    function getEmailPrefix(email) {
        if (!email) return '';
        const atIndex = email.indexOf('@');
        return atIndex > 0 ? email.substring(0, atIndex) : email;
    }

    // --- DPI Detection & Real Size Display ---
    let detectedDPI = null;
    let manualDPI = null;
    let calibratedDPI = null;

    // Auto-detect DPI
    function detectDPI() {
        // Try to get DPI from localStorage first (calibrated or manual)
        const savedDPI = localStorage.getItem('calibratedDPI') || localStorage.getItem('manualDPI');
        if (savedDPI) {
            return parseFloat(savedDPI);
        }

        // Auto-detect using screen dimensions
        // Formula: DPI = (screen width in pixels) / (screen width in inches)
        // We'll use a standard approach: window.devicePixelRatio * 96
        const devicePixelRatio = window.devicePixelRatio || 1;
        const baseDPI = 96;
        const calculatedDPI = devicePixelRatio * baseDPI;

        // Store detected DPI
        detectedDPI = calculatedDPI;
        return calculatedDPI;
    }

    // Get current DPI (prioritizes calibrated > manual > detected)
    function getCurrentDPI() {
        if (calibratedDPI) return calibratedDPI;
        if (manualDPI) return manualDPI;
        if (detectedDPI) return detectedDPI;
        return detectDPI();
    }

    // Convert mm to pixels based on DPI
    function mmToPixels(mm, dpi = null) {
        if (!mm || isNaN(mm)) return null;
        const currentDPI = dpi || getCurrentDPI();
        // 1 inch = 25.4mm, so pixels = (mm * DPI) / 25.4
        return (parseFloat(mm) * currentDPI) / 25.4;
    }

    // Load saved DPI values from localStorage
    const savedCalibratedDPI = localStorage.getItem('calibratedDPI');
    const savedManualDPI = localStorage.getItem('manualDPI');
    if (savedCalibratedDPI) {
        calibratedDPI = parseFloat(savedCalibratedDPI);
    }
    if (savedManualDPI) {
        manualDPI = parseFloat(savedManualDPI);
    }

    // Initialize DPI on page load
    detectedDPI = detectDPI();
    
    // Update version display dynamically
    const versionElement = document.getElementById('app-version');
    if (versionElement) {
        versionElement.textContent = `v${APP_VERSION}`;
    }
    // Update page title
    document.title = `Image Library ‚Äî Minimal Shell v${APP_VERSION}`;

    // Backend API base URL
    // If frontend is served on :8080 (static server), point API to :3000 on same host.
    // Otherwise use current origin.
    const API_URL = (window.location.origin.includes(':8080'))
        ? window.location.origin.replace(':8080', ':3000')
        : window.location.origin;
    const navLinks = {
        library: document.getElementById('nav-library'),
        upload: document.getElementById('nav-upload'),
        project: document.getElementById('nav-project'),
        admin: document.getElementById('nav-admin'),
    };

    // Broken image tracking
    let brokenImages = [];
    let brokenImageNotificationShown = false;
    let brokenImageNotificationDismissed = localStorage.getItem('brokenImageNotificationDismissed') === 'true';

    // Broken image functions
    function trackBrokenImage(imageId, imageSrc) {
        if (!brokenImages.find(img => img.id === imageId)) {
            brokenImages.push({ id: imageId, src: imageSrc });
            updateBrokenImageNotification();
        }
    }

    function updateBrokenImageNotification() {
        const notification = document.getElementById('broken-image-notification');
        const countElement = document.getElementById('broken-count');

        // Only show notification if user hasn't dismissed it permanently
        if (brokenImages.length > 0 && !brokenImageNotificationDismissed) {
            countElement.textContent = brokenImages.length;
            notification.classList.remove('hidden');

            // Log broken images for debugging
            console.warn(`${brokenImages.length} images failed to load:`, brokenImages);
        } else {
            notification.classList.add('hidden');
        }
    }

    function clearBrokenImageTracking() {
        brokenImages = [];
        updateBrokenImageNotification();
    }

    // Function to reset notification dismissal (for development/testing)
    function resetBrokenImageNotificationDismissal() {
        brokenImageNotificationDismissed = false;
        localStorage.removeItem('brokenImageNotificationDismissed');
        updateBrokenImageNotification();
        console.log('Broken image notification dismissal reset - notifications will show again');
    }
    const pages = {
        library: document.getElementById('page-library'),
        upload: document.getElementById('page-upload'),
        project: document.getElementById('page-project'),
        admin: document.getElementById('page-admin'),
    };
    const fileInput = document.getElementById('file-input');
    const previewGrid = document.getElementById('preview-grid');
    const clearAllButton = document.getElementById('clear-all');
    const dropzone = document.getElementById('dropzone');
    const subjInput = document.getElementById('subj-input');
    const subjChips = document.getElementById('subj-chips');
    const subjFreqList = document.getElementById('subj-freq-list');

    // Track frequency of subjective (feeling) tags in-memory
    const subjFreqMap = {};
    let subjToastTimeout = null;

    // Objective metadata inputs
    const objBookInput = document.getElementById('obj-book');
    const objPageInput = document.getElementById('obj-page');
    const objRowInput = document.getElementById('obj-row');
    const objColumnInput = document.getElementById('obj-column');
    const objTypeInput = document.getElementById('obj-type');
    const objMaterialInput = document.getElementById('obj-material');
    const objWidthInput = document.getElementById('obj-width');
    const objLengthInput = document.getElementById('obj-length');
    const objRemarkInput = document.getElementById('obj-remark');
    const objBrandInput = document.getElementById('obj-brand');
    const objColorInput = document.getElementById('obj-color');
    const objChips = document.getElementById('obj-chips');
    const autoFillBtn = document.getElementById('auto-fill-btn');
    const modal = document.getElementById('lightbox-modal');
    const modalImg = document.getElementById('lightbox-image');
    const lightboxTags = document.getElementById('lightbox-tags');
    const closeModal = document.querySelector('.modal-close');
    const prevButton = document.querySelector('.prev');
    const nextButton = document.querySelector('.next');
    const lightboxSaveBtn = document.getElementById('lightbox-save-btn');
    const uploadButton = document.getElementById('upload-button');
    const librarySearchInput = document.getElementById('library-search-input');
    const libraryGrid = document.getElementById('library-grid');
    
    // Pagination state
    let currentPage = 0;
    let imagesPerRow = 0;
    let allImagesToDisplay = []; // Store all images for pagination
    const ROWS_PER_PAGE = 3;
    const librarySearchChips = document.getElementById('library-search-chips');
    const autocompleteDropdown = document.getElementById('autocomplete-dropdown');

    // Header title element for dynamic updates
    const libraryTitle = document.querySelector('#page-library .title');
    const clearAllTagsBtn = document.getElementById('clear-all-tags');
    // Removed searchModeRadios - using default OR mode

    // Selection and project elements
    const selectionControls = document.getElementById('selection-controls');
    const selectAllBtn = document.getElementById('select-all-btn');
    const deselectAllBtn = document.getElementById('deselect-all-btn');
    const updateTagBtn = document.getElementById('update-tag-btn');
    const deleteImageBtn = document.getElementById('delete-image-btn');
    const viewPoolBtn = document.getElementById('view-pool-btn');
    const backToLibraryBtn = document.getElementById('back-to-library-btn');
    const addToProjectBtn = document.getElementById('add-to-project-btn');
    const selectionCount = document.getElementById('selection-count');
    const projectNameModal = document.getElementById('project-name-modal');
    const projectNameInput = document.getElementById('project-name-input');
    const cancelProjectBtn = document.getElementById('cancel-project-btn');
    const createProjectBtn = document.getElementById('create-project-btn');
    const projectList = document.getElementById('project-list');

    // Project created confirmation modal elements
    const projectCreatedModal = document.getElementById('project-created-modal');
    const projectSuccessMessage = document.getElementById('project-success-message');
    const addMoreProjectsBtn = document.getElementById('add-more-projects-btn');
    const goToProjectBtn = document.getElementById('go-to-project-btn');

    // Project search elements
    const projectSearchInput = document.getElementById('project-search-input');
    const projectFilterBtn = document.getElementById('project-filter-btn');

    // Project view toggle elements
    const projectViewToggleBtn = document.getElementById('project-view-toggle-btn');
    const toggleIcon = document.getElementById('toggle-icon');
    const toggleText = document.getElementById('toggle-text');

    // Project detail overlay elements
    const projectDetailModal = document.getElementById('project-detail-modal');
    const closeProjectDetailBtn = document.getElementById('close-project-detail');
    const projectDetailName = document.getElementById('project-detail-name');
    const projectDetailDate = document.getElementById('project-detail-date');
    const projectDetailCount = document.getElementById('project-detail-count');
    const projectDetailOwner = document.getElementById('project-detail-owner');
    const projectDetailTags = document.getElementById('project-detail-tags');
    const projectDetailGrid = document.getElementById('project-detail-grid');

    // Share project modal elements
    const shareProjectModal = document.getElementById('share-project-modal');
    const shareProjectClose = document.getElementById('share-project-close');
    const shareProjectName = document.getElementById('share-project-name');
    const shareEmailInput = document.getElementById('share-email-input');
    const shareMessageInput = document.getElementById('share-message-input');
    const cancelShareBtn = document.getElementById('cancel-share-btn');
    const sendShareBtn = document.getElementById('send-share-btn');
    const emailSendingOverlay = document.getElementById('email-sending-overlay');

    // Update tag modal elements
    const updateTagModal = document.getElementById('update-tag-modal');
    const updateTagClose = document.getElementById('update-tag-close');
    const originalTagsList = document.getElementById('original-tags-list');
    const newTagsList = document.getElementById('new-tags-list');
    const newTagInput = document.getElementById('new-tag-input');
    const addNewTagBtn = document.getElementById('add-new-tag-btn');
    const removeAllTagsBtn = document.getElementById('remove-all-tags-btn');
    const tagWarning = document.getElementById('tag-warning');
    const updateTagCancel = document.getElementById('update-tag-cancel');
    const updateTagSave = document.getElementById('update-tag-save');

    // Delete image modal elements
    const deleteImageModal = document.getElementById('delete-image-modal');
    const deleteImageClose = document.getElementById('delete-image-close');
    const deleteCount = document.getElementById('delete-count');
    const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
    const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
    const tagUpdateSuccessModal = document.getElementById('tag-update-success-modal');
    const tagUpdateContinueBtn = document.getElementById('tag-update-continue-btn');
    const tagRemovalNotificationModal = document.getElementById('tag-removal-notification-modal');
    const tagRemovalMessage = document.getElementById('tag-removal-message');
    const tagRemovalContinueBtn = document.getElementById('tag-removal-continue-btn');

    // Tag removal confirmation modal elements
    const tagRemovalConfirmModal = document.getElementById('tag-removal-confirm-modal');
    const tagRemovalConfirmClose = document.getElementById('tag-removal-confirm-close');
    const tagRemovalTagName = document.getElementById('tag-removal-tag-name');
    const tagRemovalImageCount = document.getElementById('tag-removal-image-count');
    const tagRemovalCancelBtn = document.getElementById('tag-removal-cancel-btn');
    const tagRemovalConfirmBtn = document.getElementById('tag-removal-confirm-btn');
    const tagDeleteConfirmModal = document.getElementById('tag-delete-confirm-modal');
    const tagDeleteName = document.getElementById('tag-delete-name');
    const tagDeleteCancelBtn = document.getElementById('tag-delete-cancel-btn');
    const tagDeleteConfirmBtn = document.getElementById('tag-delete-confirm-btn');
    let pendingTagDelete = null;

    // Clear all confirmation modal elements
    const clearAllConfirmModal = document.getElementById('clear-all-confirm-modal');
    const clearAllConfirmClose = document.getElementById('clear-all-confirm-close');
    const clearAllSelectionCount = document.getElementById('clear-all-selection-count');
    const clearAllTagCount = document.getElementById('clear-all-tag-count');
    const clearAllCancelBtn = document.getElementById('clear-all-cancel-btn');
    const clearAllConfirmBtn = document.getElementById('clear-all-confirm-btn');

    // Image preview overlay elements
    const imagePreviewOverlay = document.getElementById('image-preview-overlay');
    const previewOverlayImg = document.getElementById('preview-overlay-img');
    const previewOverlayClose = document.getElementById('preview-overlay-close');
    const previewNavLeft = document.getElementById('preview-nav-left');
    const previewNavRight = document.getElementById('preview-nav-right');

    let filesToUpload = [];
    let currentImageIndex = 0;
    let imageSources = [];
    let libraryImages = []; // Store current library images for lightbox navigation
    let searchTags = []; // Store current search tags as chips
    let searchTagColors = {}; // Map tag text -> highlight color
    let usedSearchColors = new Set(); // Track used colors to avoid repeats
    let selectedImages = []; // Store selected image IDs for project creation
    let tagSelectedImages = []; // Store images selected by tags (always show tag icon)
    let imageSelectionSource = {}; // Track how each image was selected: 'manual' or search tag name

    // Update tag modal state
    let tagsToRemove = new Set(); // Track individual tags marked for removal
    let removeAllTags = false; // Track if "Remove All Tags" was clicked
    let tagsToAdd = new Set(); // Track new tags to be added
    let imageSelectionOrder = {}; // Track selection timestamps for ordering
    let tagCreationOrder = {}; // Track when each tag was first created/used
    let projects = []; // Store created projects
    let isPoolView = false; // Track if we're viewing selection pool
    let forceLibraryView = false; // Flag to prevent auto-switching to pool view
    let lastCreatedProject = null; // Store the last created project for navigation
    let isDetailedProjectView = false; // Track if we're in detailed project view mode
    let autocompleteVisible = false; // Track if autocomplete dropdown is visible
    let autocompleteHighlightIndex = -1; // Track highlighted item in autocomplete
    let autocompleteItems = []; // Store current autocomplete suggestions
    let currentUser = null; // Store current logged-in user

    // Selection Pool preview navigation
    let currentPreviewImages = []; // Array of images for navigation
    let currentPreviewIndex = 0; // Current image index in preview
    let isSelectionPoolPreview = false; // Track if we're in Selection Pool preview mode
    let pendingAddTags = new Set(); // Track tags added in lightbox before saving
    let lightboxDirty = false; // Track if any tag was added or removed in lightbox

    // --- Function Definitions ---

    function groupImagesByTagsAndSort(images) {
        console.log('=== groupImagesByTagsAndSort START ===');
        console.log('Input images:', images.map(img => `${img.id}: [${img.tags?.join(',') || 'untagged'}] uploaded: ${img.uploadTime}`));
        console.log('Tag creation order:', tagCreationOrder);


        // Create groups by tag based on current search chips:
        // when chips are "#3 star", "#2 white", "#1 pink",
        // images should be grouped: all "star", then "white", then "pink".
        const result = [];

        // Prefer current chip DOM order (left ‚Üí right) for grouping, so it always matches
        // what the user sees: "#3 star", "#2 white", "#1 pink" ‚Üí [star, white, pink].
        let allInputTags = [];
        const chipContainer = document.getElementById('library-search-chips');
        if (chipContainer) {
            const chipNodes = Array.from(chipContainer.querySelectorAll('.search-chip'));
            allInputTags = chipNodes
                .map(chip => (chip.dataset.tag || '').toLowerCase())
                .filter(tag => tag);
        }

        // Fallback if no chips are present: use historical input order from tagCreationOrder (oldest first)
        if (allInputTags.length === 0) {
            allInputTags = Object.keys(tagCreationOrder).sort((a, b) => {
                const timestampA = tagCreationOrder[a] || 0;
                const timestampB = tagCreationOrder[b] || 0;
                return timestampA - timestampB;
            });
        }

        console.log('All input tags in reverse chronological order (latest input first):', allInputTags.map(tag => `${tag}: ${tagCreationOrder[tag]}`));

        // Track which images we've already added to prevent duplicates
        const addedImageIds = new Set();

        // For each tag (in the desired order), add ALL images that have this tag
        allInputTags.forEach(tag => {
            const normalizedTag = tag.toLowerCase();
            const imagesWithThisTag = images.filter(image => {
                const imageTags = image.tags || [];
                return imageTags.some(t => t.toLowerCase() === normalizedTag);
            });

            // Sort images within this tag group by upload time (earliest first)
            imagesWithThisTag.sort((a, b) => {
                const uploadTimeA = a.uploadTime || 0;
                const uploadTimeB = b.uploadTime || 0;
                return uploadTimeA - uploadTimeB; // Earliest upload first
            });

            console.log(`Tag "${tag}" images:`, imagesWithThisTag.map(img =>
                `${img.id} (uploaded: ${img.uploadTime})`
            ));

            // Add these images to result (preventing duplicates across tag groups)
            imagesWithThisTag.forEach(image => {
                if (!addedImageIds.has(image.id)) {
                    result.push(image);
                    addedImageIds.add(image.id);
                }
            });
        });

        // Add ALL manually selected images that haven't been added yet (preserve manual selections)
        const manuallySelectedImages = images.filter(image => {
            const isManuallySelected = selectedImages.includes(image.id) && !tagSelectedImages.includes(image.id);
            return isManuallySelected && !addedImageIds.has(image.id);
        });

        console.log('Manually selected images not yet added:', manuallySelectedImages.map(img => `${img.id} (manual selection, tags: [${img.tags?.join(',') || 'untagged'}])`));

        // Add manually selected images at the end (preventing duplicates)
        manuallySelectedImages.forEach(image => {
            if (!addedImageIds.has(image.id)) {
                result.push(image);
                addedImageIds.add(image.id);
            }
        });

        // Add ALL tag-selected images that haven't been added yet
        const tagSelectedOnlyImages = images.filter(image => {
            const isTagSelected = tagSelectedImages.includes(image.id);
            return isTagSelected && !addedImageIds.has(image.id);
        });

        tagSelectedOnlyImages.forEach(image => {
            if (!addedImageIds.has(image.id)) {
                result.push(image);
                addedImageIds.add(image.id);
            }
        });

        console.log('Final sequence (with untagged manual selections):', result.map(img =>
            `${img.id}: [${img.tags?.join(',') || 'untagged'}] uploaded: ${img.uploadTime}`
        ));
        console.log('=== groupImagesByTagsAndSort END ===');

        // Show missing images in alert
        const missingImages = images.filter(img => !result.find(r => r.id === img.id));
        if (missingImages.length > 0) {
            alert('MISSING IMAGES FOUND:\n' +
                  'Input: ' + images.length + ' images\n' +
                  'Output: ' + result.length + ' images\n' +
                  'Missing IDs: ' + missingImages.map(img => img.id).join(', ') + '\n' +
                  'Missing tags: ' + JSON.stringify(missingImages.map(img => ({id: img.id, tags: img.tags})), null, 2));
        }

        return result;
    }

    function addTagGroupHeaders(images) {
        // Track which tags we've already added headers for
        const addedTagHeaders = new Set();
        const tagGroups = new Map();

        // Group images by ALL their tags (not just first tag)
        images.forEach(image => {
            const imageTags = image.tags || [];
            imageTags.forEach(tag => {
                if (!tagGroups.has(tag)) {
                    tagGroups.set(tag, []);
                }
                tagGroups.get(tag).push(image);
            });
        });

        // Add headers based on current search tags and all input tags
        const currentSearchTags = searchTags.map(tag => tag.text);

        // In pool view, show ALL search tags (green chips) that are currently active
        // In library view with search, show only matching tags
        const tagsToShow = isPoolView ? currentSearchTags :
                          currentSearchTags.length > 0 ? currentSearchTags :
                          Object.keys(tagCreationOrder).sort((a, b) => {
                              const timestampA = tagCreationOrder[a] || 0;
                              const timestampB = tagCreationOrder[b] || 0;
                              return timestampB - timestampA; // Latest tag first
                          });

        // Create a container for tag headers (button-style)
        const tagHeaderContainer = document.createElement('div');
        tagHeaderContainer.className = 'tag-headers-container';

        // Add headers for each tag that has images, showing all current search tags in pool view
        tagsToShow.forEach(tag => {
            // Skip the "car" tag to remove its header
            if (tag === 'car') {
                return;
            }

            const imagesWithThisTag = images.filter(image => {
                const imageTags = image.tags || [];
                return imageTags.includes(tag);
            });

            if (imagesWithThisTag.length > 0 && !addedTagHeaders.has(tag)) {
                const tagHeader = document.createElement('span');
                tagHeader.className = 'tag-group-header';
                tagHeader.textContent = `${tag} (${imagesWithThisTag.length})`;
                tagHeaderContainer.appendChild(tagHeader);
                addedTagHeaders.add(tag);
            }
        });

        // Add header for untagged images if any exist
        const untaggedImages = images.filter(image => {
            const imageTags = image.tags || [];
            return imageTags.length === 0;
        });

        if (untaggedImages.length > 0 && !addedTagHeaders.has('Untagged')) {
            const tagHeader = document.createElement('span');
            tagHeader.className = 'tag-group-header';
            tagHeader.textContent = 'Untagged Images';
            tagHeaderContainer.appendChild(tagHeader);
            addedTagHeaders.add('Untagged');
        }

        // Only add the container if it has headers
        if (tagHeaderContainer.children.length > 0) {
            libraryGrid.appendChild(tagHeaderContainer);
        }
    }

    function updateLibraryTitle(isPoolView = false) {
        if (isPoolView) {
            libraryTitle.textContent = 'Image Library (Selection Pool)';
        } else {
            libraryTitle.textContent = 'Image Library';
        }
    }

    function updateSearchInputVisibility() {
        const searchInput = document.getElementById('library-search-input');
        const clearAllBtn = document.getElementById('clear-all-tags');
        const libraryTitle = document.querySelector('#page-library .title');

        // Check if we're in Selection Pool view by multiple criteria
        const isSelectionPool = libraryTitle && libraryTitle.textContent.includes('Selection Pool');
        const hasTagSearch = searchTags.length > 0;
        const hasSelectedImages = selectedImages.length > 0;

        console.log('updateSearchInputVisibility - isPoolView:', isPoolView, 'isSelectionPool:', isSelectionPool, 'hasTagSearch:', hasTagSearch, 'hasSelectedImages:', hasSelectedImages);

        // Only disable search controls when explicitly in Selection Pool view
        if (isPoolView || isSelectionPool) {
            // DISABLE search input and clear button in Selection Pool view
            searchInput.disabled = true;
            clearAllBtn.disabled = true;

            // Add visual styling for disabled state
            searchInput.style.opacity = '0.5';
            searchInput.style.cursor = 'not-allowed';
            clearAllBtn.style.opacity = '0.5';
            clearAllBtn.style.cursor = 'not-allowed';

            console.log('Search input/clear DISABLED for Selection Pool view');
        } else {
            // ENABLE search controls in regular Library view
            searchInput.disabled = false;
            clearAllBtn.disabled = false;

            // Remove visual styling for disabled state
            searchInput.style.opacity = '1';
            searchInput.style.cursor = 'text';
            clearAllBtn.style.opacity = '1';
            clearAllBtn.style.cursor = 'pointer';

            console.log('Search controls ENABLED for regular Library view');
        }
    }

    // Calculate how many images fit per row based on grid width
    function calculateImagesPerRow() {
        if (!libraryGrid || libraryGrid.offsetWidth === 0) {
            // Fallback: estimate based on 150px card width + 8px gap
            imagesPerRow = Math.floor((window.innerWidth * 0.88) / 158); // 88% of viewport width
            return;
        }
        const gridWidth = libraryGrid.offsetWidth;
        const cardWidth = 150; // From CSS: grid-template-columns: repeat(auto-fill, 150px)
        const gap = 8; // From CSS: gap: 8px
        imagesPerRow = Math.floor((gridWidth + gap) / (cardWidth + gap));
        if (imagesPerRow < 1) imagesPerRow = 1; // Minimum 1 image per row
    }

    // Show loading skeleton cards
    function showLoadingSkeletons() {
        const skeletonCount = imagesPerRow * ROWS_PER_PAGE;
        for (let i = 0; i < skeletonCount; i++) {
            const skeleton = document.createElement('div');
            skeleton.className = 'preview-card library-card skeleton-card';
            skeleton.innerHTML = '<div class="skeleton-shimmer"></div>';
            libraryGrid.appendChild(skeleton);
        }
    }

    // Create an image card (normal or greyscale indicator)
    function createImageCard(image, index, imageSrc, currentSearchTags, isGreyscaleIndicator = false) {
        const card = document.createElement('div');
        card.className = 'preview-card library-card';
        card.dataset.imageId = image.id;
        
        if (isGreyscaleIndicator) {
            card.classList.add('greyscale-indicator');
        }

        const img = document.createElement('img');
        img.src = imageSrc;
        
        if (isGreyscaleIndicator) {
            // Greyscale images are non-clickable visual indicators
            img.style.filter = 'grayscale(100%)';
            img.style.opacity = '0.6';
            img.style.pointerEvents = 'none';
            card.style.pointerEvents = 'none';
            card.style.cursor = 'default';
        } else {
            // Normal images are clickable
            img.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Image clicked:', image.id, 'isPoolView:', isPoolView, 'index:', index);
                toggleImageSelection(image.id, card);
            });
            img.style.cursor = 'pointer';
            if (isPoolView) {
                card.style.cursor = 'pointer';
            }
        }

        card.appendChild(img);
        
        // Add "chosen" overlay text for greyscale indicators (after image so it appears on top)
        if (isGreyscaleIndicator) {
            const chosenOverlay = document.createElement('div');
            chosenOverlay.className = 'chosen-overlay';
            chosenOverlay.textContent = 'chosen';
            card.appendChild(chosenOverlay);
        }

        // Add hover tooltip for width/length dimensions
        if (image.width || image.length) {
            const dimensionTooltip = document.createElement('div');
            dimensionTooltip.className = 'dimension-tooltip';
            const widthText = image.width ? `Width: ${image.width}` : '';
            const lengthText = image.length ? `Length: ${image.length}` : '';
            const separator = (widthText && lengthText) ? ' | ' : '';
            dimensionTooltip.textContent = widthText + separator + lengthText;
            card.appendChild(dimensionTooltip);
        }

        // Add eye icon and ruler icon for image preview (only for non-greyscale images)
        if (!isGreyscaleIndicator) {
            // 1:1 icon (original pixel size)
            const eyeIcon = document.createElement('div');
            eyeIcon.className = 'image-preview-eye';
            eyeIcon.textContent = '1:1';
            eyeIcon.title = 'Preview full size image';

            eyeIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                const libraryTitle = document.querySelector('#page-library .title');
                const isSelectionPoolView = isPoolView || (libraryTitle && libraryTitle.textContent.includes('Selection Pool'));

                console.log('Lens clicked - isPoolView:', isPoolView, 'isSelectionPoolView:', isSelectionPoolView);

                if (isSelectionPoolView) {
                    console.log('Opening Selection Pool preview for image:', image.id, 'at index:', index);
                    showSelectionPoolPreview(image, allImagesToDisplay, index);
                } else {
                    console.log('Opening regular library preview for image:', image.id);
                    showImagePreviewOverlay(imageSrc, image);
                }
            });

            card.appendChild(eyeIcon);

            // Ruler icon (real size based on mm dimensions)
            if (image.width || image.length) {
                const rulerIcon = document.createElement('div');
                rulerIcon.className = 'image-preview-ruler';
                rulerIcon.innerHTML = 'üìè';
                rulerIcon.title = 'Preview real size (1:1 based on dimensions)';

                rulerIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Ruler clicked - showing real size for image:', image.id);
                    showRealSizeOverlay(imageSrc, image);
                });

                card.appendChild(rulerIcon);
            }
        }

        // Add booklet icon for lightbox preview (only in Selection Pool view and non-greyscale)
        if (isPoolView && !isGreyscaleIndicator) {
            const bookletIcon = document.createElement('div');
            bookletIcon.className = 'image-preview-booklet';
            bookletIcon.textContent = 'üìñ';
            bookletIcon.title = 'Open lightbox with navigation';

            bookletIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Booklet clicked, opening lightbox for index:', index);
                openLibraryLightbox(index);
            });

            card.appendChild(bookletIcon);
        }

        // Add tag overlay - show only subjective tags (exclude objective metadata like width/length)
        const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
        const isTagSelected = tagSelectedImages.includes(image.id);
        const allImageTags = image.tags || [];
        
        // Filter out objective metadata tags (width, length, book, page, row, column, type, material, remark, brand, color)
        const objectivePrefixes = ['width:', 'length:', 'book:', 'page:', 'row:', 'column:', 'type:', 'material:', 'remark:', 'brand:', 'color:'];
        const subjectiveTags = allImageTags.filter(tag => {
            const tagLower = tag.toLowerCase();
            return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
        });

        if (subjectiveTags.length > 0) {
            const tagOverlay = document.createElement('div');
            tagOverlay.className = 'tag-overlay';

            // Check if any of the matching tags are subjective
            const matchingSubjectiveTags = matchingTags.filter(tag => {
                const tagLower = tag.toLowerCase();
                return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
            });

            // Always show all tags (or first 3 + count), but highlight if there are matches
            if (matchingSubjectiveTags.length > 0) {
                tagOverlay.classList.add('has-matches');

                // Use the first matching tag's color (if any) for overlay highlight
                let overlayColor = null;
                for (const mt of matchingSubjectiveTags) {
                    const c = searchTagColors[mt.toLowerCase()];
                    if (c) {
                        overlayColor = c;
                        break;
                    }
                }
                if (overlayColor) {
                    tagOverlay.style.backgroundColor = overlayColor;
                    tagOverlay.style.color = '#ffffff';
                }
            }

            // If this image belongs to more than one active search tag,
            // we treat it as a "duplicate across tags"
            const isDuplicateAcrossTags = matchingSubjectiveTags.length > 1;
            const maxTagsToShow = 3;
            const tagsToShow = subjectiveTags.slice(0, maxTagsToShow);

            // Clear any default text and build spans so we can style duplicates
            tagOverlay.textContent = '';

            tagsToShow.forEach((tag, idx) => {
                if (idx > 0) {
                    const comma = document.createElement('span');
                    comma.textContent = ', ';
                    tagOverlay.appendChild(comma);
                }

                const span = document.createElement('span');
                span.textContent = tag;

                // If image is under more than one active tag and this tag is one of them,
                // show this tag text in red to mark the duplicate image.
                if (isDuplicateAcrossTags &&
                    matchingSubjectiveTags.some(mt => mt.toLowerCase() === tag.toLowerCase())) {
                    span.style.color = 'red';
                    span.style.fontWeight = '600';
                }

                tagOverlay.appendChild(span);
            });

            if (subjectiveTags.length > maxTagsToShow) {
                const moreSpan = document.createElement('span');
                moreSpan.textContent = ` +${subjectiveTags.length - maxTagsToShow}`;
                tagOverlay.appendChild(moreSpan);
            }

            card.appendChild(tagOverlay);
        }

        // Add creator email display (only for non-greyscale images)
        if (!isGreyscaleIndicator && image.ownership) {
            const creatorOverlay = document.createElement('div');
            creatorOverlay.className = 'creator-overlay';
            const emailPrefix = getEmailPrefix(image.ownership);
            creatorOverlay.textContent = emailPrefix;
            creatorOverlay.title = `Created by: ${image.ownership}`;
            card.appendChild(creatorOverlay);
        }

        // Handle selection state (only for non-greyscale images)
        if (!isGreyscaleIndicator) {
            const wasAlreadySelected = selectedImages.includes(image.id);
            const hasMatchingTags = currentSearchTags.length > 0 && matchingTags.length > 0;

            // Handle selection logic (same for both pool view and library view)
            if (wasAlreadySelected || hasMatchingTags) {
                card.classList.add('selected');

                // Add pool-view class if in pool view for styling
                if (isPoolView) {
                    card.classList.add('pool-view');
                }

                // Add visual indicator for selection type - prioritize tag selection
                if (isTagSelected) {
                    card.classList.add('tag-selection');
                } else if (hasMatchingTags) {
                    card.classList.add('tag-selection');
                } else if (wasAlreadySelected) {
                    card.classList.add('manual-selection');
                }

                // Only add to selectedImages if not already there
                if (!wasAlreadySelected) {
                    selectedImages.push(image.id);
                }
            }

            // Apply per-tag highlight color to the card outline based on matching tags
            if (matchingTags.length > 0) {
                let cardColor = null;
                for (const mt of matchingTags) {
                    const c = searchTagColors[mt.toLowerCase()];
                    if (c) {
                        cardColor = c;
                        break;
                    }
                }
                if (cardColor) {
                    card.style.outline = `3px solid ${cardColor}`;
                    card.style.outlineOffset = '2px';
                }
            }
        }

        return card;
    }

    // Display a page of images (3 rows)
    function displayImagePage(loadedImages, currentSearchTags) {
        const imagesToShow = imagesPerRow * ROWS_PER_PAGE;
        const startIndex = currentPage * imagesToShow;
        const endIndex = startIndex + imagesToShow;
        const pageImages = loadedImages.slice(startIndex, endIndex);

        // Check if we should show selected images at front (library view with selections, not pool view, first page only)
        const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
        const shouldShowSelectedAtFront = !isPoolView && allSelectedImageIds.length > 0 && currentPage === 0;
        
        if (shouldShowSelectedAtFront) {
            // First, display selected images at the front (in color, clickable)
            // Get selected images in their original order from loadedImages
            const selectedImagesData = loadedImages.filter(({ image }) => allSelectedImageIds.includes(image.id));
            selectedImagesData.forEach(({ image, index, imageSrc }) => {
                const card = createImageCard(image, index, imageSrc, currentSearchTags, false);
                libraryGrid.appendChild(card);
            });
        }

        // Then display page images (skip images already shown at the front to avoid "chosen" duplicates)
        pageImages.forEach(({ image, index, imageSrc }) => {
            const isSelected = allSelectedImageIds.includes(image.id);
            // If we've already shown selected images at the front, skip them here
            if (shouldShowSelectedAtFront && isSelected) {
                return;
            }
            const card = createImageCard(image, index, imageSrc, currentSearchTags, false);
            libraryGrid.appendChild(card);
        });

        // Calculate displayed count for button
        let displayedCount = startIndex + pageImages.length;
        if (shouldShowSelectedAtFront) {
            // Add selected images count to displayed count
            displayedCount += allSelectedImageIds.length;
        }

        // Add or update "Load More" button
        updateLoadMoreButton(loadedImages.length, displayedCount);
    }

    // Update or add "Load More" and "Load All" buttons
    function updateLoadMoreButton(totalImages, displayedCount) {
        // Remove existing buttons if any
        const existingLoadMoreBtn = document.getElementById('load-more-btn');
        const existingLoadAllBtn = document.getElementById('load-all-btn');
        if (existingLoadMoreBtn) {
            existingLoadMoreBtn.remove();
        }
        if (existingLoadAllBtn) {
            existingLoadAllBtn.remove();
        }

        // Only show buttons if there are more images to load
        if (displayedCount < totalImages) {
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'load-buttons-container';
            
            // Load More button
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.id = 'load-more-btn';
            loadMoreBtn.className = 'load-more-button';
            loadMoreBtn.textContent = 'Load More';
            loadMoreBtn.addEventListener('click', () => {
                loadMoreImages();
            });
            buttonContainer.appendChild(loadMoreBtn);
            
            // Load All button
            const loadAllBtn = document.createElement('button');
            loadAllBtn.id = 'load-all-btn';
            loadAllBtn.className = 'load-all-button';
            loadAllBtn.textContent = 'Load All (but it takes time)';
            loadAllBtn.addEventListener('click', () => {
                loadAllImages();
            });
            buttonContainer.appendChild(loadAllBtn);
            
            libraryGrid.appendChild(buttonContainer);
        }
    }

    // Load more images (3 more rows)
    function loadMoreImages() {
        currentPage++;
        // Recalculate images per row in case window was resized
        calculateImagesPerRow();
        
        const loadedImages = libraryImages
            .map((libImg, idx) => {
                const originalImage = allImagesToDisplay.find(img => img.id === libImg.id);
                if (!originalImage || !libImg.loaded) return null;
                return {
                    image: originalImage,
                    index: idx,
                    imageSrc: libImg.src
                };
            })
            .filter(item => item !== null);

        const currentSearchTags = searchTags.map(tag => tag.text);
        displayImagePage(loadedImages, currentSearchTags);
    }

    // Load all remaining images
    function loadAllImages() {
        // Recalculate images per row in case window was resized
        calculateImagesPerRow();
        
        const loadedImages = libraryImages
            .map((libImg, idx) => {
                const originalImage = allImagesToDisplay.find(img => img.id === libImg.id);
                if (!originalImage || !libImg.loaded) return null;
                return {
                    image: originalImage,
                    index: idx,
                    imageSrc: libImg.src
                };
            })
            .filter(item => item !== null);

        const currentSearchTags = searchTags.map(tag => tag.text);
        
        // Clear grid and display all images
        libraryGrid.innerHTML = '';
        
        // Display all images
        loadedImages.forEach(({ image, index, imageSrc }) => {
            const card = document.createElement('div');
            card.className = 'preview-card library-card';
            card.dataset.imageId = image.id;

            const img = document.createElement('img');
            img.src = imageSrc;

            img.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleImageSelection(image.id, card);
            });

            img.style.cursor = 'pointer';
            if (isPoolView) {
                card.style.cursor = 'pointer';
            }

            card.appendChild(img);

            if (image.width || image.length) {
                const dimensionTooltip = document.createElement('div');
                dimensionTooltip.className = 'dimension-tooltip';
                const widthText = image.width ? `Width: ${image.width}` : '';
                const lengthText = image.length ? `Length: ${image.length}` : '';
                const separator = (widthText && lengthText) ? ' | ' : '';
                dimensionTooltip.textContent = widthText + separator + lengthText;
                card.appendChild(dimensionTooltip);
            }

            const eyeIcon = document.createElement('div');
            eyeIcon.className = 'image-preview-eye';
            eyeIcon.textContent = '1:1';
            eyeIcon.title = 'Preview full size image';

            eyeIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const libraryTitle = document.querySelector('#page-library .title');
                const isSelectionPoolView = isPoolView || (libraryTitle && libraryTitle.textContent.includes('Selection Pool'));

                if (isSelectionPoolView) {
                    showSelectionPoolPreview(image, allImagesToDisplay, index);
                } else {
                    showImagePreviewOverlay(imageSrc, image);
                }
            });

            card.appendChild(eyeIcon);

            // Ruler icon (real size based on mm dimensions)
            if (image.width || image.length) {
                const rulerIcon = document.createElement('div');
                rulerIcon.className = 'image-preview-ruler';
                rulerIcon.innerHTML = 'üìè';
                rulerIcon.title = 'Preview real size (1:1 based on dimensions)';

                rulerIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Ruler clicked - showing real size for image:', image.id);
                    showRealSizeOverlay(imageSrc, image);
                });

                card.appendChild(rulerIcon);
            }

            if (isPoolView) {
                const bookletIcon = document.createElement('div');
                bookletIcon.className = 'image-preview-booklet';
                bookletIcon.textContent = 'üìñ';
                bookletIcon.title = 'Open lightbox with navigation';

                bookletIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openLibraryLightbox(index);
                });

                card.appendChild(bookletIcon);
            }

            const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
            const isTagSelected = tagSelectedImages.includes(image.id);
            const allImageTags = image.tags || [];
            
            const objectivePrefixes = ['width:', 'length:', 'book:', 'page:', 'row:', 'column:', 'type:', 'material:', 'remark:', 'brand:', 'color:'];
            const subjectiveTags = allImageTags.filter(tag => {
                const tagLower = tag.toLowerCase();
                return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
            });

            if (subjectiveTags.length > 0) {
                const tagOverlay = document.createElement('div');
                tagOverlay.className = 'tag-overlay';

                const matchingSubjectiveTags = matchingTags.filter(tag => {
                    const tagLower = tag.toLowerCase();
                    return !objectivePrefixes.some(prefix => tagLower.startsWith(prefix));
                });

                if (matchingSubjectiveTags.length > 0) {
                    tagOverlay.classList.add('has-matches');
                }

                tagOverlay.textContent = subjectiveTags.slice(0, 3).join(', ');
                if (subjectiveTags.length > 3) {
                    tagOverlay.textContent += ` +${subjectiveTags.length - 3}`;
                }

                card.appendChild(tagOverlay);
            }

            const wasAlreadySelected = selectedImages.includes(image.id);
            const hasMatchingTags = currentSearchTags.length > 0 && matchingTags.length > 0;

            if (wasAlreadySelected || hasMatchingTags) {
                card.classList.add('selected');

                if (isPoolView) {
                    card.classList.add('pool-view');
                }

                if (isTagSelected) {
                    card.classList.add('tag-selection');
                } else if (hasMatchingTags) {
                    card.classList.add('tag-selection');
                } else if (wasAlreadySelected) {
                    card.classList.add('manual-selection');
                }

                if (!wasAlreadySelected) {
                    selectedImages.push(image.id);
                }
            }

            libraryGrid.appendChild(card);
        });
        
        // Update currentPage to reflect that all images are displayed
        const imagesToShow = imagesPerRow * ROWS_PER_PAGE;
        currentPage = Math.ceil(loadedImages.length / imagesToShow) - 1;
        
        // Remove buttons since all images are now loaded
        updateLoadMoreButton(loadedImages.length, loadedImages.length);
    }
    
    // Recalculate images per row on window resize
    window.addEventListener('resize', () => {
        if (allImagesToDisplay.length > 0) {
            calculateImagesPerRow();
        }
    });

    async function displayLibraryImages() {
        console.log('=== displayLibraryImages START ===');
        console.log('displayLibraryImages called, selectedImages at start:', selectedImages.length);
        console.log('isPoolView at start:', isPoolView);

        const searchMode = 'OR'; // Default to OR mode since radio buttons removed
        const currentSearchTags = searchTags.map(tag => tag.text);
        console.log('currentSearchTags:', currentSearchTags);

        try {
            // Clear broken image tracking for new load
            clearBrokenImageTracking();

            // Get all images first
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const allImagesResponse = await fetch(`${API_URL}/images`, {
                headers: headers
            });
            const allImages = await allImagesResponse.json();


            let imagesToDisplay = [];

            if (isPoolView && currentSearchTags.length === 0) {
                console.log('=== POOL VIEW LOGIC (NO SEARCH TAGS) ===');
                console.log('selectedImages:', selectedImages);
                console.log('tagSelectedImages:', tagSelectedImages);
                // Pool view without search tags - show ALL selected images (both manual and tag-selected)
                const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
                console.log('allSelectedImageIds combined:', allSelectedImageIds);
                imagesToDisplay = allImages.filter(img => allSelectedImageIds.includes(img.id));
                console.log('Pool view filtered images:', imagesToDisplay.length, '(manual + tag selected)');

                console.log('Pool view without search tags - showing all selected images by selection order');
                // Sort by selection order (most recently selected first)
                imagesToDisplay.sort((a, b) => {
                    const orderA = imageSelectionOrder[a.id] || 0;
                    const orderB = imageSelectionOrder[b.id] || 0;
                    return orderB - orderA; // Latest selection first
                });

                console.log('Pool view processing completed');
            } else if (isPoolView && currentSearchTags.length > 0) {
                console.log('=== POOL VIEW LOGIC (WITH SEARCH TAGS) ===');
                console.log('Processing tags first, then combining with existing selections');

                // First, process the search tags to get tag-matching images
                console.log('Fetching tag-matching images for tags:', currentSearchTags);
                const sessionToken = localStorage.getItem('sessionToken');
                const headers = {};
                if (sessionToken) {
                    headers['Authorization'] = `Bearer ${sessionToken}`;
                }
                const tagResponse = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`, {
                    headers: headers
                });

                if (!tagResponse.ok) {
                    throw new Error(`Tag search failed: ${tagResponse.status} ${tagResponse.statusText}`);
                }

                const tagMatchingImages = await tagResponse.json();
                console.log('Tag-matching images found:', tagMatchingImages.length);

                // Update tag-selected images (add new ones, keep existing ones)
                const newTagSelectedImages = tagMatchingImages.map(img => img.id);
                console.log('newTagSelectedImages from tags:', newTagSelectedImages);
                console.log('selectedImages before tag processing:', selectedImages);
                console.log('tagSelectedImages before tag processing:', tagSelectedImages);
                const currentTimestamp = Date.now();

                // Track how each image was selected
                const searchTagsString = currentSearchTags.join(',');
                tagMatchingImages.forEach(image => {
                    if (!imageSelectionSource[image.id]) {
                        imageSelectionSource[image.id] = searchTagsString;
                    }
                });

                // Track selection timestamps for new tag-selected images
                newTagSelectedImages.forEach(imageId => {
                    if (!tagSelectedImages.includes(imageId)) {
                        imageSelectionOrder[imageId] = currentTimestamp;
                    }
                });

                tagSelectedImages = [...new Set([...tagSelectedImages, ...newTagSelectedImages])];

                // DON'T add tag images to selectedImages - keep them separate
                // selectedImages = manual selections only
                // tagSelectedImages = tag selections only
                // Combine them only for display purposes

                console.log('selectedImages after tag processing:', selectedImages);
                console.log('tagSelectedImages after tag processing:', tagSelectedImages);

                // Now combine ALL selections for pool view display
                const allSelectedImageIds = [...new Set([...selectedImages, ...tagSelectedImages])];
                console.log('allSelectedImageIds combined for pool view:', allSelectedImageIds);
                imagesToDisplay = allImages.filter(img => allSelectedImageIds.includes(img.id));

                // Group by tags since we have search tags active
                imagesToDisplay = groupImagesByTagsAndSort(imagesToDisplay);

                console.log('Pool view with tags processing completed, final images:', imagesToDisplay.length);
            } else if (currentSearchTags.length === 0) {
                console.log('=== LIBRARY VIEW WITH NO TAGS ===');
                // Library view with no search tags - show all images, latest first
                // DON'T clear tagSelectedImages here - preserve historical tag selections
                imagesToDisplay = allImages;

                // Sort by image ID in descending order (latest uploads first)
                imagesToDisplay.sort((a, b) => b.id - a.id);

                console.log('Library view with no active tags, sorted latest first, preserving tagSelectedImages:', tagSelectedImages.length);
            } else {
                // Library view with search tags - show ALL images in the library,
                // but put matching images first, grouped by tag order (#3, then #2, then #1).
                console.log('=== LIBRARY VIEW WITH SEARCH TAGS (SHOW ALL IMAGES, GROUP MATCHES FIRST) ===');

                // We still fetch tag-matching images to update tag selection metadata.
                console.log('Fetching tag-matching images for tags (for selection metadata and ordering):', currentSearchTags);
                const sessionToken2 = localStorage.getItem('sessionToken');
                const headers2 = {};
                if (sessionToken2) {
                    headers2['Authorization'] = `Bearer ${sessionToken2}`;
                }
                const tagResponse = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`, {
                    headers: headers2
                });

                if (!tagResponse.ok) {
                    throw new Error(`Tag search failed: ${tagResponse.status} ${tagResponse.statusText}`);
                }

                const tagMatchingImages = await tagResponse.json();
                console.log('Tag-matching images found:', tagMatchingImages.length);

                // Update tag-selected images (add new ones, keep existing ones)
                const newTagSelectedImages = tagMatchingImages.map(img => img.id);
                console.log('newTagSelectedImages from tags:', newTagSelectedImages);
                console.log('selectedImages before tag processing:', selectedImages);
                console.log('tagSelectedImages before tag processing:', tagSelectedImages);
                const currentTimestamp = Date.now();

                // Track how each image was selected - attribute to the current search operation
                const searchTagsString = currentSearchTags.join(','); // Unique identifier for this search
                tagMatchingImages.forEach(image => {
                    if (!imageSelectionSource[image.id]) {
                        imageSelectionSource[image.id] = searchTagsString;
                    }
                });

                // Track selection timestamps for new tag-selected images
                newTagSelectedImages.forEach(imageId => {
                    if (!tagSelectedImages.includes(imageId)) {
                        imageSelectionOrder[imageId] = currentTimestamp;
                    }
                });

                tagSelectedImages = [...new Set([...tagSelectedImages, ...newTagSelectedImages])];

                console.log('selectedImages after tag processing:', selectedImages);
                console.log('tagSelectedImages after tag processing:', tagSelectedImages);

                // 1) Matching images: those that have at least one of the current search tags
                const currentTagsLower = currentSearchTags.map(t => t.toLowerCase());
                const matchingImages = allImages.filter(image => {
                    const imageTags = (image.tags || []).map(t => t.toLowerCase());
                    return imageTags.some(tag => currentTagsLower.includes(tag));
                });

                // Group matching images by tag order: #3 (first typed) first, then #2, then #1
                const groupedMatchingImages = groupImagesByTagsAndSort(matchingImages);

                // 2) Remaining images: those that don't match any active search tag
                const groupedIds = new Set(groupedMatchingImages.map(img => img.id));
                const remainingImages = allImages
                    .filter(img => !groupedIds.has(img.id))
                    .sort((a, b) => b.id - a.id); // latest uploads first for the rest

                // 3) Final sequence: all matching (grouped), then all remaining
                imagesToDisplay = [...groupedMatchingImages, ...remainingImages];

                console.log('Library view with search tags - matching images first, then others. Total:', imagesToDisplay.length);
            }

            // Update header based on view type - check if we're showing selection pool
            console.log('=== TITLE UPDATE LOGIC ===');
            console.log('About to update title - isPoolView:', isPoolView);
            console.log('currentSearchTags.length:', currentSearchTags.length);

            const showingSelectionPool = isShowingSelectionPool();
            console.log('isShowingSelectionPool():', showingSelectionPool);

            if (isPoolView) {
                // Always show Selection Pool title when explicitly in pool view
                console.log('Setting title to Selection Pool (explicit pool view)');
                updateLibraryTitle(true);
            } else if (showingSelectionPool && !forceLibraryView) {
                console.log('Setting title to Selection Pool (showing selection pool)');
                updateLibraryTitle(true); // Selection Pool (active search or pool view)
            } else if (currentSearchTags.length > 0 && forceLibraryView) {
                console.log('STAYING in Library view despite search tags (user requested)');
                console.log('currentSearchTags:', currentSearchTags);
                updateLibraryTitle(false); // Keep library title
                forceLibraryView = false; // Reset flag after use
            } else {
                console.log('Setting title to regular Library');
                updateLibraryTitle(false); // Full library
            }

            // Update search input visibility based on view type
            updateSearchInputVisibility();

            // SAFETY CHECK: Always disable search input/clear button if title shows Selection Pool
            setTimeout(() => {
                const libraryTitle = document.querySelector('#page-library .title');
                if (libraryTitle && libraryTitle.textContent.includes('Selection Pool')) {
                    const searchInput = document.getElementById('library-search-input');
                    const clearAllBtn = document.getElementById('clear-all-tags');

                    searchInput.disabled = true;
                    clearAllBtn.disabled = true;

                    searchInput.style.opacity = '0.5';
                    searchInput.style.cursor = 'not-allowed';
                    clearAllBtn.style.opacity = '0.5';
                    clearAllBtn.style.cursor = 'not-allowed';

                    console.log('SAFETY CHECK: Search controls disabled for Selection Pool');
                }
            }, 100);

            const images = imagesToDisplay;
            
            // Store all images for pagination
            allImagesToDisplay = images;
            currentPage = 0; // Reset pagination when loading new images
            
            // Calculate images per row based on grid width
            calculateImagesPerRow();

            libraryGrid.innerHTML = '';
            libraryImages = []; // Reset library images array
            // Keep existing selected images - don't reset selectedImages array

            // Special handling for pool view with no images
            if (isPoolView && images.length === 0) {
                const noImagesMessage = document.createElement('div');
                noImagesMessage.className = 'no-images-message';
                noImagesMessage.style.textAlign = 'center';
                noImagesMessage.style.padding = '40px';
                noImagesMessage.style.color = '#666';
                noImagesMessage.innerHTML = '<p>No images in selection pool.</p><p>You can use "Back to Library" to return to the main library and select more images.</p>';
                libraryGrid.appendChild(noImagesMessage);
                return; // Exit early if no images
            }
            
            // Show loading skeleton cards
            showLoadingSkeletons();

            // Check which tags have matches and update chip colors
            await updateTagChipColors(currentSearchTags, searchMode);

            // Add tag group headers in Selection Pool view OR when there are search tags active
            if ((isPoolView || currentSearchTags.length > 0) && images.length > 0) {
                addTagGroupHeaders(images);
            }

            // Process images with broken image detection
            const imagePromises = images.map(async (image, index) => {
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;

                // Test if image loads
                return new Promise((resolve) => {
                    const testImg = new Image();
                    testImg.onload = () => resolve({ image, index, imageSrc, loaded: true });
                    testImg.onerror = () => {
                        trackBrokenImage(image.id, imageSrc);
                        resolve({ image, index, imageSrc, loaded: false });
                    };
                    testImg.src = imageSrc;
                });
            });

            // Wait for all image load tests to complete
            const imageResults = await Promise.all(imagePromises);

            // Add ALL images to libraryImages (including broken ones) to preserve selections
            imageResults.forEach(({ image, index, imageSrc, loaded }) => {
                libraryImages.push({
                    src: imageSrc,
                    index: index,
                    tags: image.tags || [],
                    id: image.id,
                    loaded: loaded
                });
            });

            // Store all loaded images for pagination
            const loadedImages = imageResults.filter(result => result.loaded);
            
            // Clear loading skeletons and display first page
            libraryGrid.innerHTML = '';
            displayImagePage(loadedImages, currentSearchTags);

            // Show selection controls if there are images and search is active OR if we have selections
            // SPECIAL CASE: Always show controls in pool view, even with no images/selections
            if ((images.length > 0 && (currentSearchTags.length > 0 || selectedImages.length > 0)) || isPoolView) {
                selectionControls.classList.remove('is-hidden');
                updateSelectionState(); // This will call updateButtonVisibility()
            } else {
                selectionControls.classList.add('is-hidden');
                // Only clear selectedImages if we're not in pool view and have no search tags
                if (!isPoolView && currentSearchTags.length === 0) {
                    selectedImages = [];
                }
                updateButtonVisibility(); // Ensure buttons are correct even when no selections
                updateClearButtonState(); // Ensure Clear All button is disabled when no selections
            }

            console.log('displayLibraryImages completed, selectedImages at end:', selectedImages);
        } catch (error) {
            console.error('Error fetching images:', error);
            console.error('Error details:', {
                message: error.message,
                stack: error.stack,
                isPoolView: isPoolView,
                selectedImages: selectedImages,
                searchTags: searchTags
            });
            
            // Show user-friendly error message with retry button
            libraryGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <p style="font-size: 16px; margin-bottom: 8px;">‚ùå Error loading images</p>
                    <p style="font-size: 14px; color: #999; margin-bottom: 16px;">${error.message || 'Please check your connection and try again.'}</p>
                    <button class="button" onclick="displayLibraryImages()" style="margin-top: 8px;">Retry</button>
                </div>
            `;

            // Reset states to prevent getting stuck
            if (isPoolView) {
                console.log('Resetting pool view state due to error');
                isPoolView = false;
                viewPoolBtn.classList.remove('is-hidden');
                backToLibraryBtn.classList.add('is-hidden');
                selectAllBtn.classList.remove('is-hidden');
                deselectAllBtn.classList.remove('is-hidden');
            }
        }
    }

    async function updateTagChipColors(tags, searchMode) {
        for (const tagText of tags) {
            try {
                const sessionToken = localStorage.getItem('sessionToken');
                const headers = {};
                if (sessionToken) {
                    headers['Authorization'] = `Bearer ${sessionToken}`;
                }
                const response = await fetch(`${API_URL}/images?tags=${tagText}&mode=OR`, {
                    headers: headers
                });
                const images = await response.json();
                const hasMatches = images.length > 0;
                const imageCount = images.length;

                // Update the chip color and count based on matches
                const chip = Array.from(librarySearchChips.querySelectorAll('.search-chip')).find(
                    chip => {
                        // Extract tag name from "tagname (count)" format
                        const chipText = chip.textContent.replace(/[√óx]$/, '').trim();
                        const tagName = chipText.replace(/\s*\(\d+\)$/, '');
                        return tagName === tagText;
                    }
                );

                if (chip) {
                    // Update the chip text with new count
                    const deleteBtn = chip.querySelector('.chip-delete');
                    chip.textContent = `${tagText} (${imageCount})`;
                    if (deleteBtn) {
                        chip.appendChild(deleteBtn); // Re-add the delete button
                    }

                    // Update color classes
                    if (hasMatches) {
                        chip.classList.remove('no-matches');
                        chip.classList.add('has-matches');
                    } else {
                        chip.classList.remove('has-matches');
                        chip.classList.add('no-matches');
                    }
                }

                // Update searchTags array
                const tagIndex = searchTags.findIndex(tag => tag.text === tagText);
                if (tagIndex !== -1) {
                    searchTags[tagIndex].hasMatches = hasMatches;
                }
            } catch (error) {
                console.error(`Error checking matches for tag "${tagText}":`, error);
            }
        }
    }

    function navigateTo(pageName) {
        const confirmModal = document.getElementById('confirm-modal');
        // Do not navigate if the confirmation modal is visible
        if (confirmModal && !confirmModal.classList.contains('is-hidden')) {
            return;
        }
        Object.values(pages).forEach(page => page.classList.add('is-hidden'));
        document.querySelectorAll('.menu__item').forEach(link => link.classList.remove('is-active'));
        pages[pageName].classList.remove('is-hidden');
        navLinks[pageName].classList.add('is-active');

        if (pageName === 'library') {
            clearBrokenImageTracking();
            initializeFreshSearchInput();
            displayLibraryImages();
        } else if (pageName === 'project') {
            displayProjects();
        } else if (pageName === 'admin') {
            loadAdminUsers();
        } else if (pageName === 'upload') {
            fetchSubjFrequencies();
        }
    }

    function handleFiles(files) {
        for (const file of files) {
            if (!file.type.startsWith('image/')) continue;
            filesToUpload.push(file);

            const reader = new FileReader();
            reader.onload = (e) => {
                const card = document.createElement('div');
                card.className = 'preview-card';

                const img = document.createElement('img');
                img.src = e.target.result;
                img.addEventListener('click', (event) => {
                    const allImages = Array.from(previewGrid.querySelectorAll('img'));
                    const clickedIndex = allImages.indexOf(event.target);
                    openModal(clickedIndex);
                });

                const del = document.createElement('button');
                del.type = 'button';
                del.className = 'delete-btn';
                del.textContent = '√ó';
                del.addEventListener('click', () => {
                    const indexToRemove = filesToUpload.indexOf(file);
                    if (indexToRemove > -1) {
                        filesToUpload.splice(indexToRemove, 1);
                    }
                    card.remove();
                });

                // Add 1:1 icon and ruler icon for full-size preview
                const previewIcon = document.createElement('div');
                previewIcon.className = 'image-preview-eye';
                previewIcon.textContent = '1:1';
                previewIcon.title = 'Preview full size image';
                const imageSrc = e.target.result; // Store image source for preview
                previewIcon.addEventListener('click', (evt) => {
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Show image in overlay at original size
                    showImagePreviewOverlay(imageSrc, null);
                });

                // Ruler icon for real size (only if dimensions are available)
                const objWidth = document.getElementById('obj-width').value;
                const objLength = document.getElementById('obj-length').value;
                const rulerIcon = document.createElement('div');
                rulerIcon.className = 'image-preview-ruler';
                rulerIcon.innerHTML = 'üìè';
                rulerIcon.title = 'Preview real size (1:1 based on dimensions)';
                
                if (objWidth || objLength) {
                    rulerIcon.addEventListener('click', (evt) => {
                        evt.preventDefault();
                        evt.stopPropagation();
                        // Show image in overlay at real size
                        const tempImage = {
                            width: objWidth || null,
                            length: objLength || null
                        };
                        showRealSizeOverlay(imageSrc, tempImage);
                    });
                } else {
                    rulerIcon.style.opacity = '0.5';
                    rulerIcon.style.cursor = 'not-allowed';
                    rulerIcon.title = 'Add width or length to enable real size preview';
                }

                card.appendChild(del);
                card.appendChild(img);
                card.appendChild(previewIcon);
                card.appendChild(rulerIcon);
                previewGrid.appendChild(card);
            };
            reader.readAsDataURL(file);
        }
    }

    function showSubjToast(message) {
        if (!message) return;
        const existing = document.getElementById('subj-toast');
        if (existing) existing.remove();
        const toast = document.createElement('div');
        toast.id = 'subj-toast';
        toast.className = 'subj-toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        if (subjToastTimeout) clearTimeout(subjToastTimeout);
        subjToastTimeout = setTimeout(() => {
            toast.remove();
        }, 5000);
    }

    function isObjectiveTag(tag) {
        if (!tag) return false;
        const t = String(tag).toLowerCase();
        const prefixes = [
            'book:', 'page:', 'row:', 'column:', 'type:', 'material:', 'width:',
            'length:', 'remark:', 'brand:', 'color:', 'dimension:'
        ];
        return prefixes.some(p => t.startsWith(p));
    }

    function getCurrentFeelingTags() {
        if (!subjChips) return [];
        return Array.from(subjChips.querySelectorAll('.chip')).map(c =>
            c.textContent.replace(/[√óx]$/, '').trim().toLowerCase()
        );
    }

    function refreshSubjFreqDisabledState() {
        if (!subjFreqList) return;
        const currentTags = new Set(getCurrentFeelingTags());
        Array.from(subjFreqList.querySelectorAll('.subj-freq-item')).forEach(row => {
            const label = (row.dataset.label || '').toLowerCase();
            const isUsed = currentTags.has(label);
            if (isUsed) {
                row.classList.add('disabled');
            } else {
                row.classList.remove('disabled');
            }
        });
    }

    function updateSubjFreqList() {
        if (!subjFreqList) return;
        // Convert map to array and sort by count desc, then label asc
        const items = Object.entries(subjFreqMap)
            .map(([label, count]) => ({ label, count }))
            .sort((a, b) => b.count - a.count || a.label.localeCompare(b.label));

        subjFreqList.innerHTML = '';
        items.forEach(({ label, count }) => {
            const row = document.createElement('div');
            row.className = 'subj-freq-item';
            row.dataset.label = label;

            const spanLabel = document.createElement('span');
            spanLabel.className = 'subj-freq-item__label';
            spanLabel.textContent = label;

            const spanCount = document.createElement('span');
            spanCount.className = 'subj-freq-item__count';
            spanCount.textContent = `√ó${count}`;

            row.appendChild(spanLabel);
            row.appendChild(spanCount);

            // Clicking a frequent item adds it again to chips (once per current feelings)
            row.addEventListener('click', () => {
                if (row.classList.contains('disabled')) {
                    showSubjToast('Tag already added');
                    return;
                }
                const added = addSubjChip(label);
                if (added !== false) {
                    refreshSubjFreqDisabledState();
                }
            });

            subjFreqList.appendChild(row);
        });
        refreshSubjFreqDisabledState();
    }

    async function fetchSubjFrequencies() {
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }

            const response = await fetch(`${API_URL}/tag-frequencies`, { headers });
            if (!response.ok) {
                throw new Error(`Failed to fetch tag frequencies: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();

            // Reset and populate the in-memory map
            Object.keys(subjFreqMap).forEach(k => delete subjFreqMap[k]);
            data.forEach(item => {
                if (!item || !item.name) return;
                const label = String(item.name).toLowerCase();
                const count = Number(item.count) || 0;
                subjFreqMap[label] = count;
            });

            updateSubjFreqList();
        } catch (err) {
            console.error('Error fetching tag frequencies:', err);
        }
    }

    async function persistFeelingsUsage(feelings) {
        const payload = Array.isArray(feelings) ? feelings : [];
        if (payload.length === 0) return;
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json'
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/feelings/usage`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ feelings: payload })
            });
            if (!response.ok) {
                throw new Error(`Failed to persist feelings: ${response.status} ${response.statusText}`);
            }
        } catch (err) {
            console.error('Error persisting feelings usage:', err);
        }
    }

    async function persistFeelingsUsageDecrement(feelings) {
        const payload = Array.isArray(feelings) ? feelings : [];
        if (payload.length === 0) return;
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json'
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/feelings/usage/decrement`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ feelings: payload })
            });
            if (!response.ok) {
                throw new Error(`Failed to decrement feelings: ${response.status} ${response.statusText}`);
            }
        } catch (err) {
            console.error('Error decrementing feelings usage:', err);
        }
    }

    function addSubjChip(label) {
        const text = (label || '').toLowerCase().trim();
        if (!text) return false;
        const exists = [...subjChips.querySelectorAll('.chip')].some(
            c => c.textContent.replace(/[√óx]$/, '').trim().toLowerCase() === text
        );
        if (exists) {
            showSubjToast('Tag already added');
            return false;
        }
        const chip = document.createElement('span');
        chip.className = 'chip is-subjective';
        chip.textContent = text;
        chip.tabIndex = 0;

        // Hover behavior: temporarily "flash" images that match this tag
        chip.addEventListener('mouseenter', () => {
            const tagLower = text.toLowerCase();
            const cards = document.querySelectorAll('.library-card');
            cards.forEach(card => {
                const imageId = parseInt(card.dataset.imageId, 10);
                const img = libraryImages.find(img => img.id === imageId);
                if (!img || !img.tags) return;
                const hasTag = img.tags.some(t => t.toLowerCase() === tagLower);
                if (hasTag) {
                    // Pass the tag color into the card via CSS variable for the running dotted border
                    const c = searchTagColors && searchTagColors[tagLower] ? searchTagColors[tagLower] : '#000';
                    card.style.setProperty('--tag-flash-color', c);
                    card.classList.add('tag-flash');
                }
            });
        });

        chip.addEventListener('mouseleave', () => {
            const cards = document.querySelectorAll('.library-card.tag-flash');
            cards.forEach(card => card.classList.remove('tag-flash'));
        });
        chip.addEventListener('click', () => chip.classList.toggle('is-selected'));
        const x = document.createElement('button');
        x.type = 'button';
        x.className = 'x';
        x.textContent = '√ó';
        x.addEventListener('click', (ev) => {
            ev.stopPropagation();
            chip.remove();
            refreshSubjFreqDisabledState();
        });
        chip.appendChild(x);
        subjChips.appendChild(chip);
        refreshSubjFreqDisabledState();
        return true;
    }

    function handleSubjCommit() {
        const parts = subjInput.value.split(',').map(p => p.trim()).filter(p => p.length > 0);
        const uniqueParts = [...new Set(parts.map(p => p.toLowerCase()))];
        uniqueParts.forEach(p => addSubjChip(p));
        subjInput.value = '';
    }

    function handleObjCommit(input) {
        const value = input.value.trim();
        if (value) {
            // Get prefix from data attribute or determine from input id
            const prefix = input.getAttribute('data-prefix') || '';
            // Create tag with prefix (e.g., "book:Album-01" or just "Album-01" if no prefix)
            const tagValue = prefix ? `${prefix}${value}` : value;
            addObjChip(tagValue);
            input.value = '';
        }
    }

    function addObjChip(text) {
        if (!text.trim()) return;

        const chip = document.createElement('div');
        chip.className = 'chip chip--objective';
        chip.textContent = text.trim();

        const x = document.createElement('span');
        x.className = 'chip-remove';
        x.textContent = '√ó';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        objChips.appendChild(chip);
    }

    function autoFillMetadata() {
        // Sample data arrays for random selection
        const sampleData = {
            books: ['Album-01', 'Collection-A', 'Stamps-2024', 'Vintage-Set', 'Modern-Series'],
            pages: ['12', '25', '8', '33', '15', '7', '41'],
            rows: ['1', '2', '3', '4', '5'],
            columns: ['1', '2', '3', '4'],
            types: ['stamp', 'coin', 'banknote', 'postcard', 'photo', 'document'],
            materials: ['paper', 'metal', 'plastic', 'fabric', 'wood', 'ceramic'],
            widths: ['25', '15', '40', '30', '20', '50'],
            lengths: ['30', '20', '25', '35', '25', '30'],
            remarks: [
                'excellent condition, rare find',
                'mint condition, first edition',
                'good condition, slight wear',
                'vintage piece, collector item',
                'pristine condition, never used',
                'historical significance, well preserved'
            ],
            brands: ['royal-mail', 'usps', 'canada-post', 'deutsche-post', 'japan-post'],
            colors: ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'black', 'white']
        };

        // Random selection function
        const random = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // Fill all fields with random sample data (without prefixes in input values)
        if (objBookInput) objBookInput.value = random(sampleData.books);
        if (objPageInput) objPageInput.value = random(sampleData.pages);
        if (objRowInput) objRowInput.value = random(sampleData.rows);
        if (objColumnInput) objColumnInput.value = random(sampleData.columns);
        if (objTypeInput) objTypeInput.value = random(sampleData.types);
        if (objMaterialInput) objMaterialInput.value = random(sampleData.materials);
        if (objWidthInput) objWidthInput.value = random(sampleData.widths);
        if (objLengthInput) objLengthInput.value = random(sampleData.lengths);
        if (objRemarkInput) objRemarkInput.value = random(sampleData.remarks);
        if (objBrandInput) objBrandInput.value = random(sampleData.brands);
        if (objColorInput) objColorInput.value = random(sampleData.colors);

        // Visual feedback
        autoFillBtn.textContent = 'Filled!';
        autoFillBtn.style.background = '#4caf50';
        setTimeout(() => {
            autoFillBtn.textContent = 'Auto Fill';
            autoFillBtn.style.background = '#2196f3';
        }, 1500);
    }

    function updateArrowVisibility() {
        const totalImages = imageSources.length;
        prevButton.style.display = (currentImageIndex > 0 && totalImages > 1) ? 'block' : 'none';
        nextButton.style.display = (currentImageIndex < totalImages - 1 && totalImages > 1) ? 'block' : 'none';
    }

    function openModal(index) {
        currentImageIndex = index;
        imageSources = Array.from(previewGrid.querySelectorAll('img')).map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        updateArrowVisibility();
    }

    function hideModal() {
        modal.classList.add('is-hidden');
        const freqFloating = document.getElementById('lightbox-freq-floating');
        if (freqFloating) freqFloating.remove();
        pendingAddTags.clear();
        lightboxDirty = false;
        if (lightboxSaveBtn) lightboxSaveBtn.classList.add('is-hidden');
    }

    // --- Library Lightbox Functions ---

    function openLibraryLightbox(index) {
        pendingAddTags.clear();
        lightboxDirty = false;
        currentImageIndex = index;
        imageSources = libraryImages.map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        renderLightboxFreqFloating(libraryImages[index].id);
        modal.classList.remove('is-hidden');
        if (lightboxSaveBtn) lightboxSaveBtn.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showLibraryImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        if (libraryImages[index]) {
            renderLightboxFreqFloating(libraryImages[index].id);
        }
        if (lightboxSaveBtn) lightboxSaveBtn.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    // --- Search Tag Chip Functions ---

    function getColorForSearchTag(text) {
        const key = text.toLowerCase();
        if (searchTagColors[key]) return searchTagColors[key];

        const palette = [
            '#2196F3', // blue
            '#4CAF50', // green
            '#FF9800', // orange
            '#9C27B0', // purple
            '#00BCD4', // cyan
            '#3F51B5', // indigo
            '#8BC34A', // light green
            '#FFC107', // amber
            '#795548', // brown
            '#607D8B'  // blue grey
        ];

        let color = null;
        for (const c of palette) {
            if (!usedSearchColors.has(c)) {
                color = c;
                break;
            }
        }
        if (!color) {
            color = '#4CAF50';
        }
        searchTagColors[key] = color;
        usedSearchColors.add(color);
        return color;
    }

    async function addSearchTagChip(tagText) {
        const text = tagText.toLowerCase().trim();
        if (!text) return;

        // Check if tag already exists
        if (searchTags.some(tag => tag.text === text)) return;

        // Reset forceLibraryView when user actively adds new tags
        // This allows auto-switching to Selection Pool after "Back to Library"
        forceLibraryView = false;
        console.log('Reset forceLibraryView to false when adding new tag:', text);

        // Track tag input timestamp for ordering (most recent input first)
        const currentTimestamp = Date.now();
        tagCreationOrder[text] = currentTimestamp;
        console.log(`Tag "${text}" input at timestamp:`, currentTimestamp);
        
        // Save the updated tag order
        saveTagCreationOrder();

        // Add to searchTags array (newest at the front)
        searchTags.unshift({ text: text, hasMatches: true });

        // Create chip element with count
        const chip = document.createElement('span');
        chip.className = 'chip search-chip';

        // Get image count for this tag (to determine matches / no-matches)
        let imageCount = 0;
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images?tags=${text}&mode=OR`, {
                headers: headers
            });
            const images = await response.json();
            imageCount = images.length;
        } catch (error) {
            console.error(`Error getting count for tag "${text}":`, error);
        }

        // Temporary order; we'll renumber all chips after insertion
        let order = 1;

        if (imageCount === 0) {
            // Mark as no matches - red box
            chip.className = 'chip search-chip no-matches';
            chip.textContent = `#${order} ${text} (0)`;
            // Update searchTags entry
            const tagEntry = searchTags.find(t => t.text === text);
            if (tagEntry) tagEntry.hasMatches = false;
        } else {
            // Tag has matches - assign a non-red color and show count
            const color = getColorForSearchTag(text);
            chip.className = 'chip search-chip has-matches';
            chip.style.backgroundColor = color;
            chip.style.borderColor = color;
            chip.style.color = '#ffffff';
            chip.textContent = `#${order} ${text} (${imageCount})`;

            const tagEntry = searchTags.find(t => t.text === text);
            if (tagEntry) tagEntry.hasMatches = true;
        }
        chip.tabIndex = 0;
        chip.dataset.tag = text;
        chip.dataset.count = String(imageCount);

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'chip-delete';
        deleteBtn.textContent = '√ó';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();

            // Always confirm before clearing this tag and its selected images
            showTagRemovalConfirmation(tagText);
        });

        chip.appendChild(deleteBtn);
        // Insert newest chip at the beginning so it appears on the left
        if (librarySearchChips.firstChild) {
            librarySearchChips.insertBefore(chip, librarySearchChips.firstChild);
        } else {
            librarySearchChips.appendChild(chip);
        }

        // Renumber all chips so leftmost is highest # and rightmost is #1
        renumberSearchChips();
        updateClearButtonState();
    }

    function renumberSearchChips() {
        const chips = Array.from(librarySearchChips.querySelectorAll('.search-chip'));
        chips.forEach((chip, index) => {
            // Rightmost (newest) chip is #1, then #2, etc.
            const order = chips.length - index;
            const tag = chip.dataset.tag || '';
            const count = chip.dataset.count || '';

            // Preserve class and color, only change the label text
            if (chip.classList.contains('no-matches')) {
                chip.textContent = `#${order} ${tag} (0)`;
            } else {
                chip.textContent = `#${order} ${tag} (${count})`;
            }

            // Re-append delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'chip-delete';
            deleteBtn.textContent = '√ó';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showTagRemovalConfirmation(tag);
            });
            chip.appendChild(deleteBtn);
        });
    }

    function removeSearchTagChipInPoolView(tagText) {
        console.log('=== removeSearchTagChipInPoolView START ===');
        console.log('Removing tag in pool view:', tagText, 'MUST stay in pool view');
        
        const originalPoolView = isPoolView; // Preserve original state
        
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);
        console.log('After removing tag, searchTags.length:', searchTags.length);

        // Remove from tagCreationOrder (this tag is no longer tracked)
        delete tagCreationOrder[tagText];
        saveTagCreationOrder();

        // Find images that have the removed tag and remove them from selected images
        const imagesToRemove = [];
        
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesToRemove.push(imageId);
            }
        });

        // Remove these images from selections
        selectedImages = selectedImages.filter(id => !imagesToRemove.includes(id));
        tagSelectedImages = tagSelectedImages.filter(id => !imagesToRemove.includes(id));

        // Remove selection timestamps for removed images
        imagesToRemove.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        console.log('Removed images with tag "' + tagText + '":', imagesToRemove);
        console.log('Remaining selectedImages:', selectedImages.length);

        // Show notification about tag removal and image deselection
        if (imagesToRemove.length > 0) {
            showTagRemovalNotification(tagText, imagesToRemove.length);
        }

        // Remove chip from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            const chipTag = (chip.dataset.tag || '').toLowerCase();
            if (chipTag === tagText.toLowerCase()) {
                chip.remove();
            }
        });

        // Keep input visually empty; chips represent current tags
        librarySearchInput.value = '';
        
        // Force preserve pool view state
        isPoolView = originalPoolView;
        console.log('Forced isPoolView back to:', isPoolView);
        
        renumberSearchChips();
        updateClearButtonState();
        
        // Directly refresh pool view without calling any functions that might reset state
        console.log('About to refresh pool view display');
        displayLibraryImages();
        
        // Double-check pool view state after display
        if (!isPoolView && originalPoolView) {
            console.log('WARNING: isPoolView was reset! Forcing it back to true');
            isPoolView = true;
            updateLibraryTitle(true);
        }
        
        console.log('=== removeSearchTagChipInPoolView END ===');
        console.log('Final isPoolView:', isPoolView);
    }

    function removeSearchTagChip(tagText) {
        console.log('=== removeSearchTagChip START ===');
        console.log('removeSearchTagChip called for tag:', tagText, 'isPoolView:', isPoolView);
        
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);
        console.log('After removing tag, searchTags.length:', searchTags.length);

        // Also clear stored color for this tag so it can be reused later
        if (searchTagColors && searchTagColors[tagText.toLowerCase()]) {
            const color = searchTagColors[tagText.toLowerCase()];
            delete searchTagColors[tagText.toLowerCase()];
            if (usedSearchColors && usedSearchColors.has(color)) {
                usedSearchColors.delete(color);
            }
        }

        // Remove from tagCreationOrder (this tag is no longer tracked)
        delete tagCreationOrder[tagText];
        saveTagCreationOrder();

        // Find images that have the removed tag and remove them from selected images
        const imagesToRemove = [];
        
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesToRemove.push(imageId);
            }
        });

        // Remove these images from selections
        selectedImages = selectedImages.filter(id => !imagesToRemove.includes(id));
        tagSelectedImages = tagSelectedImages.filter(id => !imagesToRemove.includes(id));

        // Remove selection timestamps for removed images
        imagesToRemove.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        console.log('Removed images with tag "' + tagText + '":', imagesToRemove);
        console.log('Remaining selectedImages:', selectedImages.length);

        // Show notification about tag removal and image deselection
        if (imagesToRemove.length > 0) {
            showTagRemovalNotification(tagText, imagesToRemove.length);
        }

        // Remove chip from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            const chipTag = (chip.dataset.tag || '').toLowerCase();
            if (chipTag === tagText.toLowerCase()) {
                chip.remove();
            }
        });

        // Keep input visually empty; chips represent current tags
        console.log('About to renumber chips after removal, isPoolView:', isPoolView);
        renumberSearchChips();
        updateClearButtonState();
        console.log('After updateClearButtonState, isPoolView:', isPoolView);
        
        // Stay in selection pool view if we were there
        const wasInPoolView = isPoolView;
        console.log('wasInPoolView saved as:', wasInPoolView);
        
        if (wasInPoolView) {
            // Keep in pool view and refresh to show remaining selected images
            console.log('About to call displayLibraryImages in pool view mode');
            displayLibraryImages();
        } else {
            // If we were in library view, refresh the library view
            console.log('About to call displayLibraryImages in library view mode');
            displayLibraryImages();
        }
        
        console.log('=== removeSearchTagChip END ===');
        console.log('Final isPoolView:', isPoolView);
    }



    function clearAllSearchChips() {
        console.log('=== clearAllSearchChips CALLED ===');
        console.log('clearAllSearchChips called - clearing everything and returning to main library');
        console.log('Before clear - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'tagSelectedImages:', tagSelectedImages.length, 'isPoolView:', isPoolView);

        // Clear all search tags
        searchTags = [];
        tagSelectedImages = []; // Clear tag-selected images
        imageSelectionSource = {}; // Clear selection source tracking
        librarySearchChips.innerHTML = '';


        // Clear all selected images
        selectedImages = [];

        // Clear all selection timestamps
        imageSelectionOrder = {};

        // Remove visual selection styling from all cards
        const cards = document.querySelectorAll('.library-card');
        cards.forEach(card => {
            card.classList.remove('selected');
            card.classList.remove('manual-selection');
            card.classList.remove('tag-selection');
        });

        // Ensure we're in main library view (not pool view)
        console.log('clearAllSearchChips - SETTING isPoolView = false');
        isPoolView = false;

        // Update UI states
        updateClearButtonState();
        updateSelectionState();

        // Refresh to show full library with no selections or filters
        displayLibraryImages();

        console.log('After clear - returned to main library with no selections or filters');
        console.log('Final state - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'isPoolView:', isPoolView);
        console.log('=== clearAllSearchChips END ===');
    }



    function updateSearchInput() {
        // We keep the visible input EMPTY; chips below represent current tags.
        // Only manage the programmaticUpdate flag so clearing doesn't wipe chips.
        librarySearchInput.dataset.programmaticUpdate = 'true';
        librarySearchInput.value = '';

        // Remove the flag shortly after to resume normal behavior.
        requestAnimationFrame(() => {
            setTimeout(() => {
                delete librarySearchInput.dataset.programmaticUpdate;
            }, 50);
        });
    }

    function updateClearButtonState() {
        // Simple: disable button when 0 selected images
        const totalSelections = [...new Set([...selectedImages, ...tagSelectedImages])].length;

        if (totalSelections === 0) {
            clearAllTagsBtn.disabled = true;
            clearAllTagsBtn.style.opacity = '0.5';
            clearAllTagsBtn.style.cursor = 'not-allowed';
            clearAllTagsBtn.style.backgroundColor = '#ccc';
        } else {
            clearAllTagsBtn.disabled = false;
            clearAllTagsBtn.style.opacity = '1';
            clearAllTagsBtn.style.cursor = 'pointer';
            clearAllTagsBtn.style.backgroundColor = '';
        }
    }

    function initializeFreshSearchInput() {
        // Clear any cached or remembered values
        librarySearchInput.value = '';
        librarySearchInput.defaultValue = '';

        // Clear any browser autocomplete cache for this session
        if (librarySearchInput.form) {
            librarySearchInput.form.reset();
        }

        // Force clear any browser-stored values
        setTimeout(() => {
            librarySearchInput.value = '';
        }, 0);

        // NOTE: Do not clear existing chips here; only reset the raw input field.
    }

    function getMatchingTags(imageTags, searchTags) {
        if (!imageTags || !searchTags || searchTags.length === 0) {
            return [];
        }

        // Return tags that are both in the image and in the search
        return imageTags.filter(imageTag =>
            searchTags.some(searchTag =>
                searchTag.toLowerCase() === imageTag.toLowerCase()
            )
        );
    }

    function displayLightboxTags(index) {
        if (index >= libraryImages.length || index < 0) {
            lightboxTags.innerHTML = '';
            return;
        }

        const currentImage = libraryImages[index];
        // Only show subjective/feeling tags (exclude metadata with prefixes)
        const imageTags = (currentImage.tags || []).filter(t => !isObjectiveTag(t));
        lightboxTags.innerHTML = '';

        // Left column: tag list + add input (frequency panel floats separately)
        const tagList = document.createElement('div');
        tagList.className = 'lightbox-tag-list';

        // Render existing + pending chips
        const allTagSet = new Set([...imageTags, ...pendingAddTags]);
        if (allTagSet.size === 0) {
            const empty = document.createElement('span');
            empty.className = 'no-tags';
            empty.textContent = 'No tags';
            tagList.appendChild(empty);
        } else {
            allTagSet.forEach(tagText => {
            const chip = document.createElement('span');
            chip.className = 'lightbox-tag-chip';
            chip.textContent = tagText;

            // Highlight if it matches current search
            const currentSearchTags = searchTags.map(tag => tag.text);
            if (currentSearchTags.some(searchTag =>
                searchTag.toLowerCase() === tagText.toLowerCase())) {
                chip.classList.add('highlighted');
            }

            // Add red remove "√ó" to request confirmation before deletion
            const removeBtn = document.createElement('span');
            removeBtn.className = 'lightbox-tag-remove';
            removeBtn.textContent = '√ó';
            removeBtn.title = 'Remove this tag from the image';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleRemoveTagFromImage(currentImage.id, tagText);
            });
            chip.appendChild(removeBtn);

                tagList.appendChild(chip);
            });
        }

        // Add input for adding new tags in lightbox
        const addWrap = document.createElement('div');
        addWrap.className = 'lightbox-tag-add';

        const addInput = document.createElement('input');
        addInput.type = 'text';
        addInput.placeholder = 'Add new tag (press Enter/Tab)';

        const commitAdd = async () => {
            const value = (addInput.value || '').trim();
            if (!value) return;
            const added = await handleAddTagToImage(currentImage.id, value);
            if (added) addInput.value = '';
        };

        addInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                commitAdd();
            }
        });

        addWrap.appendChild(addInput);
        lightboxTags.appendChild(tagList);
        lightboxTags.appendChild(addWrap);

        renderLightboxFreqFloating(currentImage.id);
    }

    // Remove a single tag from an image with confirmation (used in lightbox)
    function handleRemoveTagFromImage(imageId, tagText) {
        const image = libraryImages.find(img => img.id === imageId);
        if (!image || !tagDeleteConfirmModal) return;
        pendingTagDelete = { imageId, tagText };
        tagDeleteName.textContent = tagText;
        tagDeleteConfirmModal.classList.remove('is-hidden');
    }

    async function confirmRemoveTagFromImage() {
        if (!pendingTagDelete) return;
        const { imageId, tagText } = pendingTagDelete;
        const image = libraryImages.find(img => img.id === imageId);
        if (!image) {
            pendingTagDelete = null;
            tagDeleteConfirmModal.classList.add('is-hidden');
            return;
        }
        const newTags = (image.tags || []).filter(t => t !== tagText);
        try {
            await updateImageTags(imageId, newTags);
            image.tags = newTags;
            pendingAddTags.delete(tagText);
            lightboxDirty = true;
            displayLightboxTags(currentPreviewIndex);
            // Update feelings frequency if this is a subjective tag
            if (!isObjectiveTag(tagText)) {
                await persistFeelingsUsageDecrement([tagText]);
                await fetchSubjFrequencies();
            }
        } catch (err) {
            console.error('Failed to remove tag from image:', err);
            alert('Failed to remove tag. Please try again.');
        } finally {
            pendingTagDelete = null;
            tagDeleteConfirmModal.classList.add('is-hidden');
        }
    }

    async function handleAddTagToImage(imageId, tagText) {
        const image = libraryImages.find(img => img.id === imageId);
        if (!image) return;
        const cleaned = tagText.trim();
        if (!cleaned) return;
        // Prevent duplicates against existing tags + pending adds (case-insensitive)
        const exists = [...(image.tags || []), ...pendingAddTags].some(t => t.toLowerCase() === cleaned.toLowerCase());
        if (exists) {
            showLightboxToast('Tag already added');
            return false;
        }
        pendingAddTags.add(cleaned);
        lightboxDirty = true;
        displayLightboxTags(currentPreviewIndex);
        renderLightboxFreqFloating(imageId);
        return true;
    }

    async function saveLightboxTagChanges(imageId, { closeAfterSave = false } = {}) {
        const image = libraryImages.find(img => img.id === imageId);
        if (!image) return;
        if (pendingAddTags.size === 0) {
            // No new tags, but if something changed (e.g., removals) and user clicked Save,
            // just close when requested instead of saying "Nothing to save".
            if (closeAfterSave && lightboxDirty) {
                lightboxDirty = false;
                hideModal();
            } else if (!lightboxDirty) {
                showLightboxToast('Nothing to save');
            }
            return;
        }
        const newTags = [...new Set([...(image.tags || []), ...pendingAddTags])];
        try {
            await updateImageTags(imageId, newTags);
            image.tags = newTags;
            // Increment feelings usage for subjective tags (no prefix)
            const feelings = [...pendingAddTags].filter(tag => !tag.includes(':'));
            if (feelings.length > 0) {
                await persistFeelingsUsage(feelings);
                await fetchSubjFrequencies();
            }
            pendingAddTags.clear();
            lightboxDirty = false;
            displayLightboxTags(currentPreviewIndex);
            renderLightboxFreqFloating(imageId);
            showLightboxToast('Tags saved');
            if (closeAfterSave) {
                hideModal();
            }
        } catch (err) {
            console.error('Failed to save tags:', err);
            alert('Failed to save tags. Please try again.');
        }
    }

    function renderLightboxFreqFloating(imageId) {
        // Prefer the preview overlay if it's visible; otherwise use the lightbox modal
        const overlay = (imagePreviewOverlay && imagePreviewOverlay.classList.contains('show'))
            ? imagePreviewOverlay
            : document.getElementById('lightbox-modal');
        if (!overlay) return;
        // remove existing
        const existing = document.getElementById('lightbox-freq-floating');
        if (existing) existing.remove();

        const panel = document.createElement('div');
        panel.id = 'lightbox-freq-floating';
        panel.className = 'lightbox-freq-floating';

        const header = document.createElement('h4');
        header.textContent = 'Frequently used';
        panel.appendChild(header);

        const list = document.createElement('div');
        list.className = 'lightbox-freq-list';

        const freqItems = Object.entries(subjFreqMap)
            .map(([label, count]) => ({ label, count }))
            .sort((a, b) => b.count - a.count || a.label.localeCompare(b.label));

        if (freqItems.length === 0) {
            const empty = document.createElement('div');
            empty.style.color = '#ccc';
            empty.textContent = 'No frequent tags yet';
            list.appendChild(empty);
        } else {
            // Determine current tags for disable state
            const image = libraryImages.find(img => img.id === imageId);
            const existingTags = new Set([...(image?.tags || []), ...pendingAddTags]);
            freqItems.forEach(({ label, count }) => {
                const row = document.createElement('div');
                row.className = 'lightbox-freq-item';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = label;
                const countSpan = document.createElement('span');
                countSpan.textContent = `√ó${count}`;
                row.appendChild(nameSpan);
                row.appendChild(countSpan);
                const isUsed = Array.from(existingTags).some(t => t.toLowerCase() === label.toLowerCase());
                if (isUsed) {
                    row.classList.add('disabled');
                }
                row.addEventListener('click', () => {
                    if (row.classList.contains('disabled')) {
                        showLightboxToast('Tag already added');
                        return;
                    }
                    handleAddTagToImage(imageId, label);
                });
                list.appendChild(row);
            });
        }

        panel.appendChild(list);
        overlay.appendChild(panel);
    }

    let lightboxToastTimeout = null;
    function showLightboxToast(message) {
        if (!message) return;
        const existing = document.getElementById('lightbox-toast');
        if (existing) existing.remove();
        const toast = document.createElement('div');
        toast.id = 'lightbox-toast';
        toast.className = 'lightbox-toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        if (lightboxToastTimeout) clearTimeout(lightboxToastTimeout);
        lightboxToastTimeout = setTimeout(() => {
            toast.remove();
        }, 1800);
    }

    // --- Selection and Project Management Functions ---

    function toggleImageSelection(imageId, cardElement) {
        // Allow selection/deselection in both library and pool view

        const isSelected = selectedImages.includes(imageId);
        const isTagSelected = tagSelectedImages.includes(imageId);

        if (isSelected) {
            // Deselect - allow full deselection for both manual and tag-selected images
            selectedImages = selectedImages.filter(id => id !== imageId);
            cardElement.classList.remove('selected', 'manual-selection', 'tag-selection');

            // Remove from selection order tracking and source tracking
            delete imageSelectionOrder[imageId];
            delete imageSelectionSource[imageId];

            // Don't automatically re-select tag images - allow them to be fully deselected
        } else {
            // Select
            selectedImages.push(imageId);
            cardElement.classList.add('selected');

            // Remove pool-deselected class to restore red borders
            cardElement.classList.remove('pool-deselected');

            // Track selection timestamp for ordering (latest first in pool view)
            imageSelectionOrder[imageId] = Date.now();

            // Track as manual selection
            imageSelectionSource[imageId] = 'manual';

            // Update CSS class based on selection type
            cardElement.classList.remove('manual-selection', 'tag-selection');
            if (isTagSelected) {
                cardElement.classList.add('tag-selection');
            } else {
                cardElement.classList.add('manual-selection');
            }
        }

        updateSelectionState();
    }

    function updateSelectionState() {
        selectionCount.textContent = `${selectedImages.length} selected`;
        addToProjectBtn.disabled = selectedImages.length === 0;
        updateButtonVisibility();
        updateClearButtonState(); // Update Clear All button state when selections change
    }

    function isShowingSelectionPool() {
        // We now treat Selection Pool as an explicit view only.
        // Tag searches stay in the main library until the user clicks "View Selection Pool".
        return isPoolView;
    }



    function updateButtonVisibility() {
        console.log('updateButtonVisibility called, isPoolView:', isPoolView, 'selectedImages.length:', selectedImages.length);
        console.log('searchTags.length:', searchTags.length);

        // In pool view, consider both manual and tag selections
        const hasSelections = isPoolView ?
            (selectedImages.length > 0 || tagSelectedImages.length > 0) :
            selectedImages.length > 0;

        console.log('=== BUTTON VISIBILITY DEBUG ===');
        console.log('isPoolView:', isPoolView);
        console.log('selectedImages.length:', selectedImages.length);
        console.log('tagSelectedImages.length:', tagSelectedImages.length);
        console.log('hasSelections calculated:', hasSelections);
        const showingSelectionPool = isShowingSelectionPool();

        // Check if we're actually showing Selection Pool (either explicit pool view OR search results with selections)
        const actuallyShowingSelectionPool = isPoolView || showingSelectionPool;

        if (isPoolView) {
            // Pool view: Show all buttons (Select All, Deselect All, Back to Library, Add to Project)
            viewPoolBtn.classList.add('is-hidden');
            viewPoolBtn.disabled = true;

            backToLibraryBtn.classList.remove('is-hidden');
            backToLibraryBtn.disabled = false;

            // Keep Select All and Deselect All visible in pool view
            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false;

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            // Show Add to Project button in pool view
            addToProjectBtn.classList.remove('is-hidden');
            addToProjectBtn.disabled = !hasSelections; // Dimmed when no selections

            console.log('Pool view - Add to Project button:');
            console.log('  - hidden:', addToProjectBtn.classList.contains('is-hidden'));
            console.log('  - disabled:', addToProjectBtn.disabled);
            console.log('  - hasSelections:', hasSelections);

            console.log('Set buttons for pool view - showing all buttons');
        } else {
            // Library view: Show library controls, hide back button
            viewPoolBtn.classList.remove('is-hidden');
            // Always behave as "View Selection Pool" in library view
            viewPoolBtn.textContent = 'View Selection Pool';
            viewPoolBtn.disabled = !hasSelections; // Dimmed when no selections

            backToLibraryBtn.classList.add('is-hidden');
            backToLibraryBtn.disabled = true;

            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false; // Always enabled in library view

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            // Show Add to Project button in library view when there are selections
            if (hasSelections) {
                addToProjectBtn.classList.remove('is-hidden');
                addToProjectBtn.disabled = false;
                console.log('Library view - Add to Project button SHOWN (has selections)');
            } else {
                addToProjectBtn.classList.add('is-hidden');
                addToProjectBtn.disabled = true;
                console.log('Library view - Add to Project button HIDDEN (no selections)');
            }

            // Hide Update Tag button in library view
            updateTagBtn.classList.add('is-hidden');

            console.log('Set buttons for library view, showingSelectionPool:', showingSelectionPool);
        }

        // Update Tag button: Show when actually displaying Selection Pool (regardless of isPoolView flag)
        if (actuallyShowingSelectionPool && hasSelections) {
            updateTagBtn.classList.remove('is-hidden');
            updateTagBtn.disabled = false;
        } else {
            updateTagBtn.classList.add('is-hidden');
            updateTagBtn.disabled = true;
        }

        // Delete Image button: Show when actually displaying Selection Pool and has selections
        if (actuallyShowingSelectionPool && hasSelections) {
            deleteImageBtn.classList.remove('is-hidden');
            deleteImageBtn.disabled = false;
        } else {
            deleteImageBtn.classList.add('is-hidden');
            deleteImageBtn.disabled = true;
        }

        // Log final button states for debugging
        console.log('Final button states:');
        console.log('viewPoolBtn - hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
        console.log('backToLibraryBtn - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
        console.log('selectAllBtn - hidden:', selectAllBtn.classList.contains('is-hidden'), 'disabled:', selectAllBtn.disabled);
        console.log('deselectAllBtn - hidden:', deselectAllBtn.classList.contains('is-hidden'), 'disabled:', deselectAllBtn.disabled);
        console.log('addToProjectBtn - hidden:', addToProjectBtn.classList.contains('is-hidden'), 'disabled:', addToProjectBtn.disabled);
        console.log('updateTagBtn - hidden:', updateTagBtn.classList.contains('is-hidden'), 'disabled:', updateTagBtn.disabled);
    }

    function selectAllImages() {
        const cards = document.querySelectorAll('.library-card');
        selectedImages = [];
        const currentTimestamp = Date.now();

        cards.forEach(card => {
            const imageId = parseInt(card.dataset.imageId);
            selectedImages.push(imageId);

            // Track selection timestamp for ordering
            imageSelectionOrder[imageId] = currentTimestamp;

            // Track as manual selection (select all is considered manual)
            imageSelectionSource[imageId] = 'manual';

            // Add selected class
            card.classList.add('selected');

            // Remove pool-deselected class to restore red borders
            card.classList.remove('pool-deselected');

            // Determine and apply the correct selection type class
            const isTagSelected = tagSelectedImages.includes(imageId);
            card.classList.remove('manual-selection', 'tag-selection');

            if (isTagSelected) {
                card.classList.add('tag-selection');
            } else {
                card.classList.add('manual-selection');
            }
        });

        updateSelectionState();
    }

    function deselectAllImages() {
        // Safety check: Don't execute if no selections
        if (selectedImages.length === 0) {
            console.warn('deselectAllImages called but no images are selected');
            return;
        }

        const cards = document.querySelectorAll('.library-card');

        // Clear selection timestamps for all deselected images
        selectedImages.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        selectedImages = [];

        cards.forEach(card => {
            if (isPoolView) {
                // In Selection Pool, remove red borders but keep icons
                card.classList.remove('selected');
                card.classList.add('pool-deselected');
            } else {
                // In Library view, remove all selection-related classes completely
                card.classList.remove('selected');
                card.classList.remove('manual-selection');
                card.classList.remove('tag-selection');
                card.classList.remove('pool-deselected');
            }
        });

        updateSelectionState();
    }



    function handleViewPoolClick() {
        // Always explicitly switch to Selection Pool when this button is clicked.
        // Tag searches alone no longer auto-switch the view.
        viewSelectionPool();
    }

    async function viewSelectionPool() {
        console.log('=== viewSelectionPool START ===');
        console.log('selectedImages:', selectedImages);
        console.log('selectedImages.length:', selectedImages.length);

        if (selectedImages.length === 0) {
            alert('No images selected. Please select some images first.');
            return;
        }

        console.log('Setting isPoolView to true');
        isPoolView = true;

        // Update header to show Selection Pool
        updateLibraryTitle(true);

        // Use the main display function which now handles pool view
        await displayLibraryImages();
        console.log('=== viewSelectionPool END ===');
    }

    function showFullLibrary() {
        console.log('=== showFullLibrary START ===');
        console.log('Showing full library while preserving green tag chips for user reference');

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection status for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== showFullLibrary END ===');
    }

    function backToFullLibrary() {
        console.log('=== backToFullLibrary START ===');
        console.log('Returning to full library while preserving green tag chips for user reference');
        console.log('backToFullLibrary called - preserving tagSelectedImages:', tagSelectedImages);

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection history for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== backToFullLibrary END ===');
    }

    function backToLibrary() {
        try {
            console.log('=== backToLibrary START ===');
            console.log('selectedImages before:', selectedImages);
            console.log('searchTags before:', searchTags);
            console.log('tagSelectedImages before:', tagSelectedImages);
            console.log('isPoolView before:', isPoolView);

            // Safety check: Don't execute if button should be disabled
            if (backToLibraryBtn.disabled) {
                console.error('backToLibrary called but button is disabled! This should not happen.');
                console.log('Button state - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                return;
            }

            // Check if we're actually in pool view
            if (!isPoolView) {
                console.warn('backToLibrary called but isPoolView is already false!');
                console.log('Current button states:');
                console.log('viewPoolBtn hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
                console.log('backToLibraryBtn hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                // Force correct button state
                updateButtonVisibility();
                return;
            }

            isPoolView = false;
            forceLibraryView = true; // Prevent auto-switching back to pool view
            console.log('Set isPoolView to false and forceLibraryView to true');
            console.log('About to update title to Library view');

            // Update header back to normal library view
            updateLibraryTitle(false);
            console.log('Title updated to Library view');

            // PRESERVE search tags and selections when going back to library
            // Users should see all their search tags still visible and functional
            if (searchTags.length > 0) {
                console.log('Preserving search tags and all selections in library view');

                // Merge tag-selected images into selectedImages to preserve all selections
                const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];
                selectedImages = allSelectedImages;

                // Update selection source for merged images
                tagSelectedImages.forEach(imageId => {
                    if (!imageSelectionSource[imageId]) {
                        imageSelectionSource[imageId] = 'tag-merged';
                    }
                });

                // Keep tagSelectedImages as they are for proper display in library view
                console.log('Search tags and selections preserved:', selectedImages.length, 'tags:', searchTags.length);
            }

            // Refresh library view (will show all images with preserved selections)
            console.log('Calling displayLibraryImages...');
            displayLibraryImages().then(() => {
                console.log('displayLibraryImages completed successfully');
                console.log('tagSelectedImages after:', tagSelectedImages);
                console.log('=== backToLibrary END ===');
            }).catch(error => {
                console.error('Error in displayLibraryImages:', error);
                alert('Error returning to library. Please refresh the page.');
            });

        } catch (error) {
            console.error('Error in backToLibrary:', error);
            alert('Error returning to library. Please refresh the page.');
        }
    }

    function showProjectNameModal() {
        console.log('Selected images before modal:', selectedImages);
        console.log('Tag-selected images before modal:', tagSelectedImages);

        // Safety check: Don't execute if no selections (check both manual and tag selections)
        const totalSelections = selectedImages.length + tagSelectedImages.length;
        if (totalSelections === 0) {
            console.warn('showProjectNameModal called but no images are selected');
            alert('Please select at least one image.');
            return;
        }

        console.log(`Total selections for project: ${totalSelections} (${selectedImages.length} manual + ${tagSelectedImages.length} tag-based)`);

        projectNameInput.value = '';
        projectNameModal.classList.remove('is-hidden');
        projectNameInput.focus();
    }

    function hideProjectNameModal() {
        projectNameModal.classList.add('is-hidden');
        projectNameInput.value = '';
    }

    function showProjectCreatedModal(projectName, imageCount) {
        projectSuccessMessage.textContent = `Project "${projectName}" created with ${imageCount} images! What would you like to do next?`;
        projectCreatedModal.classList.remove('is-hidden');
    }

    function hideProjectCreatedModal() {
        projectCreatedModal.classList.add('is-hidden');
        lastCreatedProject = null;
    }

    function showProjectDetailModal(project) {
        console.log('=== SHOWPROJECTDETAILMODAL START ===');
        console.log('Opening project detail modal for:', project);

        // Store project ID for reference
        projectDetailModal.dataset.projectId = project.id;

        // Update header information
        projectDetailName.textContent = `üìÅ ${project.name}`;
        projectDetailDate.textContent = `üìÖ Created: ${new Date(project.created_at).toLocaleDateString()}`;
        if (project.ownership && projectDetailOwner) {
            const emailPrefix = getEmailPrefix(project.ownership);
            projectDetailOwner.textContent = `üë§ Created by: ${emailPrefix}`;
            projectDetailOwner.style.display = 'inline';
        } else if (projectDetailOwner) {
            projectDetailOwner.style.display = 'none';
        }

        // Generate detailed count with breakdown using the formatting function
        // Pass the project as fallback for existing projects without breakdown data
        console.log('Project detail - project:', project);
        console.log('Project detail - selection_breakdown:', project.selection_breakdown);
        const countText = formatSelectionBreakdown(project.selection_breakdown, project);
        console.log('Project detail - countText:', countText);
        projectDetailCount.textContent = countText;

        // Get unique tags from project images
        const projectTags = getProjectTags(project.image_ids);
        projectDetailTags.textContent = `üè∑Ô∏è Tags: ${projectTags.join(', ') || 'No tags'}`;

        // Load project images
        loadProjectImages(project.image_ids);

        // Show modal
        projectDetailModal.classList.remove('is-hidden');
    }

    function hideProjectDetailModal() {
        projectDetailModal.classList.add('is-hidden');
        projectDetailGrid.innerHTML = '';
        delete projectDetailModal.dataset.projectId;
    }

    function getProjectTags(imageIds) {
        const allTags = new Set();
        imageIds.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags) {
                image.tags.forEach(tag => allTags.add(tag));
            }
        });
        return Array.from(allTags);
    }

    function generateSelectionBreakdown() {
        // Get current search tags
        const currentSearchTags = searchTags.map(tag => tag.text);

        console.log('generateSelectionBreakdown - currentSearchTags:', currentSearchTags);
        console.log('generateSelectionBreakdown - selectedImages:', selectedImages);
        console.log('generateSelectionBreakdown - imageSelectionSource:', imageSelectionSource);

        // Count images by how they were selected
        const tagCounts = {};
        let manuallySelectedCount = 0;

        selectedImages.forEach(imageId => {
            const selectionSource = imageSelectionSource[imageId];

            if (selectionSource === 'manual') {
                manuallySelectedCount++;
            } else if (selectionSource) {
                // This was selected by a search operation
                // The selectionSource contains the search tags used (comma-separated)
                const searchTagsUsed = selectionSource.split(',');

                // For breakdown, we want to show which specific search tag this image should be attributed to
                // Find which of the current search tags this image actually has
                const image = libraryImages.find(img => img.id === imageId);
                if (image && image.tags) {
                    // Find the first current search tag that this image has
                    const matchingTag = currentSearchTags.find(tag => image.tags.includes(tag));
                    if (matchingTag) {
                        tagCounts[matchingTag] = (tagCounts[matchingTag] || 0) + 1;
                    } else {
                        // Image was selected by search but doesn't match current tags (shouldn't happen)
                        manuallySelectedCount++;
                    }
                } else {
                    manuallySelectedCount++;
                }
            } else {
                // No selection source recorded, treat as manual
                manuallySelectedCount++;
            }
        });

        console.log('generateSelectionBreakdown - tagCounts:', tagCounts);
        console.log('generateSelectionBreakdown - manuallySelectedCount:', manuallySelectedCount);

        return {
            tagCounts,
            manuallySelectedCount,
            totalImages: selectedImages.length
        };
    }

    function generateBreakdownFromProject(project) {
        // For existing projects without breakdown data, analyze the images
        const imageIds = project.image_ids || [];
        const tagCounts = {};
        let totalImages = imageIds.length;

        console.log('generateBreakdownFromProject - imageIds:', imageIds);
        console.log('generateBreakdownFromProject - libraryImages.length:', libraryImages.length);

        // Count images by tag
        imageIds.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            console.log(`Image ${imageId}:`, image ? `found with tags: ${image.tags}` : 'not found');
            if (image && image.tags) {
                image.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        });

        console.log('generateBreakdownFromProject - tagCounts:', tagCounts);

        return {
            tagCounts,
            manuallySelectedCount: 0, // Can't determine for existing projects
            totalImages
        };
    }

    function formatSelectionBreakdown(breakdown, project = null) {
        console.log('formatSelectionBreakdown called with breakdown:', breakdown, 'project:', project);

        // If no breakdown provided, try to generate one from project data
        if (!breakdown && project) {
            console.log('No breakdown provided, generating from project...');
            breakdown = generateBreakdownFromProject(project);
        }

        if (!breakdown) {
            console.log('No breakdown available, using simple format');
            return `üìä Total Images: ${project?.image_ids?.length || 0}`;
        }

        console.log('Using breakdown:', breakdown);

        const tagBreakdowns = [];

        // Add tag counts
        Object.entries(breakdown.tagCounts || {}).forEach(([tag, count]) => {
            tagBreakdowns.push(`${tag} - ${count} image${count !== 1 ? 's' : ''}`);
        });

        // Add manually selected count (only if we have the data)
        if (breakdown.manuallySelectedCount > 0) {
            tagBreakdowns.push(`${breakdown.manuallySelectedCount} manually selected`);
        }

        // If no tag breakdowns but we have images, they must be manually selected (for existing projects)
        if (tagBreakdowns.length === 0 && breakdown.totalImages > 0 && !breakdown.tagCounts) {
            tagBreakdowns.push(`${breakdown.totalImages} manually selected`);
        }

        let result = `üìä Total Images: ${breakdown.totalImages}`;
        if (tagBreakdowns.length > 0) {
            result += ` (${tagBreakdowns.join(', ')})`;
        }

        console.log('Final formatted result:', result);
        return result;
    }

    async function loadProjectImages(imageIds) {
        projectDetailGrid.innerHTML = '';

        try {
            // Get all images from API
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images`, {
                headers: headers
            });
            if (!response.ok) throw new Error('Failed to fetch images');
            const allImages = await response.json();

            // Filter to only project images
            const projectImages = allImages.filter(img => imageIds.includes(img.id));

            projectImages.forEach(image => {
                const card = document.createElement('div');
                card.className = 'project-image-card';

                const img = document.createElement('img');
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                img.alt = `Image ${image.id}`;

                // Test image loading before displaying
                const testImg = new Image();
                testImg.onload = () => {
                    img.src = imageSrc;

                    // Add click handler for lightbox
                    img.addEventListener('click', () => {
                        // Open lightbox for this image
                        openProjectImageLightbox(image, projectImages);
                    });

                    card.appendChild(img);
                };
                testImg.onerror = () => {
                    // Skip broken images in project view
                    console.warn(`Project image failed to load: ${imageSrc} (ID: ${image.id})`);
                    // Don't append the img to the card
                };
                testImg.src = imageSrc;

                // Add tag overlay - show tags on project images (same style as library)
                const imageTags = image.tags || [];
                if (imageTags.length > 0) {
                    const tagOverlay = document.createElement('div');
                    tagOverlay.className = 'tag-overlay';

                    // Show first 3 tags for project images
                    tagOverlay.textContent = imageTags.slice(0, 3).join(', ');
                    if (imageTags.length > 3) {
                        tagOverlay.textContent += ` +${imageTags.length - 3}`;
                    }

                    card.appendChild(tagOverlay);
                }

                // Create icons container
                const iconsContainer = document.createElement('div');
                iconsContainer.className = 'project-image-icons';

                // Determine selection type and add appropriate icons
                const isTagSelected = tagSelectedImages.includes(image.id);
                const isManualSelected = selectedImages.includes(image.id) && !isTagSelected;

                if (isTagSelected) {
                    const tagIcon = document.createElement('div');
                    tagIcon.className = 'project-image-icon';
                    tagIcon.textContent = 'üè∑Ô∏è';
                    tagIcon.title = 'Selected by tags';
                    iconsContainer.appendChild(tagIcon);
                }

                if (isManualSelected) {
                    const handIcon = document.createElement('div');
                    handIcon.className = 'project-image-icon';
                    handIcon.textContent = 'üëÜ';
                    handIcon.title = 'Manually selected';
                    iconsContainer.appendChild(handIcon);
                }

                if (iconsContainer.children.length > 0) {
                    card.appendChild(iconsContainer);
                }

                projectDetailGrid.appendChild(card);
            });

        } catch (error) {
            console.error('Error loading project images:', error);
            projectDetailGrid.innerHTML = '<p>Error loading project images.</p>';
        }
    }

    function openProjectImageLightbox(image, projectImages) {
        // Set up lightbox for project images with proper src format
        const imageIndex = projectImages.findIndex(img => img.id === image.id);

        // Format project images for lightbox (add src property)
        const formattedImages = projectImages.map(img => ({
            ...img,
            src: `${API_URL}/${img.filepath.replace(/\\/g, '/')}`
        }));

        // Temporarily set for lightbox navigation
        libraryImages = formattedImages;
        openLibraryLightbox(imageIndex);
    }

    function filterProjects(searchTerm) {
        const projectCards = document.querySelectorAll('.project-card');
        projectCards.forEach(card => {
            const projectTitle = card.querySelector('.project-title').textContent.toLowerCase();
            if (projectTitle.includes(searchTerm)) {
                card.style.display = 'block';
            } else {
                card.style.display = 'none';
            }
        });
    }

    // Image Preview Overlay Functions
    function showImagePreviewOverlay(imageSrc, image) {
        // Set up regular library preview (no navigation)
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = image ? `Full size preview of image ${image.id}` : 'Full size preview';

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        imagePreviewOverlay.classList.add('show');

        // Hide navigation arrows for regular library view
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');

        // Prevent body scrolling when overlay is open (but allow overlay scrolling)
        document.body.style.overflow = 'hidden';

        // Add pan event listeners
        addPanEventListeners();

        if (image) {
            console.log('Regular image preview overlay opened for image:', image.id);
        } else {
            console.log('Image preview overlay opened for uploaded image');
        }
    }

    function hideImagePreviewOverlay() {
        imagePreviewOverlay.classList.remove('show');
        previewOverlayImg.src = '';

        // Restore body scrolling
        document.body.style.overflow = '';

        // Remove pan event listeners
        removePanEventListeners();

        // Reset Selection Pool preview state
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        // Hide navigation arrows
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');

        // Hide real-size specific elements
        document.getElementById('preview-overlay-settings').classList.add('hidden');
        document.getElementById('preview-dimension-info').classList.add('hidden');
        previewOverlayImg.style.width = '';
        previewOverlayImg.style.height = '';
        previewOverlayImg.style.maxWidth = '';
        previewOverlayImg.style.maxHeight = '';

        // Remove floating frequency panel if present
        const freqFloating = document.getElementById('lightbox-freq-floating');
        if (freqFloating) {
            freqFloating.remove();
        }
        // Clear pending adds on close
        pendingAddTags.clear();
    }

    // Show real-size overlay (strict 1:1 based on mm dimensions)
    function showRealSizeOverlay(imageSrc, image) {
        if (!image || (!image.width && !image.length)) {
            console.warn('Cannot show real size: no dimensions available');
            return;
        }

        const widthMm = parseFloat(image.width);
        const lengthMm = parseFloat(image.length);
        const currentDPI = getCurrentDPI();

        // Calculate pixel dimensions
        const widthPx = widthMm ? mmToPixels(widthMm, currentDPI) : null;
        const lengthPx = lengthMm ? mmToPixels(lengthMm, currentDPI) : null;

        // Set image source
        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = image.id ? `Real size preview of image ${image.id}` : 'Real size preview';

        // Set strict dimensions (no zoom, no scaling)
        if (widthPx && lengthPx) {
            // Use the larger dimension to determine orientation
            if (widthPx > lengthPx) {
                previewOverlayImg.style.width = `${widthPx}px`;
                previewOverlayImg.style.height = `${lengthPx}px`;
            } else {
                previewOverlayImg.style.width = `${widthPx}px`;
                previewOverlayImg.style.height = `${lengthPx}px`;
            }
            previewOverlayImg.style.maxWidth = `${widthPx}px`;
            previewOverlayImg.style.maxHeight = `${lengthPx}px`;
        } else if (widthPx) {
            previewOverlayImg.style.width = `${widthPx}px`;
            previewOverlayImg.style.height = 'auto';
            previewOverlayImg.style.maxWidth = `${widthPx}px`;
            previewOverlayImg.style.maxHeight = 'none';
        } else if (lengthPx) {
            previewOverlayImg.style.width = 'auto';
            previewOverlayImg.style.height = `${lengthPx}px`;
            previewOverlayImg.style.maxWidth = 'none';
            previewOverlayImg.style.maxHeight = `${lengthPx}px`;
        }

        // Show overlay first
        imagePreviewOverlay.classList.add('show');

        // Center the image after it loads
        const centerImage = () => {
            const overlay = imagePreviewOverlay;
            const content = document.querySelector('.image-preview-content');
            if (content && previewOverlayImg.complete) {
                // Calculate center position for scrolling
                const scrollLeft = Math.max(0, (content.scrollWidth - overlay.clientWidth) / 2);
                const scrollTop = Math.max(0, (content.scrollHeight - overlay.clientHeight) / 2);
                overlay.scrollLeft = scrollLeft;
                overlay.scrollTop = scrollTop;
            }
        };

        // Center immediately if image already loaded, otherwise wait for load
        if (previewOverlayImg.complete) {
            setTimeout(centerImage, 50);
        } else {
            previewOverlayImg.onload = () => {
                setTimeout(centerImage, 50);
            };
        }

        // Hide navigation arrows
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');

        // Show settings button and dimension info
        const settingsBtn = document.getElementById('preview-overlay-settings');
        const dimensionInfo = document.getElementById('preview-dimension-info');
        
        settingsBtn.classList.remove('hidden');
        dimensionInfo.classList.remove('hidden');

        // Update dimension info
        const dimensionText = [];
        if (widthMm) dimensionText.push(`Width: ${widthMm}mm`);
        if (lengthMm) dimensionText.push(`Length: ${lengthMm}mm`);
        dimensionText.push(`(Real Size)`);
        dimensionInfo.innerHTML = `
            <div class="dimension-text">${dimensionText.join(' √ó ')}</div>
            <div class="dpi-text">Detected DPI: ${currentDPI.toFixed(1)}</div>
        `;

        // Prevent body scrolling
        document.body.style.overflow = 'hidden';

        // Add pan event listeners
        addPanEventListeners();

        console.log('Real size overlay opened:', {
            widthMm,
            lengthMm,
            widthPx,
            lengthPx,
            dpi: currentDPI
        });
    }

    // Pan functionality variables
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    // Pan functionality functions
    function addPanEventListeners() {
        imagePreviewOverlay.addEventListener('mousedown', startPan);
        imagePreviewOverlay.addEventListener('mousemove', doPan);
        imagePreviewOverlay.addEventListener('mouseup', endPan);
        imagePreviewOverlay.addEventListener('mouseleave', endPan);

        // Prevent default drag behavior on images
        previewOverlayImg.addEventListener('dragstart', (e) => e.preventDefault());
    }

    function removePanEventListeners() {
        imagePreviewOverlay.removeEventListener('mousedown', startPan);
        imagePreviewOverlay.removeEventListener('mousemove', doPan);
        imagePreviewOverlay.removeEventListener('mouseup', endPan);
        imagePreviewOverlay.removeEventListener('mouseleave', endPan);
    }

    function startPan(e) {
        // Don't start panning if clicking on the close button
        if (e.target.id === 'preview-overlay-close') return;

        isPanning = true;
        imagePreviewOverlay.classList.add('panning');

        startX = e.clientX;
        startY = e.clientY;
        scrollLeft = imagePreviewOverlay.scrollLeft;
        scrollTop = imagePreviewOverlay.scrollTop;

        e.preventDefault();
    }

    function doPan(e) {
        if (!isPanning) return;

        e.preventDefault();

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        imagePreviewOverlay.scrollLeft = scrollLeft - deltaX;
        imagePreviewOverlay.scrollTop = scrollTop - deltaY;
    }

    function endPan() {
        isPanning = false;
        imagePreviewOverlay.classList.remove('panning');
    }

    // Selection Pool Preview Functions
    function showSelectionPoolPreview(clickedImage, allImages, clickedIndex) {
        console.log('showSelectionPoolPreview called with:', {
            clickedImage: clickedImage.id,
            allImagesCount: allImages.length,
            clickedIndex: clickedIndex
        });

        // Set up navigation data
        currentPreviewImages = allImages;
        currentPreviewIndex = clickedIndex;
        isSelectionPoolPreview = true;

        // Show the clicked image
        const imageSrc = `${API_URL}/${clickedImage.filepath.replace(/\\/g, '/')}`;
        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = `Full size preview of image ${clickedImage.id}`;

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        // Show overlay first
        imagePreviewOverlay.classList.add('show');

        // Update navigation arrows visibility (after overlay is shown)
        updateNavigationArrows();

        // Prevent body scrolling and add pan functionality
        document.body.style.overflow = 'hidden';
        addPanEventListeners();

        console.log('Selection Pool preview opened for image:', clickedImage.id, 'at index:', clickedIndex);
        console.log('Navigation arrows should be visible now');
    }

    function updateNavigationArrows() {
        console.log('updateNavigationArrows called:', {
            currentPreviewIndex: currentPreviewIndex,
            totalImages: currentPreviewImages.length,
            isSelectionPoolPreview: isSelectionPoolPreview
        });

        if (!isSelectionPoolPreview) {
            // Hide arrows for regular library preview
            previewNavLeft.classList.add('hidden');
            previewNavRight.classList.add('hidden');
            console.log('Hiding arrows - not Selection Pool preview');
            return;
        }

        // Show/hide arrows based on current position in Selection Pool
        if (currentPreviewIndex <= 0) {
            previewNavLeft.classList.add('hidden');
            console.log('Hiding left arrow - at first image');
        } else {
            previewNavLeft.classList.remove('hidden');
            console.log('Showing left arrow');
        }

        if (currentPreviewIndex >= currentPreviewImages.length - 1) {
            previewNavRight.classList.add('hidden');
            console.log('Hiding right arrow - at last image');
        } else {
            previewNavRight.classList.remove('hidden');
            console.log('Showing right arrow');
        }

        console.log('Navigation arrows updated');
    }

    function navigatePreview(direction) {
        if (!isSelectionPoolPreview) return;

        let newIndex = currentPreviewIndex;

        if (direction === 'left' && currentPreviewIndex > 0) {
            newIndex = currentPreviewIndex - 1;
        } else if (direction === 'right' && currentPreviewIndex < currentPreviewImages.length - 1) {
            newIndex = currentPreviewIndex + 1;
        }

        if (newIndex !== currentPreviewIndex) {
            currentPreviewIndex = newIndex;
            const newImage = currentPreviewImages[newIndex];
            const newImageSrc = `${API_URL}/${newImage.filepath.replace(/\\/g, '/')}`;

            previewOverlayImg.src = newImageSrc;
            previewOverlayImg.alt = `Full size preview of image ${newImage.id}`;

            // Reset scroll position for new image
            imagePreviewOverlay.scrollTop = 0;
            imagePreviewOverlay.scrollLeft = 0;

            // Update arrow visibility
            updateNavigationArrows();

            console.log('Navigated to image:', newImage.id, 'at index:', newIndex);
        }
    }

    async function createProject() {
        const projectName = projectNameInput.value.trim();

        // Combine both manual and tag-based selections
        const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];

        console.log('Creating project with selected images:', selectedImages);
        console.log('Creating project with tag-selected images:', tagSelectedImages);
        console.log('Creating project with combined images:', allSelectedImages);

        if (!projectName) {
            alert('Please enter a project name.');
            return;
        }

        // Check if we have selected images (check combined selections)
        if (allSelectedImages.length === 0) {
            alert('Please select at least one image before creating a project.');
            return;
        }

        // Check if project name already exists
        if (projects.some(p => p.name.toLowerCase() === projectName.toLowerCase())) {
            alert('A project with this name already exists.');
            return;
        }

        // Store the count before clearing selection
        const imageCount = allSelectedImages.length;

        try {
            // Generate selection breakdown before saving
            const breakdown = generateSelectionBreakdown();
            const newProject = await saveProjectToAPI(projectName, [...allSelectedImages], breakdown);
            displayProjects();

            // Store the created project for navigation
            lastCreatedProject = newProject;

            // Hide project name modal first, then clear selection
            hideProjectNameModal();
            deselectAllImages();

            // Show success confirmation modal
            showProjectCreatedModal(projectName, imageCount);
        } catch (error) {
            alert('Failed to create project. Please try again.');
        }
    }

    async function loadProjectsFromAPI() {
        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/projects`, {
                headers: headers
            });
            if (response.ok) {
                projects = await response.json();
                console.log('Loaded projects from API:', projects.length);
            } else {
                console.error('Failed to load projects:', response.statusText);
                projects = [];
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            projects = [];
        }
    }

    async function saveProjectToAPI(projectName, imageIds, breakdown = null) {
        try {
            const projectData = {
                name: projectName,
                image_ids: imageIds
            };

            // Add breakdown metadata if provided
            if (breakdown) {
                projectData.selection_breakdown = breakdown;
            }

            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json',
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/projects`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(projectData)
            });

            if (response.ok) {
                const newProject = await response.json();
                projects.push(newProject);
                console.log('Project saved to API:', newProject);
                return newProject;
            } else {
                console.error('Failed to save project:', response.statusText);
                throw new Error('Failed to save project');
            }
        } catch (error) {
            console.error('Error saving project:', error);
            throw error;
        }
    }

    async function deleteProjectFromAPI(projectId) {
        try {
            const response = await fetch(`${API_URL}/projects/${projectId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                projects = projects.filter(p => p.id !== projectId);
                console.log('Project deleted from API:', projectId);
                return true;
            } else {
                console.error('Failed to delete project:', response.statusText);
                throw new Error('Failed to delete project');
            }
        } catch (error) {
            console.error('Error deleting project:', error);
            throw error;
        }
    }

    function toggleProjectView() {
        isDetailedProjectView = !isDetailedProjectView;

        // Update toggle button appearance
        if (isDetailedProjectView) {
            projectViewToggleBtn.classList.add('detailed-mode');
            toggleIcon.textContent = 'üìä';
            toggleText.textContent = 'Present View';
        } else {
            projectViewToggleBtn.classList.remove('detailed-mode');
            toggleIcon.textContent = 'üìã';
            toggleText.textContent = 'Detailed View';
        }

        // Update project list classes
        if (isDetailedProjectView) {
            projectList.classList.add('detailed-view');
        } else {
            projectList.classList.remove('detailed-view');
        }

        // Refresh the project display
        displayProjects();
    }

    async function toggleEmailHistory(projectId, toggleButton, emailList) {
        if (emailList.classList.contains('expanded')) {
            // Collapse
            emailList.classList.remove('expanded');
            toggleButton.textContent = 'Show All';
        } else {
            // Expand and load email history
            try {
                const response = await fetch(`${API_URL}/projects/${projectId}/email-history`);
                if (response.ok) {
                    const emailHistory = await response.json();

                    emailList.innerHTML = '';

                    if (emailHistory.length === 0) {
                        emailList.innerHTML = '<div class="email-history-item">No emails sent yet</div>';
                    } else {
                        emailHistory.forEach(email => {
                            const emailItem = document.createElement('div');
                            emailItem.className = 'email-history-item';

                            const date = new Date(email.sent_at);
                            const statusClass = email.success ? 'success' : 'failed';
                            const statusText = email.success ? 'Sent' : 'Failed';

                            emailItem.innerHTML = `
                                <div class="email-recipient">${email.recipient_email}</div>
                                <div class="email-date">${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                                <span class="email-status ${statusClass}">${statusText}</span>
                            `;

                            emailList.appendChild(emailItem);
                        });
                    }

                    emailList.classList.add('expanded');
                    toggleButton.textContent = 'Hide All';
                } else {
                    console.error('Failed to load email history');
                    emailList.innerHTML = '<div class="email-history-item">Failed to load email history</div>';
                    emailList.classList.add('expanded');
                    toggleButton.textContent = 'Hide All';
                }
            } catch (error) {
                console.error('Error loading email history:', error);
                emailList.innerHTML = '<div class="email-history-item">Error loading email history</div>';
                emailList.classList.add('expanded');
                toggleButton.textContent = 'Hide All';
            }
        }
    }

    async function loadLastEmailInfo(projectId, emailSection) {
        console.log('=== LOAD LAST EMAIL INFO START ===');
        console.log('Loading last email info for project:', projectId);

        try {
            const response = await fetch(`${API_URL}/projects/${projectId}/email-history`);
            console.log('Email history API response status:', response.status);

            if (response.ok) {
                const emailHistory = await response.json();
                console.log('Email history data:', emailHistory);

                if (emailHistory.length > 0) {
                    const lastEmail = emailHistory[0]; // Most recent email
                    console.log('Last email:', lastEmail);

                    const lastEmailRow = document.createElement('div');
                    lastEmailRow.className = 'project-detail-row';

                    const date = new Date(lastEmail.sent_at);
                    const statusText = lastEmail.success ? '‚úÖ' : '‚ùå';

                    lastEmailRow.innerHTML = `<strong>üìß Last email:</strong> ${lastEmail.recipient_email} (${date.toLocaleDateString()}) ${statusText}`;
                    emailSection.appendChild(lastEmailRow);
                    console.log('Last email row added to section');
                } else {
                    console.log('No email history found');
                    const noEmailRow = document.createElement('div');
                    noEmailRow.className = 'project-detail-row';
                    noEmailRow.innerHTML = '<strong>üìß Last email:</strong> No emails sent yet';
                    emailSection.appendChild(noEmailRow);
                }
            } else {
                console.log('Email history API failed:', response.status);
            }
        } catch (error) {
            console.error('Error loading last email info:', error);
        }

        console.log('=== LOAD LAST EMAIL INFO END ===');
    }

    async function displayProjects() {
        if (projects.length === 0) {
            projectList.innerHTML = '<p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>';
            return;
        }

        projectList.innerHTML = '';

        // Sort projects by creation date - latest first (top-left corner)
        const sortedProjects = [...projects].sort((a, b) => {
            // Sort by ID in descending order (assuming higher ID = more recent)
            return b.id - a.id;
        });

        for (const project of sortedProjects) {
            const projectCard = document.createElement('div');
            projectCard.className = isDetailedProjectView ? 'project-card detailed-view' : 'project-card';

            // Project card header with title and metadata
            const cardHeader = document.createElement('div');
            cardHeader.className = 'project-card-header';

            const titleSection = document.createElement('div');
            titleSection.className = 'project-title-section';

            const projectTitle = document.createElement('h3');
            projectTitle.className = 'project-title';
            projectTitle.textContent = project.name;

            if (isDetailedProjectView) {
                // Detailed view: Show comprehensive information
                const detailedInfo = document.createElement('div');
                detailedInfo.className = 'project-detailed-info';

                // Creation date
                const date = new Date(project.created_at);
                const dateRow = document.createElement('div');
                dateRow.className = 'project-detail-row';
                dateRow.innerHTML = `<strong>üìÖ Created:</strong> ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                detailedInfo.appendChild(dateRow);

                // Image count
                const countRow = document.createElement('div');
                countRow.className = 'project-detail-row';
                countRow.innerHTML = `<strong>üìä Images:</strong> ${project.image_ids.length} images`;
                detailedInfo.appendChild(countRow);

                // Creator/Owner
                if (project.ownership) {
                    const ownerRow = document.createElement('div');
                    ownerRow.className = 'project-detail-row';
                    const emailPrefix = getEmailPrefix(project.ownership);
                    ownerRow.innerHTML = `<strong>üë§ Created by:</strong> ${emailPrefix}`;
                    detailedInfo.appendChild(ownerRow);
                }

                // Email history section
                const emailSection = document.createElement('div');
                emailSection.className = 'email-history-section';

                // Load and show last email info immediately
                loadLastEmailInfo(project.id, emailSection);

                const emailHeader = document.createElement('div');
                emailHeader.className = 'email-history-header';
                emailHeader.innerHTML = '<strong>üìß Email History:</strong>';

                const emailToggle = document.createElement('button');
                emailToggle.className = 'email-history-toggle';
                emailToggle.textContent = 'Show All';
                emailToggle.dataset.projectId = project.id;

                const emailList = document.createElement('div');
                emailList.className = 'email-history-list';
                emailList.id = `email-history-${project.id}`;

                emailToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleEmailHistory(project.id, emailToggle, emailList);
                });

                emailHeader.appendChild(emailToggle);
                emailSection.appendChild(emailHeader);
                emailSection.appendChild(emailList);
                detailedInfo.appendChild(emailSection);

                titleSection.appendChild(projectTitle);
                titleSection.appendChild(detailedInfo);
            } else {
                // Present view: Show basic metadata
                const projectMeta = document.createElement('div');
                projectMeta.className = 'project-meta';

                const imageCount = document.createElement('span');
                imageCount.className = 'project-image-count';
                imageCount.textContent = `${project.image_ids.length} images`;

                const createdDate = document.createElement('span');
                createdDate.className = 'project-created-date';
                const date = new Date(project.created_at);
                createdDate.textContent = `Created ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

                const creatorEmail = document.createElement('span');
                creatorEmail.className = 'project-creator-email';
                if (project.ownership) {
                    const emailPrefix = getEmailPrefix(project.ownership);
                    creatorEmail.textContent = `by ${emailPrefix}`;
                }

                projectMeta.appendChild(imageCount);
                projectMeta.appendChild(createdDate);
                if (project.ownership) {
                    projectMeta.appendChild(creatorEmail);
                }
                titleSection.appendChild(projectTitle);
                titleSection.appendChild(projectMeta);
            }

            const actionSection = document.createElement('div');
            actionSection.className = 'project-actions';

            const shareBtn = document.createElement('button');
            shareBtn.className = 'button share-project-btn';
            shareBtn.innerHTML = '';
            shareBtn.title = 'Share project via email';
            shareBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                showShareProjectModal(project);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'button delete-project-btn';
            deleteBtn.innerHTML = 'üóëÔ∏è';
            deleteBtn.title = 'Delete project';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                deleteProject(project.id);
            });

            actionSection.appendChild(shareBtn);
            actionSection.appendChild(deleteBtn);
            cardHeader.appendChild(titleSection);
            cardHeader.appendChild(actionSection);

            // Only show image preview in present view
            if (!isDetailedProjectView) {
                // Project images preview (first few images)
                const projectPreview = document.createElement('div');
                projectPreview.className = 'project-preview';

                // Get image data for this project
                try {
                    const sessionToken = localStorage.getItem('sessionToken');
                    const headers = {};
                    if (sessionToken) {
                        headers['Authorization'] = `Bearer ${sessionToken}`;
                    }
                    const response = await fetch(`${API_URL}/images`, {
                        headers: headers
                    });
                    const allImages = await response.json();
                    const projectImageData = allImages.filter(img => project.image_ids.includes(img.id));

                    // Show first 6 images as preview
                    const previewImages = projectImageData.slice(0, 6);
                    previewImages.forEach(image => {
                        const previewImg = document.createElement('img');
                        previewImg.className = 'project-preview-image';
                        previewImg.src = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                        projectPreview.appendChild(previewImg);
                    });

                    // Add "more" indicator if there are more images
                    if (projectImageData.length > 6) {
                        const moreIndicator = document.createElement('div');
                        moreIndicator.className = 'project-more-indicator';
                        moreIndicator.textContent = `+${projectImageData.length - 6} more`;
                        projectPreview.appendChild(moreIndicator);
                    }
                } catch (error) {
                    console.error('Error loading project images:', error);
                }

                projectCard.appendChild(cardHeader);
                projectCard.appendChild(projectPreview);
            } else {
                // Detailed view: Only show header
                projectCard.appendChild(cardHeader);
            }

            // Add click handler to open project detail modal
            projectCard.addEventListener('click', () => {
                showProjectDetailModal(project);
            });

            // Make project card look clickable
            projectCard.style.cursor = 'pointer';

            projectList.appendChild(projectCard);
        }
    }

    async function deleteProject(projectId) {
        const project = projects.find(p => p.id === projectId);
        if (project && confirm(`Are you sure you want to delete the project "${project.name}"?`)) {
            try {
                await deleteProjectFromAPI(projectId);
                displayProjects();
            } catch (error) {
                alert('Failed to delete project. Please try again.');
            }
        }
    }

    async function refreshEmailHistoryDisplays(projectId) {
        console.log('=== REFRESH EMAIL HISTORY START ===');
        console.log('Refreshing email history displays for project:', projectId);
        console.log('isDetailedProjectView:', isDetailedProjectView);
        console.log('projectDetailModal hidden:', projectDetailModal.classList.contains('is-hidden'));

        // 1. Update email history in detailed project view
        if (isDetailedProjectView) {
            console.log('Updating email history in detailed project view');
            await updateProjectEmailHistory(projectId);
        }

        // 2. Refresh project detail modal if it's open for this project
        if (!projectDetailModal.classList.contains('is-hidden')) {
            const currentProjectId = projectDetailModal.dataset.projectId;
            console.log('Current modal project ID:', currentProjectId, 'Target project ID:', projectId);
            if (currentProjectId == projectId) {
                console.log('Refreshing project detail modal');
                const project = projects.find(p => p.id == projectId);
                if (project) {
                    showProjectDetailModal(project);
                } else {
                    console.log('Project not found in projects array');
                }
            } else {
                console.log('Modal is open but for different project');
            }
        }

        console.log('=== REFRESH EMAIL HISTORY END ===');
    }

    async function updateProjectEmailHistory(projectId) {
        console.log('=== UPDATE PROJECT EMAIL HISTORY START ===');
        console.log('Updating email history for project:', projectId);

        // Find the project card for this project ID
        const projectCards = document.querySelectorAll('.project-card.detailed-view');

        for (const card of projectCards) {
            // Find the email history section in this card
            const emailSection = card.querySelector('.email-history-section');
            if (emailSection) {
                // Check if this card is for the target project by looking at the toggle button
                const toggleButton = emailSection.querySelector('.email-history-toggle');
                if (toggleButton && toggleButton.dataset.projectId == projectId) {
                    console.log('Found matching project card, updating email history');

                    // Clear existing last email info
                    const existingEmailRow = emailSection.querySelector('.project-detail-row');
                    if (existingEmailRow) {
                        existingEmailRow.remove();
                    }

                    // Add updated last email info
                    await loadLastEmailInfo(projectId, emailSection);

                    // If email history is expanded, refresh it too
                    const emailList = emailSection.querySelector('.email-history-list');
                    if (emailList && emailList.classList.contains('expanded')) {
                        console.log('Email history is expanded, refreshing list');
                        await toggleEmailHistory(projectId, toggleButton, emailList);
                        await toggleEmailHistory(projectId, toggleButton, emailList); // Toggle twice to refresh
                    }

                    break;
                }
            }
        }

        console.log('=== UPDATE PROJECT EMAIL HISTORY END ===');
    }

    // Autocomplete Functions
    async function showAutocomplete(query) {
        if (query.length < 2) {
            hideAutocomplete();
            return;
        }

        try {
            const response = await fetch(`${API_URL}/tags?q=${encodeURIComponent(query)}`);
            if (!response.ok) {
                throw new Error('Failed to fetch tags');
            }

            const tags = await response.json();
            autocompleteItems = tags.slice(0, 10); // Limit to 10 suggestions

            if (autocompleteItems.length === 0) {
                hideAutocomplete();
                return;
            }

            renderAutocomplete();
            autocompleteDropdown.classList.add('show');
            autocompleteVisible = true;
            autocompleteHighlightIndex = -1;

        } catch (error) {
            console.error('Error fetching autocomplete suggestions:', error);
            hideAutocomplete();
        }
    }

    function renderAutocomplete() {
        autocompleteDropdown.innerHTML = '';

        autocompleteItems.forEach((tag, index) => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.dataset.index = index;

            item.innerHTML = `
                <span class="autocomplete-item-name">${tag.name}</span>
                <span class="autocomplete-item-count">${tag.usage_count}</span>
            `;

            item.addEventListener('click', () => {
                selectAutocompleteItem(tag.name);
            });

            autocompleteDropdown.appendChild(item);
        });
    }

    function hideAutocomplete() {
        autocompleteDropdown.classList.remove('show');
        autocompleteVisible = false;
        autocompleteHighlightIndex = -1;
        autocompleteItems = [];
    }

    function selectAutocompleteItem(tagName) {
        const currentValue = librarySearchInput.value;
        const lastCommaIndex = currentValue.lastIndexOf(',');

        let newValue;
        if (lastCommaIndex === -1) {
            // No comma, replace entire value
            newValue = tagName;
        } else {
            // Replace text after last comma
            newValue = currentValue.substring(0, lastCommaIndex + 1) + ' ' + tagName;
        }

        librarySearchInput.value = newValue;
        hideAutocomplete();
        librarySearchInput.focus();
    }

    function highlightAutocompleteItem(direction) {
        if (!autocompleteVisible || autocompleteItems.length === 0) return;

        // Remove previous highlight
        const items = autocompleteDropdown.querySelectorAll('.autocomplete-item');
        items.forEach(item => item.classList.remove('highlighted'));

        // Update highlight index
        if (direction === 'down') {
            autocompleteHighlightIndex = Math.min(autocompleteHighlightIndex + 1, autocompleteItems.length - 1);
        } else if (direction === 'up') {
            autocompleteHighlightIndex = Math.max(autocompleteHighlightIndex - 1, -1);
        }

        // Apply new highlight
        if (autocompleteHighlightIndex >= 0) {
            items[autocompleteHighlightIndex].classList.add('highlighted');
        }
    }

    function selectHighlightedItem() {
        if (autocompleteHighlightIndex >= 0 && autocompleteHighlightIndex < autocompleteItems.length) {
            selectAutocompleteItem(autocompleteItems[autocompleteHighlightIndex].name);
            return true;
        }
        return false;
    }

    // Authentication Functions
    async function checkAuthentication() {
        const sessionToken = localStorage.getItem('sessionToken');

        if (!sessionToken) {
            window.location.href = '/login.html';
            return false;
        }

        try {
            const response = await fetch(`${API_URL}/auth/verify-session`, {
                headers: { 'Authorization': `Bearer ${sessionToken}` }
            });

            if (!response.ok) {
                localStorage.removeItem('sessionToken');
                window.location.href = '/login.html';
                return false;
            }

            const result = await response.json();
            currentUser = result.user;

            // Show/hide admin menu item based on admin role
            const adminLink = document.getElementById('nav-admin');
            const settingsLink = document.getElementById('nav-settings');
            if (currentUser.role === 'admin') {
                if (adminLink) adminLink.classList.remove('is-hidden');
                if (settingsLink) settingsLink.style.display = 'block';
            } else {
                if (adminLink) adminLink.classList.add('is-hidden');
                if (settingsLink) settingsLink.style.display = 'none';
            }

            // Update email display in headers
            updateUserEmailDisplay();

            return true;

        } catch (error) {
            console.error('Authentication check failed:', error);
            localStorage.removeItem('sessionToken');
            window.location.href = '/login.html';
            return false;
        }
    }

    function updateUserEmailDisplay() {
        const emailDisplays = [
            document.getElementById('user-email-display'),
            document.getElementById('user-email-display-upload'),
            document.getElementById('user-email-display-project'),
            document.getElementById('user-email-display-admin')
        ];

        const email = currentUser ? currentUser.email : '';
        
        emailDisplays.forEach(display => {
            if (display) {
                display.textContent = email;
                display.style.display = email ? 'block' : 'none';
            }
        });
    }

    function openSettings() {
        if (currentUser && currentUser.role === 'admin') {
            navigateTo('admin');
        } else {
            alert('Admin access required');
        }
    }

    // Admin Panel Functions
    async function loadAdminUsers() {
        const sessionToken = localStorage.getItem('sessionToken');
        const adminLoading = document.getElementById('admin-loading');
        const adminUsersContent = document.getElementById('admin-users-content');
        const adminMessage = document.getElementById('admin-message');
        
        if (!sessionToken) {
            window.location.href = '/login.html';
            return;
        }

        adminLoading.classList.remove('hidden');
        adminUsersContent.classList.add('hidden');
        adminMessage.classList.add('hidden');

        try {
            const response = await fetch(`${API_URL}/admin/users`, {
                headers: { 'Authorization': `Bearer ${sessionToken}` }
            });
            
            if (response.status === 401 || response.status === 403) {
                window.location.href = '/login.html';
                return;
            }
            
            if (!response.ok) {
                throw new Error('Failed to load users');
            }
            
            const users = await response.json();
            displayAdminUsers(users);
            
        } catch (error) {
            console.error('Error loading users:', error);
            showAdminMessage('Failed to load users', 'error');
        } finally {
            adminLoading.classList.add('hidden');
            adminUsersContent.classList.remove('hidden');
        }
    }

    function displayAdminUsers(users) {
        const usersTbody = document.getElementById('admin-users-tbody');
        usersTbody.innerHTML = '';
        
        const sessionToken = localStorage.getItem('sessionToken');
        
        users.forEach(user => {
            const row = document.createElement('tr');
            
            const statusClass = `status-${user.status}`;
            const level = parseInt(user.level, 10) || 1;
            
            row.innerHTML = `
                <td>${user.email}</td>
                <td><span class="status-badge ${statusClass}">${user.status}</span></td>
                <td>${formatAdminDate(user.created_at)}</td>
                <td>${formatAdminDate(user.last_login)}</td>
                <td>
                    <select class="admin-user-level-select" data-user-id="${user.id}">
                        <option value="1" ${level === 1 ? 'selected' : ''}>Level 1</option>
                        <option value="2" ${level === 2 ? 'selected' : ''}>Level 2</option>
                        <option value="3" ${level === 3 ? 'selected' : ''}>Level 3</option>
                    </select>
                </td>
                <td>
                    <button type="button" class="admin-user-delete-btn" data-user-id="${user.id}" data-user-email="${user.email}">Delete</button>
                </td>
            `;
            
            const levelSelect = row.querySelector('.admin-user-level-select');
            if (levelSelect) {
                levelSelect.addEventListener('change', async (e) => {
                    const newLevel = parseInt(e.target.value, 10);
                    if (!sessionToken) return;
                    try {
                        const response = await fetch(`${API_URL}/admin/users/${user.id}/level`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${sessionToken}`
                            },
                            body: JSON.stringify({ level: newLevel })
                        });
                        if (!response.ok) {
                            throw new Error('Failed to update user level');
                        }
                        showAdminMessage(`Updated ${user.email} to Level ${newLevel}`, 'success');
                    } catch (err) {
                        console.error('Error updating user level:', err);
                        showAdminMessage('Failed to update user level', 'error');
                        // revert select on error
                        e.target.value = String(level);
                    }
                });
            }
            
            const deleteBtn = row.querySelector('.admin-user-delete-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', async () => {
                    const confirmed = window.confirm(`Delete user "${user.email}"? This cannot be undone.`);
                    if (!confirmed || !sessionToken) return;
                    try {
                        const response = await fetch(`${API_URL}/admin/users/${user.id}`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${sessionToken}`
                            }
                        });
                        if (!response.ok) {
                            throw new Error('Failed to delete user');
                        }
                        row.remove();
                        showAdminMessage(`Deleted user ${user.email}`, 'success');
                    } catch (err) {
                        console.error('Error deleting user:', err);
                        showAdminMessage('Failed to delete user', 'error');
                    }
                });
            }
            
            usersTbody.appendChild(row);
        });
    }

    function formatAdminDate(dateString) {
        if (!dateString) return 'Never';
        const date = new Date(dateString);
        // Format: MM/DD/YYYY HH:MM:SS (local time)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${month}/${day}/${year} ${hours}:${minutes}:${seconds}`;
    }

    function showAdminMessage(text, type = 'success') {
        const adminMessage = document.getElementById('admin-message');
        adminMessage.textContent = text;
        adminMessage.className = `admin-message ${type}`;
        adminMessage.classList.remove('hidden');
        
        setTimeout(() => {
            adminMessage.classList.add('hidden');
        }, 5000);
    }

    async function logout() {
        console.log('üö™ Logout function called');
        const sessionToken = localStorage.getItem('sessionToken');
        console.log('Session token:', sessionToken ? 'exists' : 'not found');

        // Call backend logout endpoint to invalidate session
        if (sessionToken) {
            try {
                console.log('üì° Calling backend logout endpoint...');
                const response = await fetch(`${API_URL}/auth/logout`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${sessionToken}` }
                });
                console.log('Backend logout response:', response.status);
            } catch (error) {
                console.error('Error calling logout endpoint:', error);
                // Continue with logout even if backend call fails
            }
        }

        // Clear session token
        console.log('üßπ Clearing session token...');
        localStorage.removeItem('sessionToken');

        // Clear current user
        currentUser = null;
        console.log('üë§ Current user cleared');

        // Clear email display
        updateUserEmailDisplay();

        // Redirect to login page
        console.log('üîÑ Redirecting to login page...');
        window.location.href = '/login.html';
    }

    // Make functions globally available
    window.openSettings = openSettings;
    window.logout = logout;

    // Add event listener for logout button as backup
    document.addEventListener('DOMContentLoaded', function() {
        const logoutBtn = document.getElementById('nav-logout');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('üö™ Logout button clicked via event listener (sidebar footer)');
                logout();
            });
        }
    });

    // Share Project Functions
    function showShareProjectModal(project) {
        shareProjectName.textContent = project.name;
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        shareProjectModal.classList.remove('is-hidden');
        shareEmailInput.focus();

        // Store project data for sharing
        shareProjectModal.dataset.projectId = project.id;
        shareProjectModal.dataset.projectName = project.name;
    }

    function hideShareProjectModal() {
        shareProjectModal.classList.add('is-hidden');
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        delete shareProjectModal.dataset.projectId;
        delete shareProjectModal.dataset.projectName;
    }

    // Update Tag Modal Functions
    function showUpdateTagModal() {
        console.log('showUpdateTagModal called');

        // Reset state
        tagsToRemove.clear();
        removeAllTags = false;
        tagsToAdd.clear();

        // Hide success modal if visible
        tagUpdateSuccessModal.classList.add('is-hidden');

        // Reset Remove All Tags button
        const removeAllBtn = document.getElementById('remove-all-tags-btn');
        removeAllBtn.textContent = 'Remove All Tags';
        removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

        // Get all unique tags from selected images
        const originalTags = new Set();
        selectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags) {
                image.tags.forEach(tag => originalTags.add(tag));
            }
        });

        const sortedTags = Array.from(originalTags).sort();
        const tagCount = sortedTags.length;

        // Update modal header with tag count
        const updateTagHeader = document.querySelector('#update-tag-modal h2');
        if (updateTagHeader) {
            updateTagHeader.textContent = `Update Tags {#${tagCount}}`;
        }

        // Populate original tags list with X buttons based on selection count
        populateOriginalTagsList(sortedTags);

        // Clear new tags list and input
        newTagsList.innerHTML = '';
        newTagInput.value = '';
        tagWarning.classList.add('is-hidden');

        // Show modal
        updateTagModal.classList.remove('is-hidden');
    }

    function updateTagCount() {
        // Count all tags: original tags (not marked for removal) + new tags
        const originalTagElements = originalTagsList.querySelectorAll('.tag-item-removable:not(.marked-for-removal)');
        const newTagElements = newTagsList.querySelectorAll('.tag-item');
        const totalCount = originalTagElements.length + newTagElements.length;
        
        // Update modal header with tag count
        const updateTagHeader = document.querySelector('#update-tag-modal h2');
        if (updateTagHeader) {
            updateTagHeader.textContent = `Update Tags {#${totalCount}}`;
        }
    }

    function populateOriginalTagsList(tags) {
        originalTagsList.innerHTML = '';

        // Determine which tags are common to ALL selected images
        const commonTags = getCommonTagsFromSelectedImages();

        tags.forEach(tag => {
            const tagElement = document.createElement('div');
            tagElement.className = 'tag-item-removable';

            const tagText = document.createElement('span');
            tagText.textContent = tag;
            tagElement.appendChild(tagText);

            // Show X button if this tag is common to ALL selected images
            const isCommonTag = commonTags.includes(tag);
            if (isCommonTag) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => removeIndividualTag(tag);
                tagElement.appendChild(removeBtn);
            }

            originalTagsList.appendChild(tagElement);
        });
        
        // Update tag count after populating
        updateTagCount();
    }

    function getCommonTagsFromSelectedImages() {
        if (selectedImages.length === 0) return [];

        // Get tags from first image
        const firstImage = libraryImages.find(img => img.id === selectedImages[0]);
        if (!firstImage || !firstImage.tags) return [];

        let commonTags = [...firstImage.tags];

        // For each subsequent image, keep only tags that are also in that image
        for (let i = 1; i < selectedImages.length; i++) {
            const image = libraryImages.find(img => img.id === selectedImages[i]);
            if (!image || !image.tags) {
                return []; // If any image has no tags, no tags are common
            }
            commonTags = commonTags.filter(tag => image.tags.includes(tag));
        }

        return commonTags;
    }

    function hideUpdateTagModal() {
        updateTagModal.classList.add('is-hidden');
        originalTagsList.innerHTML = '';
        newTagsList.innerHTML = '';
        newTagInput.value = '';
        tagWarning.classList.add('is-hidden');

        // Reset state
        tagsToRemove.clear();
        removeAllTags = false;
        tagsToAdd.clear();

        // Reset Remove All Tags button
        const removeAllBtn = document.getElementById('remove-all-tags-btn');
        removeAllBtn.textContent = 'Remove All Tags';
        removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

        // Hide success modal if visible
        tagUpdateSuccessModal.classList.add('is-hidden');
    }

    function removeIndividualTag(tag) {
        const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
        const tagElement = Array.from(tagElements).find(element =>
            element.querySelector('span').textContent === tag
        );

        if (!tagElement) return;

        // Toggle removal state
        if (tagsToRemove.has(tag)) {
            // Currently marked for removal - undo it
            console.log('Unmarking tag for removal:', tag);
            tagsToRemove.delete(tag);
            tagElement.classList.remove('marked-for-removal');
        } else {
            // Not marked for removal - mark it
            console.log('Marking tag for removal:', tag);
            tagsToRemove.add(tag);
            tagElement.classList.add('marked-for-removal');
        }
        
        // Update tag count after removal state change
        updateTagCount();
    }

    function removeAllTagsFromSelected() {
        const removeAllBtn = document.getElementById('remove-all-tags-btn');

        if (!removeAllTags) {
            // Mark all tags for removal
            console.log('Marking all tags for removal');
            removeAllTags = true;
            removeAllBtn.textContent = 'Undo Remove All';
            removeAllBtn.style.backgroundColor = '#ff9800'; // Orange for undo

            // Visual feedback - dim all tags
            const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
            tagElements.forEach(element => {
                element.classList.add('marked-for-removal');
            });
        } else {
            // Undo remove all tags
            console.log('Undoing remove all tags');
            removeAllTags = false;
            removeAllBtn.textContent = 'Remove All Tags';
            removeAllBtn.style.backgroundColor = '#f44336'; // Red for remove

            // Remove visual feedback
            const tagElements = originalTagsList.querySelectorAll('.tag-item-removable');
            tagElements.forEach(element => {
                element.classList.remove('marked-for-removal');
            });
        }
        
        // Update tag count after remove all/undo
        updateTagCount();
    }

    function addNewTags() {
        const inputValue = newTagInput.value.trim();

        if (!inputValue) {
            tagWarning.classList.remove('is-hidden');
            setTimeout(() => {
                tagWarning.classList.add('is-hidden');
            }, 3000);
            return;
        }

        tagWarning.classList.add('is-hidden');

        // Split by comma and clean up tags
        const newTags = inputValue.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);

        newTags.forEach(tag => {
            if (!tagsToAdd.has(tag)) {
                tagsToAdd.add(tag);

                // Add to visual list with X button
                const tagElement = document.createElement('div');
                tagElement.className = 'tag-item tag-item-removable';

                const tagText = document.createElement('span');
                tagText.textContent = tag;
                tagElement.appendChild(tagText);

                const removeBtn = document.createElement('button');
                removeBtn.className = 'tag-remove-btn';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = () => removeNewTag(tag, tagElement);
                tagElement.appendChild(removeBtn);

                newTagsList.appendChild(tagElement);
            }
        });

        // Clear input
        newTagInput.value = '';
        updateTagCount(); // Update count after adding new tags
    }

    function removeNewTag(tag, tagElement) {
        console.log('Removing new tag:', tag);
        tagsToAdd.delete(tag);
        tagElement.remove();
        updateTagCount(); // Update count when tag is removed
    }

    function showTagUpdateSuccess() {
        // Show success modal
        tagUpdateSuccessModal.classList.remove('is-hidden');
    }

    function hideTagUpdateSuccess() {
        tagUpdateSuccessModal.classList.add('is-hidden');
    }

    function showTagRemovalNotification(tagText, deselectedCount) {
        // Update the message with specific details
        tagRemovalMessage.textContent = `Tag "${tagText}" removed and ${deselectedCount} image${deselectedCount !== 1 ? 's' : ''} deselected!`;

        // Show the notification modal
        tagRemovalNotificationModal.classList.remove('is-hidden');

        // Auto-hide after 3 seconds
        setTimeout(() => {
            hideTagRemovalNotification();
        }, 3000);
    }

    function hideTagRemovalNotification() {
        tagRemovalNotificationModal.classList.add('is-hidden');
    }

    // Tag Removal Confirmation Functions
    function showTagRemovalConfirmation(tagText) {
        // Count how many images have this tag from both selected and tag-selected images
        const imagesWithTag = [];
        const allSelectedImages = [...new Set([...selectedImages, ...tagSelectedImages])];

        allSelectedImages.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags && image.tags.includes(tagText)) {
                imagesWithTag.push(imageId);
            }
        });

        // Update modal content
        tagRemovalTagName.textContent = tagText;
        tagRemovalImageCount.textContent = imagesWithTag.length;

        // Store tag for removal action
        tagRemovalConfirmModal.dataset.tagToRemove = tagText;

        // Show modal
        tagRemovalConfirmModal.classList.remove('is-hidden');
    }

    function hideTagRemovalConfirmModal() {
        tagRemovalConfirmModal.classList.add('is-hidden');
        delete tagRemovalConfirmModal.dataset.tagToRemove;
    }

    function confirmTagRemoval() {
        const tagToRemove = tagRemovalConfirmModal.dataset.tagToRemove;
        if (tagToRemove) {
            // Hide confirmation modal first
            hideTagRemovalConfirmModal();

            // Remove the tag and clear its selected images
            if (isPoolView) {
                // In Selection Pool, preserve pool view behavior
                removeSearchTagChipInPoolView(tagToRemove);
            } else {
                // In Library view, remove chip and refresh highlights
                removeSearchTagChip(tagToRemove);
            }
        }
    }

    // Clear All Confirmation Functions
    function showClearAllConfirmation() {
        // Count current selections and tags
        const totalSelections = selectedImages.length + tagSelectedImages.length;
        const uniqueSelections = [...new Set([...selectedImages, ...tagSelectedImages])].length;
        const totalTags = searchTags.length;

        // Update modal content
        clearAllSelectionCount.textContent = uniqueSelections;
        clearAllTagCount.textContent = totalTags;

        // Show modal
        clearAllConfirmModal.classList.remove('is-hidden');
    }

    function hideClearAllConfirmModal() {
        clearAllConfirmModal.classList.add('is-hidden');
    }

    function confirmClearAll() {
        // Hide confirmation modal first
        hideClearAllConfirmModal();

        // Execute the clear all action
        clearAllSearchChips();
    }


    async function saveTagUpdates() {
        console.log('=== SAVE TAG UPDATES START ===');
        console.log('Selected images:', selectedImages);
        console.log('Selected images count:', selectedImages.length);
        console.log('Tags to remove:', Array.from(tagsToRemove));
        console.log('Remove all tags:', removeAllTags);
        console.log('Tags to add:', Array.from(tagsToAdd));

        // Check if there are any changes
        if (!removeAllTags && tagsToRemove.size === 0 && tagsToAdd.size === 0) {
            console.log('No changes to save');
            hideUpdateTagModal();
            return;
        }

        try {
            let successCount = 0;
            let errorCount = 0;
            const updateResults = [];

            // Process each selected image
            for (const imageId of selectedImages) {
                try {
                    console.log(`--- Processing image ${imageId} ---`);
                    const image = libraryImages.find(img => img.id === imageId);
                    if (!image) {
                        console.warn(`Image ${imageId} not found in libraryImages`);
                        continue;
                    }

                    const originalTags = image.tags ? [...image.tags] : [];
                    console.log(`Original tags for image ${imageId}:`, originalTags);

                    let currentTags = [...originalTags];

                    // Handle tag removal
                    if (removeAllTags) {
                        currentTags = [];
                        console.log(`Removing all tags from image ${imageId}`);
                    } else {
                        // Remove individual tags
                        tagsToRemove.forEach(tagToRemove => {
                            const beforeLength = currentTags.length;
                            currentTags = currentTags.filter(tag => tag !== tagToRemove);
                            const afterLength = currentTags.length;
                            if (beforeLength !== afterLength) {
                                console.log(`Removed tag "${tagToRemove}" from image ${imageId}`);
                            }
                        });
                    }

                    // Add new tags
                    tagsToAdd.forEach(tagToAdd => {
                        if (!currentTags.includes(tagToAdd)) {
                            currentTags.push(tagToAdd);
                            console.log(`Added tag "${tagToAdd}" to image ${imageId}`);
                        }
                    });

                    console.log(`Final tags for image ${imageId}:`, currentTags);

                    // Update the image in backend
                    await updateImageTags(imageId, currentTags);

                    // Update local image object
                    image.tags = currentTags;

                    successCount++;
                    updateResults.push({ imageId, status: 'success', tags: currentTags });
                    console.log(`‚úì Successfully updated image ${imageId}`);

                } catch (imageError) {
                    errorCount++;
                    updateResults.push({ imageId, status: 'error', error: imageError.message });
                    console.error(`‚úó Failed to update image ${imageId}:`, imageError);
                }
            }

            console.log('=== UPDATE SUMMARY ===');
            console.log(`Total images processed: ${selectedImages.length}`);
            console.log(`Successful updates: ${successCount}`);
            console.log(`Failed updates: ${errorCount}`);
            console.log('Update results:', updateResults);

            if (errorCount > 0) {
                console.warn(`${errorCount} images failed to update. Check the logs above for details.`);
                alert(`Warning: ${errorCount} out of ${selectedImages.length} images failed to update. Check the browser console for details.`);
            }

            console.log('Tag updates completed. Refreshing display...');

            // Refresh the library display
            await displayLibraryImages();

            // Close update tag modal first
            hideUpdateTagModal();

            // Show success modal
            showTagUpdateSuccess();

            console.log('=== SAVE TAG UPDATES END ===');

        } catch (error) {
            console.error('Critical error during tag updates:', error);
            alert('Failed to update tags. Please try again.');
        }
    }

    async function updateImageTags(imageId, tags) {
        console.log(`Updating tags for image ${imageId}:`, tags);
        console.log(`Making PUT request to: ${API_URL}/images/${imageId}/tags`);

        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {
                'Content-Type': 'application/json',
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            const response = await fetch(`${API_URL}/images/${imageId}/tags`, {
                method: 'PUT',
                headers: headers,
                body: JSON.stringify({ tags: tags })
            });

            console.log(`Response status: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Server error response:`, errorText);
                throw new Error(`Failed to update tags for image ${imageId}: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const result = await response.json();
            console.log(`Successfully updated tags for image ${imageId}:`, result);
            return result;
        } catch (error) {
            console.error(`Network or parsing error for image ${imageId}:`, error);
            throw error;
        }
    }

    // Delete Image Functions
    function showDeleteImageModal() {
        const totalSelected = selectedImages.length + tagSelectedImages.length;
        deleteCount.textContent = totalSelected;
        deleteImageModal.classList.remove('is-hidden');
    }

    function hideDeleteImageModal() {
        deleteImageModal.classList.add('is-hidden');
    }

    async function deleteSelectedImages() {
        try {
            // Get all selected image IDs (both manual and tag-selected)
            const allSelectedIds = [...new Set([...selectedImages, ...tagSelectedImages])];

            if (allSelectedIds.length === 0) {
                alert('No images selected for deletion.');
                return;
            }

            console.log(`Deleting ${allSelectedIds.length} images:`, allSelectedIds);

            // Delete each image
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            for (const imageId of allSelectedIds) {
                const response = await fetch(`${API_URL}/images/${imageId}`, {
                    method: 'DELETE',
                    headers: headers
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Failed to delete image ${imageId}:`, errorText);
                    console.error(`Response status: ${response.status}, Status text: ${response.statusText}`);
                    throw new Error(`Failed to delete image ${imageId}: ${response.status} ${response.statusText} - ${errorText}`);
                }

                console.log(`Successfully deleted image ${imageId}`);
            }

            // Clear all selections
            selectedImages = [];
            tagSelectedImages = [];
            imageSelectionSource = {};
            imageSelectionOrder = {};

            // Hide delete modal
            hideDeleteImageModal();

            // Return to library view with zero selections
            showingSelectionPool = false;
            isPoolView = false;

            // Refresh the library display
            await displayLibraryImages();

            console.log(`Successfully deleted ${allSelectedIds.length} images and returned to library`);

        } catch (error) {
            console.error('Error deleting images:', error);
            alert('Failed to delete some images. Please try again.');
        }
    }

    async function shareProject() {
        const email = shareEmailInput.value.trim();
        const message = shareMessageInput.value.trim();
        const projectId = shareProjectModal.dataset.projectId;
        const projectName = shareProjectModal.dataset.projectName;

        if (!email) {
            alert('Please enter a recipient email address.');
            shareEmailInput.focus();
            return;
        }

        if (!email.includes('@') || !email.includes('.')) {
            alert('Please enter a valid email address.');
            shareEmailInput.focus();
            return;
        }

        // Show loading state and overlay
        sendShareBtn.disabled = true;
        sendShareBtn.textContent = 'Sending...';
        hideShareProjectModal();
        emailSendingOverlay.classList.remove('is-hidden');

        try {
            // Get the project data to include breakdown in email
            const project = projects.find(p => p.id == projectId);
            const breakdownText = formatSelectionBreakdown(project?.selection_breakdown, project);

            console.log('=== EMAIL SHARING ===');
            console.log('Project for email:', project);
            console.log('Breakdown text being sent:', breakdownText);

            const emailData = {
                recipient_email: email,
                message: message,
                breakdown_text: breakdownText  // Send formatted breakdown to backend
            };

            console.log('Email data being sent to backend:', emailData);

            const sessionToken = localStorage.getItem('sessionToken');
            if (!sessionToken) {
                throw new Error('Not authenticated. Please log in again.');
            }

            const response = await fetch(`${API_URL}/projects/${projectId}/share`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${sessionToken}`
                },
                body: JSON.stringify(emailData)
            });

            if (response.status === 401 || response.status === 403) {
                throw new Error('Not authorized. Please log in again.');
            }

            if (response.ok) {
                emailSendingOverlay.classList.add('is-hidden');
                alert(`Project "${projectName}" has been shared successfully with ${email}!`);

                // Refresh email history displays immediately
                await refreshEmailHistoryDisplays(projectId);
            } else {
                const errorText = await response.text();
                throw new Error(errorText || 'Failed to share project');
            }
        } catch (error) {
            console.error('Error sharing project:', error);
            emailSendingOverlay.classList.add('is-hidden');
            alert(error.message || 'Failed to share project. Please try again.');
        } finally {
            // Reset button state
            sendShareBtn.disabled = false;
            sendShareBtn.textContent = 'Send Email';
            emailSendingOverlay.classList.add('is-hidden');
        }
    }

    // --- Event Listeners ---

    navLinks.library.addEventListener('click', (e) => { e.preventDefault(); navigateTo('library'); });
    navLinks.upload.addEventListener('click', (e) => { e.preventDefault(); navigateTo('upload'); });
    navLinks.project.addEventListener('click', (e) => { e.preventDefault(); navigateTo('project'); });
    if (navLinks.admin) {
        navLinks.admin.addEventListener('click', (e) => { 
            e.preventDefault(); 
            if (currentUser && currentUser.role === 'admin') {
                navigateTo('admin'); 
            } else {
                alert('Admin access required');
            }
        });
    }

    // Initialize: Load images when page first loads (if library page is visible)
    if (pages.library && !pages.library.classList.contains('is-hidden')) {
        console.log('Initial page load - loading library images');
        displayLibraryImages().catch(error => {
            console.error('Error loading images on initial page load:', error);
        });
    }

    // Always fetch persisted feeling frequencies on page load (refresh-safe)
    fetchSubjFrequencies();

    // Broken image notification dismiss
    document.getElementById('dismiss-notification').addEventListener('click', () => {
        // Hide notification immediately
        document.getElementById('broken-image-notification').classList.add('hidden');

        // Set persistent dismissal flag so it won't show again
        brokenImageNotificationDismissed = true;
        localStorage.setItem('brokenImageNotificationDismissed', 'true');

        console.log('Broken image notification dismissed permanently');
    });

    fileInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
    });

    clearAllButton.addEventListener('click', () => {
        previewGrid.innerHTML = '';
        filesToUpload = [];
        fileInput.value = '';
    });

    subjInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSubjCommit();
        }
    });

    // Add event listeners for all objective metadata inputs
    [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objWidthInput, objLengthInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
        if (input) {
            input.addEventListener('keydown', (e) => {
                // Special handling for width and length inputs - Tab should move focus without clearing
                if ((input === objWidthInput || input === objLengthInput) && e.key === 'Tab') {
                    // Allow Tab to work normally (move to next field) without clearing input
                    // Only commit if Enter or comma is pressed
                    if (e.key === 'Enter' || e.key === ',') {
                        e.preventDefault();
                        handleObjCommit(input);
                    }
                    // Tab key will work normally (no preventDefault)
                    return;
                }
                
                if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
                    e.preventDefault();
                    handleObjCommit(input);
                }
            });
        }
    });

    // Auto-fill button event listener
    autoFillBtn.addEventListener('click', autoFillMetadata);

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.add('is-dragover'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.remove('is-dragover'), false);
    });
    dropzone.addEventListener('drop', (e) => {
        handleFiles(e.dataTransfer.files);
    }, false);

    window.addEventListener('paste', (e) => {
        if (pages.upload.classList.contains('is-hidden')) return;
        handleFiles(e.clipboardData.files);
        dropzone.classList.add('is-dragover');
        setTimeout(() => dropzone.classList.remove('is-dragover'), 150);
    });

    prevButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex - 1);
        } else {
            showImage(currentImageIndex - 1);
        }
    });

    nextButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex + 1);
        } else {
            showImage(currentImageIndex + 1);
        }
    });

    closeModal.addEventListener('click', hideModal);


    // Add keyboard support for Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (!modal.classList.contains('is-hidden')) {
                hideModal();
            } else if (!tagRemovalConfirmModal.classList.contains('is-hidden')) {
                hideTagRemovalConfirmModal();
            } else if (!clearAllConfirmModal.classList.contains('is-hidden')) {
                hideClearAllConfirmModal();
            } else if (feelingsWarningModal && !feelingsWarningModal.classList.contains('is-hidden')) {
                feelingsWarningModal.classList.add('is-hidden');
                if (subjInput) {
                    subjInput.focus();
                }
            } else if (noImagesWarningModal && !noImagesWarningModal.classList.contains('is-hidden')) {
                noImagesWarningModal.classList.add('is-hidden');
                if (fileInput) {
                    fileInput.click();
                }
            } else if (dimensionWarningModal && !dimensionWarningModal.classList.contains('is-hidden')) {
                dimensionWarningModal.classList.add('is-hidden');
                if (objWidthInput) {
                    objWidthInput.focus();
                }
            }
        }
    });

    const loadingOverlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const uploadMoreBtn = document.getElementById('upload-more-btn');
    const goToLibraryBtn = document.getElementById('go-to-library-btn');
    const feelingsWarningModal = document.getElementById('feelings-warning-modal');
    const okFeelingsBtn = document.getElementById('ok-feelings-btn');
    const noImagesWarningModal = document.getElementById('no-images-warning-modal');
    const okNoImagesBtn = document.getElementById('ok-no-images-btn');
    const dimensionWarningModal = document.getElementById('dimension-warning-modal');
    const okDimensionBtn = document.getElementById('ok-dimension-btn');

    function clearUploadUI() {
        previewGrid.innerHTML = '';
        subjChips.innerHTML = '';
        objChips.innerHTML = '';

        // Clear all objective metadata inputs
        [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objWidthInput, objLengthInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
            if (input) input.value = '';
        });

        filesToUpload = [];
        fileInput.value = '';
    }

    uploadMoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
        // Refresh persisted frequencies so the next add-more flow shows latest counts
        fetchSubjFrequencies();
    });

    goToLibraryBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
        // Refresh persisted frequencies before navigating back to library
        fetchSubjFrequencies();
        navigateTo('library');
    });

    // Handle OK button for feelings warning modal
    if (okFeelingsBtn && feelingsWarningModal) {
        okFeelingsBtn.addEventListener('click', () => {
            feelingsWarningModal.classList.add('is-hidden');
            // Focus on subjective input
            if (subjInput) {
                subjInput.focus();
            }
        });
    }

    // Handle OK button for no images warning modal
    if (okNoImagesBtn && noImagesWarningModal) {
        okNoImagesBtn.addEventListener('click', () => {
            noImagesWarningModal.classList.add('is-hidden');
            // Focus on file input
            if (fileInput) {
                fileInput.click();
            }
        });
    }

    // Handle OK button for dimension warning modal
    if (okDimensionBtn && dimensionWarningModal) {
        okDimensionBtn.addEventListener('click', () => {
            dimensionWarningModal.classList.add('is-hidden');
            // Focus on width input
            if (objWidthInput) {
                objWidthInput.focus();
            }
        });
    }

    // Handle OK button for feelings warning modal
    if (okFeelingsBtn) {
        okFeelingsBtn.addEventListener('click', () => {
            feelingsWarningModal.classList.add('is-hidden');
            // Focus on subjective input
            if (subjInput) {
                subjInput.focus();
            }
        });
    }

    uploadButton.addEventListener('click', async () => {
        const subjTags = Array.from(subjChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[√óx]$/, '').trim());
        const objTags = Array.from(objChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[√óx]$/, '').trim());
        
        // Get width/length values from input fields
        const widthValue = objWidthInput ? objWidthInput.value.trim() : '';
        const lengthValue = objLengthInput ? objLengthInput.value.trim() : '';
        
        // Check if width/length are already in chips
        const hasWidthInChips = objTags.some(tag => tag.toLowerCase().startsWith('width:'));
        const hasLengthInChips = objTags.some(tag => tag.toLowerCase().startsWith('length:'));
        
        // Add width/length from input fields if they exist and aren't already in chips
        if (widthValue && !hasWidthInChips) {
            // Add prefix if not already present
            const widthTag = widthValue.toLowerCase().startsWith('width:') ? widthValue : `width:${widthValue}`;
            objTags.push(widthTag);
        }
        if (lengthValue && !hasLengthInChips) {
            // Add prefix if not already present
            const lengthTag = lengthValue.toLowerCase().startsWith('length:') ? lengthValue : `length:${lengthValue}`;
            objTags.push(lengthTag);
        }
        
        // Process all other objective inputs and add prefixes if needed
        const objectiveInputs = [
            { input: objBookInput, prefix: 'book:' },
            { input: objPageInput, prefix: 'page:' },
            { input: objRowInput, prefix: 'row:' },
            { input: objColumnInput, prefix: 'column:' },
            { input: objTypeInput, prefix: 'type:' },
            { input: objMaterialInput, prefix: 'material:' },
            { input: objRemarkInput, prefix: 'remark:' },
            { input: objBrandInput, prefix: 'brand:' },
            { input: objColorInput, prefix: 'color:' }
        ];
        
        objectiveInputs.forEach(({ input, prefix }) => {
            if (input && input.value.trim()) {
                const value = input.value.trim();
                const hasInChips = objTags.some(tag => tag.toLowerCase().startsWith(prefix));
                if (!hasInChips) {
                    // Add prefix if not already present
                    const tag = value.toLowerCase().startsWith(prefix) ? value : `${prefix}${value}`;
                    objTags.push(tag);
                }
            }
        });
        
        const allTags = [...subjTags, ...objTags];

        if (filesToUpload.length === 0) {
            // Show warning modal instead of alert
            if (noImagesWarningModal) {
                noImagesWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        // Validate that at least one subjective tag (feeling) is added
        if (subjTags.length === 0) {
            // Show warning modal instead of alert
            if (feelingsWarningModal) {
                feelingsWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        // Validate that at least one dimension field (width or length) is filled
        if (!widthValue && !lengthValue && !hasWidthInChips && !hasLengthInChips) {
            // Show warning modal instead of alert
            if (dimensionWarningModal) {
                dimensionWarningModal.classList.remove('is-hidden');
            }
            return;
        }

        const formData = new FormData();
        filesToUpload.forEach(file => {
            formData.append('images', file);
        });
        formData.append('tags', JSON.stringify(allTags));

        uploadButton.disabled = true;
        loadingOverlay.classList.remove('is-hidden');

        try {
            const sessionToken = localStorage.getItem('sessionToken');
            const headers = {};
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                headers: headers,
                body: formData
            });

            loadingOverlay.classList.add('is-hidden');

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${errorText}`);
            }

            // Track tag creation timestamps for uploaded images
            const currentTimestamp = Date.now();
            allTags.forEach(tag => {
                if (!tagCreationOrder[tag]) {
                    tagCreationOrder[tag] = currentTimestamp;
                    console.log(`Tag "${tag}" first created during upload at:`, tagCreationOrder[tag]);
                }
            });
            saveTagCreationOrder();

            // Clear the upload form
            clearUploadUI();
            
            // Reload images to show the newly uploaded ones
            await displayLibraryImages();

            // Refresh frequency list based on newly saved tags
            await fetchSubjFrequencies().then(() => {
                const now = new Date().toISOString();
                console.log(`[freq-refresh] Refreshed after upload at ${now}`);
            });

            // On success, show the custom confirmation dialog
            confirmModal.classList.remove('is-hidden');

        } catch (error) {
            console.error('Error uploading images:', error);
            alert(`An error occurred during upload. Please try again. Details: ${error.message}`);
            loadingOverlay.classList.add('is-hidden');
            uploadButton.disabled = false;
        }
    });





    // Handle tag input with Enter, Tab, comma, and autocomplete navigation
    librarySearchInput.addEventListener('keydown', async (e) => {
        if (autocompleteVisible) {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                highlightAutocompleteItem('down');
                return;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                highlightAutocompleteItem('up');
                return;
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideAutocomplete();
                return;
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectHighlightedItem()) {
                    return; // Item was selected from autocomplete
                }
                // Fall through to normal tag commit if no item highlighted
            }
        }

        if (e.key === 'Enter' || e.key === 'Tab') {
            e.preventDefault();
            await handleSearchTagCommit();
        }
        // Note: Backspace functionality for removing tag chips has been disabled
        // Users must use the "x" button on individual chips or "Clear All" button
    });

    // Handle autocomplete on input
    librarySearchInput.addEventListener('input', async (e) => {
        const value = e.target.value;
        const lastCommaIndex = value.lastIndexOf(',');

        // Get the current word being typed (after last comma or from beginning)
        const currentWord = lastCommaIndex === -1
            ? value.trim()
            : value.substring(lastCommaIndex + 1).trim();

        if (currentWord.length >= 2) {
            await showAutocomplete(currentWord);
        } else {
            hideAutocomplete();
        }
    });

    // Hide autocomplete when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-container')) {
            hideAutocomplete();
        }
    });

    // Also handle input changes for real-time search
    librarySearchInput.addEventListener('input', (e) => {
        console.log('=== INPUT EVENT TRIGGERED ===');
        console.log('Input value:', `"${e.target.value}"`);
        console.log('programmaticUpdate flag:', e.target.dataset.programmaticUpdate);
        console.log('isPoolView:', isPoolView);
        
        // IMPORTANT: Only clear chips if this is a USER action, not programmatic update
        // Check if we're in the middle of removing a single tag chip
        // ALSO: Don't clear all chips if we're in pool view to prevent losing pool context
        if (e.target.value === '' && !e.target.dataset.programmaticUpdate && !isPoolView) {
            console.log('CONDITIONS MET - calling clearAllSearchChips()');
            clearAllSearchChips();
        } else {
            console.log('CONDITIONS NOT MET - NOT calling clearAllSearchChips()');
            console.log('- value empty:', e.target.value === '');
            console.log('- not programmatic:', !e.target.dataset.programmaticUpdate);
            console.log('- not pool view:', !isPoolView);
        }
        console.log('=== INPUT EVENT END ===');
    });

    // Ensure input is fresh on focus
    librarySearchInput.addEventListener('focus', () => {
        // Clear any browser-suggested values on focus
        setTimeout(() => {
            if (librarySearchInput.value && searchTags.length === 0) {
                librarySearchInput.value = '';
            }
        }, 0);
    });

    // Prevent browser from storing values
    librarySearchInput.addEventListener('blur', () => {
        // Don't let browser remember the value
        librarySearchInput.setAttribute('autocomplete', 'new-password');
        setTimeout(() => {
            librarySearchInput.setAttribute('autocomplete', 'off');
        }, 100);
    });

    async function handleSearchTagCommit() {
        const inputValue = librarySearchInput.value.trim();
        if (!inputValue) return;

        console.log('=== ADDING SEARCH TAG ===');
        console.log('Before adding tag - selectedImages:', selectedImages);
        console.log('Before adding tag - tagSelectedImages:', tagSelectedImages);
        console.log('Before adding tag - isPoolView:', isPoolView);

        // Treat the whole input as a single tag (no comma splitting)
        await addSearchTagChip(inputValue);

        // Clear input and refresh search; keep autocomplete closed
        hideAutocomplete();
        autocompleteVisible = false;
        autocompleteHighlightIndex = -1;

        librarySearchInput.value = '';
        librarySearchInput.focus();

        console.log('About to call displayLibraryImages after adding tag');
        displayLibraryImages();
    }

    // Removed searchModeRadios event listener - using default OR mode

    // Clear all button (clears both tags and selected images)
    clearAllTagsBtn.addEventListener('click', () => {
        showClearAllConfirmation();
    });

    // Initialize button state
    updateClearButtonState();

    // Tag creation order persistence functions
    function saveTagCreationOrder() {
        try {
            localStorage.setItem('tagCreationOrder', JSON.stringify(tagCreationOrder));
        } catch (error) {
            console.error('Error saving tag creation order:', error);
        }
    }

    function loadTagCreationOrder() {
        try {
            const saved = localStorage.getItem('tagCreationOrder');
            if (saved) {
                tagCreationOrder = JSON.parse(saved);
                console.log('Loaded tag creation order:', tagCreationOrder);
            }
        } catch (error) {
            console.error('Error loading tag creation order:', error);
            tagCreationOrder = {};
        }
    }





    // Initialize search input to be completely fresh
    initializeFreshSearchInput();

    // Load tag creation order from localStorage
    loadTagCreationOrder();

    // Selection and project event listeners
    selectAllBtn.addEventListener('click', selectAllImages);
    deselectAllBtn.addEventListener('click', deselectAllImages);
    updateTagBtn.addEventListener('click', () => {
        console.log('Update Tag button clicked - showing modal');
        showUpdateTagModal();
    });
    deleteImageBtn.addEventListener('click', () => {
        console.log('Delete Image button clicked - showing modal');
        showDeleteImageModal();
    });
    viewPoolBtn.addEventListener('click', handleViewPoolClick);
    backToLibraryBtn.addEventListener('click', backToLibrary);
    addToProjectBtn.addEventListener('click', showProjectNameModal);
    cancelProjectBtn.addEventListener('click', hideProjectNameModal);
    createProjectBtn.addEventListener('click', createProject);

    // Project created confirmation modal event listeners
    addMoreProjectsBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Stay in current view to allow selecting more images for another project
        console.log('User chose to add more projects');
    });

    goToProjectBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Navigate to the project page
        navigateTo('project');
        console.log('User chose to go to project page');
    });

    // Project detail modal event listeners
    closeProjectDetailBtn.addEventListener('click', hideProjectDetailModal);

    // Project search functionality
    projectSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        filterProjects(searchTerm);
    });

    projectFilterBtn.addEventListener('click', () => {
        // Future: Add advanced filtering options
        console.log('Filter button clicked - future feature');
    });

    // Project view toggle event listener
    projectViewToggleBtn.addEventListener('click', toggleProjectView);

    // Image preview overlay event listeners
    previewOverlayClose.addEventListener('click', hideImagePreviewOverlay);

    // Real-size display settings and calibration
    const previewOverlaySettings = document.getElementById('preview-overlay-settings');
    const realSizeSettingsModal = document.getElementById('real-size-settings-modal');
    const closeSettingsModalBtn = document.getElementById('close-settings-modal');
    const manualDPIInput = document.getElementById('manual-dpi-input');
    const applyManualDPI = document.getElementById('apply-manual-dpi');
    const resetManualDPI = document.getElementById('reset-manual-dpi');
    const openCalibrationTool = document.getElementById('open-calibration-tool');
    const calibrationToolModal = document.getElementById('calibration-tool-modal');
    const closeCalibrationModalBtn = document.getElementById('close-calibration-modal');
    const calibrationDPISlider = document.getElementById('calibration-dpi-slider');
    const calibrationDPIValue = document.getElementById('calibration-dpi-value');
    const saveCalibratedDPI = document.getElementById('save-calibrated-dpi');
    const cancelCalibration = document.getElementById('cancel-calibration');
    const detectedDPIDisplay = document.getElementById('detected-dpi-display');
    const calibrationObject = document.getElementById('calibration-object');

    // Update detected DPI display
    function updateDetectedDPIDisplay() {
        const currentDPI = getCurrentDPI();
        const dpiSource = calibratedDPI ? 'Calibrated' : (manualDPI ? 'Manual' : 'Auto-detected');
        detectedDPIDisplay.textContent = `${currentDPI.toFixed(1)} (${dpiSource})`;
    }

    // Open settings modal
    if (previewOverlaySettings) {
        previewOverlaySettings.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            updateDetectedDPIDisplay();
            if (manualDPI) {
                manualDPIInput.value = manualDPI;
            }
            realSizeSettingsModal.classList.remove('is-hidden');
        });
    }

    // Close settings modal
    function closeSettingsModal() {
        realSizeSettingsModal.classList.add('is-hidden');
    }

    if (closeSettingsModalBtn) {
        closeSettingsModalBtn.addEventListener('click', closeSettingsModal);
    }

    // Close settings modal when clicking outside
    if (realSizeSettingsModal) {
        realSizeSettingsModal.addEventListener('click', (e) => {
            if (e.target === realSizeSettingsModal) {
                closeSettingsModal();
            }
        });
    }

    // Apply manual DPI
    if (applyManualDPI) {
        applyManualDPI.addEventListener('click', () => {
            const dpiValue = parseFloat(manualDPIInput.value);
            if (dpiValue && dpiValue >= 72 && dpiValue <= 300) {
                manualDPI = dpiValue;
                localStorage.setItem('manualDPI', dpiValue.toString());
                updateDetectedDPIDisplay();
                alert(`Manual DPI set to ${dpiValue.toFixed(1)}. Real size display will use this value.`);
            } else {
                alert('Please enter a valid DPI between 72 and 300.');
            }
        });
    }

    // Reset manual DPI
    if (resetManualDPI) {
        resetManualDPI.addEventListener('click', () => {
            manualDPI = null;
            localStorage.removeItem('manualDPI');
            manualDPIInput.value = '';
            updateDetectedDPIDisplay();
            alert('Manual DPI reset. Using auto-detected DPI.');
        });
    }

    // Open calibration tool
    if (openCalibrationTool) {
        openCalibrationTool.addEventListener('click', () => {
            realSizeSettingsModal.classList.add('is-hidden');
            const currentDPI = getCurrentDPI();
            calibrationDPISlider.value = currentDPI;
            calibrationDPIValue.textContent = currentDPI.toFixed(1);
            updateCalibrationPreview();
            calibrationToolModal.classList.remove('is-hidden');
        });
    }

    // Close calibration modal
    function closeCalibrationModal() {
        calibrationToolModal.classList.add('is-hidden');
    }

    if (closeCalibrationModalBtn) {
        closeCalibrationModalBtn.addEventListener('click', closeCalibrationModal);
    }

    if (cancelCalibration) {
        cancelCalibration.addEventListener('click', closeCalibrationModal);
    }

    // Close calibration modal when clicking outside
    if (calibrationToolModal) {
        calibrationToolModal.addEventListener('click', (e) => {
            if (e.target === calibrationToolModal) {
                closeCalibrationModal();
            }
        });
    }

    // Update calibration preview size
    function updateCalibrationPreview() {
        const dpi = parseFloat(calibrationDPISlider.value);
        const widthMm = 85.6; // Credit card width
        const lengthMm = 53.98; // Credit card length
        const widthPx = mmToPixels(widthMm, dpi);
        const lengthPx = mmToPixels(lengthMm, dpi);
        
        calibrationObject.style.width = `${widthPx}px`;
        calibrationObject.style.height = `${lengthPx}px`;
    }

    // Calibration DPI slider
    if (calibrationDPISlider) {
        calibrationDPISlider.addEventListener('input', (e) => {
            const dpi = parseFloat(e.target.value);
            calibrationDPIValue.textContent = dpi.toFixed(1);
            updateCalibrationPreview();
        });
    }

    // Save calibrated DPI
    if (saveCalibratedDPI) {
        saveCalibratedDPI.addEventListener('click', () => {
            const dpi = parseFloat(calibrationDPISlider.value);
            calibratedDPI = dpi;
            localStorage.setItem('calibratedDPI', dpi.toString());
            updateDetectedDPIDisplay();
            calibrationToolModal.classList.add('is-hidden');
            alert(`Calibrated DPI saved: ${dpi.toFixed(1)}. This will be used for all real size displays.`);
        });
    }

    // Initialize DPI display
    updateDetectedDPIDisplay();

    // Close overlay when clicking outside the image
    imagePreviewOverlay.addEventListener('click', (e) => {
        if (e.target === imagePreviewOverlay) {
            hideImagePreviewOverlay();
        }
    });

    // Navigation arrow event listeners
    previewNavLeft.addEventListener('click', () => {
        navigatePreview('left');
    });

    previewNavRight.addEventListener('click', () => {
        navigatePreview('right');
    });

    // Close overlay with Escape key and add arrow key scrolling/navigation
    document.addEventListener('keydown', (e) => {
        if (imagePreviewOverlay.classList.contains('show')) {
            if (e.key === 'Escape') {
                hideImagePreviewOverlay();
            } else if (isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePreview('left');
            } else if (isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                navigatePreview('right');
            } else if (!isSelectionPoolPreview && e.key === 'ArrowUp') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowDown') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop += 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft += 50;
            } else if (!tagDeleteConfirmModal.classList.contains('is-hidden') && e.key === 'Escape') {
                pendingTagDelete = null;
                tagDeleteConfirmModal.classList.add('is-hidden');
            }
        }
    });

    // Project name input enter key
    projectNameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            createProject();
        } else if (e.key === 'Escape') {
            hideProjectNameModal();
        }
    });

    // Share project modal event listeners
    shareProjectClose.addEventListener('click', hideShareProjectModal);
    cancelShareBtn.addEventListener('click', hideShareProjectModal);
    sendShareBtn.addEventListener('click', shareProject);

    // Update tag modal event listeners
    updateTagClose.addEventListener('click', hideUpdateTagModal);
    updateTagCancel.addEventListener('click', hideUpdateTagModal);
    updateTagSave.addEventListener('click', saveTagUpdates);
    addNewTagBtn.addEventListener('click', addNewTags);
    removeAllTagsBtn.addEventListener('click', removeAllTagsFromSelected);
    tagUpdateContinueBtn.addEventListener('click', hideTagUpdateSuccess);
    tagRemovalContinueBtn.addEventListener('click', hideTagRemovalNotification);

    // Delete image modal event listeners
    deleteImageClose.addEventListener('click', hideDeleteImageModal);
    cancelDeleteBtn.addEventListener('click', hideDeleteImageModal);
    confirmDeleteBtn.addEventListener('click', deleteSelectedImages);

    // Tag removal confirmation modal event listeners
    tagRemovalConfirmClose.addEventListener('click', hideTagRemovalConfirmModal);
    tagRemovalCancelBtn.addEventListener('click', hideTagRemovalConfirmModal);
    tagRemovalConfirmBtn.addEventListener('click', confirmTagRemoval);
    if (tagDeleteCancelBtn) {
        tagDeleteCancelBtn.addEventListener('click', () => {
            pendingTagDelete = null;
            tagDeleteConfirmModal.classList.add('is-hidden');
        });
    }
    if (tagDeleteConfirmBtn) {
        tagDeleteConfirmBtn.addEventListener('click', confirmRemoveTagFromImage);
    }
    if (lightboxSaveBtn) {
        lightboxSaveBtn.addEventListener('click', () => {
            const current = libraryImages[currentImageIndex];
            if (current) {
                saveLightboxTagChanges(current.id, { closeAfterSave: true });
            }
        });
    }

    // Clear all confirmation modal event listeners
    clearAllConfirmClose.addEventListener('click', hideClearAllConfirmModal);
    clearAllCancelBtn.addEventListener('click', hideClearAllConfirmModal);
    clearAllConfirmBtn.addEventListener('click', confirmClearAll);

    // Add tag input enter key support
    newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            addNewTags();
        }
    });

    // Share email input enter key (only Enter, no ESC)
    shareEmailInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            shareProject();
        }
    });

    // Check authentication and load projects on startup
    checkAuthentication().then(isAuthenticated => {
        if (isAuthenticated) {
            loadProjectsFromAPI().then(() => {
                displayProjects();
            });
        }
    });


  </script>
</body>
</html>

